###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        26/Jul/2016  23:31:19
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\Vcan_touch.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\Vcan_touch.c -D
#        DEBUG -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\Vcan_touch.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\Vcan_touch.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\Vcan_touch.c
      1          #include "common.h"
      2          #include "MK60_port.h"
      3          #include "MK60_gpio.h"
      4          #include "MK60_spi.h"
      5          
      6          #include "VCAN_LCD.h"
      7          #include "Vcan_touch.h"
      8          
      9          
     10          #define XPT2046_INT_IN    PTX_T(TOUCH_INT_PTXn,IN)
     11          
     12          #define USE_TSLIB       1
     13          
     14          #if (USE_TSLIB )
     15          #define  TOUCH_COUNT    5
     16          
     17          typedef struct {
     18              //x[5]/y[5] 是触摸值，xfb[5]/yfb[5] 是LCD坐标。a[7]是校正参数
     19              int x[TOUCH_COUNT], xfb[TOUCH_COUNT];
     20              int y[TOUCH_COUNT], yfb[TOUCH_COUNT];
     21              int a[7];
     22          } calibration;
     23          
     24          #else
     25          #define  TOUCH_COUNT    4
     26          
     27          typedef struct {
     28              //x[5]/y[5] 是触摸值，xfb[5]/yfb[5] 是LCD坐标。a[7]是校正参数
     29              int x[TOUCH_COUNT], xfb[TOUCH_COUNT];
     30              int y[TOUCH_COUNT], yfb[TOUCH_COUNT];
     31              float a[7];
     32          } calibration;
     33          
     34          #endif
     35          
     36          

   \                                 In section .bss, align 4
     37          static uint32 touch_baud;
   \                     touch_baud:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     38          static uint32 touch_delay;
   \                     touch_delay:
   \   00000000                      DS8 4
     39          

   \                                 In section .bss, align 4
     40          static calibration cal;
   \                     cal:
   \   00000000                      DS8 108
     41          
     42          
     43          static int perform_calibration(calibration *cal);
     44          
     45          
     46          /*
     47           * 触摸模拟SPI IO 和 中断 IO 初始化
     48           */

   \                                 In section .text, align 2, keep-with-next
     49          void touch_init(void)
     50          {
   \                     touch_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     51              touch_baud = spi_init(TOUCH_SPI, TOUCH_CS, MASTER,150*1000);               //初始化SPI,主机模式
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable6  ;; 0x249f0
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       spi_init
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000014   0x6008             STR      R0,[R1, #+0]
     52          
     53              port_init(TOUCH_INT_PTXn,ALT1  | PULLUP | IRQ_FALLING);         //上拉、下降沿触发中断
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable6_2  ;; 0xa0103
   \   0000001A   0x2029             MOVS     R0,#+41
   \   0000001C   0x.... 0x....      BL       port_init
     54          
     55              touch_delay = 8*1000*1000 / touch_baud;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable6_3  ;; 0x7a1200
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000032   0x6008             STR      R0,[R1, #+0]
     56          
     57              //gpio_init(TOUCH_CS_PTXn,GPO,0);
     58          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
     59          
     60          /******************************************************
     61          * 函数名：Touchl_Calibrate
     62          * 描述  ：触摸屏校正函数
     63          * 输入  : 无
     64          * 输出  ：1 --- 校正成功
     65                              0   --- 校正失败
     66          * 举例  ：无
     67          * 注意  ：无
     68          *********************************************************/

   \                                 In section .text, align 2, keep-with-next
     69          int touch_calibrate(void)
     70          {
   \                     touch_calibrate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     71              uint16 lcd_h = LCD_H;
   \   00000004   0x.... 0x....      BL       ILI9341_get_h
   \   00000008   0x0004             MOVS     R4,R0
     72              uint16 lcd_w = LCD_W;
   \   0000000A   0x.... 0x....      BL       ILI9341_get_w
   \   0000000E   0x0005             MOVS     R5,R0
     73              uint8 i;
     74              Site_t site;
     75          
     76              //设置触摸屏校验点的位置
     77              cal.xfb[0] = 40;
   \   00000010   0x2028             MOVS     R0,#+40
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000016   0x6148             STR      R0,[R1, #+20]
     78              cal.yfb[0] = 40;
   \   00000018   0x2028             MOVS     R0,#+40
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   0000001E   0x63C8             STR      R0,[R1, #+60]
     79          
     80              cal.xfb[1] = 40;
   \   00000020   0x2028             MOVS     R0,#+40
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000026   0x6188             STR      R0,[R1, #+24]
     81              cal.yfb[1] = lcd_h - 40;
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0xF1B4 0x0028      SUBS     R0,R4,#+40
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000032   0x6408             STR      R0,[R1, #+64]
     82          
     83              cal.xfb[2] = lcd_w - 40;
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0xF1B5 0x0028      SUBS     R0,R5,#+40
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   0000003E   0x61C8             STR      R0,[R1, #+28]
     84              cal.yfb[2] = lcd_h - 40;
   \   00000040   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000042   0xF1B4 0x0028      SUBS     R0,R4,#+40
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   0000004A   0x6448             STR      R0,[R1, #+68]
     85          
     86              cal.xfb[3] = lcd_w -40;
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0xF1B5 0x0028      SUBS     R0,R5,#+40
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000056   0x6208             STR      R0,[R1, #+32]
     87              cal.yfb[3] = 40;
   \   00000058   0x2028             MOVS     R0,#+40
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   0000005E   0x6488             STR      R0,[R1, #+72]
     88          
     89          #if (USE_TSLIB )
     90              cal.xfb[4] = lcd_w/2;
   \   00000060   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   0000006C   0x6248             STR      R0,[R1, #+36]
     91              cal.yfb[4] = lcd_h/2;
   \   0000006E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   0000007A   0x64C8             STR      R0,[R1, #+76]
     92          #endif
     93          
     94              //循环显示5个触摸校验点，并获取触摸值
     95              for(i = 0; i< TOUCH_COUNT;i++)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x0006             MOVS     R6,R0
   \                     ??touch_calibrate_0: (+1)
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x2E05             CMP      R6,#+5
   \   00000084   0xDA32             BGE.N    ??touch_calibrate_1
     96              {
     97                  LCD_clear(BCOLOUR);                     //清屏
   \   00000086   0xF44F 0x4078      MOV      R0,#+63488
   \   0000008A   0x.... 0x....      BL       LCD_clear
     98          
     99                  DELAY_MS(500);                          //延时，否则按得太快，导致触摸失败
   \   0000008E   0xF44F 0x70FA      MOV      R0,#+500
   \   00000092   0x.... 0x....      BL       systick_delay_ms
    100          
    101                  site.x = cal.xfb[i];            //LCD显示触摸点十字图案
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   0000009A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009C   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   000000A0   0x6940             LDR      R0,[R0, #+20]
   \   000000A2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    102                  site.y = cal.yfb[i];
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   000000AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AC   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   000000B0   0x6BC0             LDR      R0,[R0, #+60]
   \   000000B2   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    103                  LCD_cross(site,10,FCOLOUR);
   \   000000B6   0x221F             MOVS     R2,#+31
   \   000000B8   0x210A             MOVS     R1,#+10
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   \   000000BC   0x.... 0x....      BL       LCD_cross
    104          
    105                  while(!xpt2046_read(&site));            //等待获取触摸点位置
   \                     ??touch_calibrate_2: (+1)
   \   000000C0   0xA800             ADD      R0,SP,#+0
   \   000000C2   0x.... 0x....      BL       xpt2046_read
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD0FA             BEQ.N    ??touch_calibrate_2
    106                  cal.x[i] = site.x;
   \   000000CA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   000000D2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D4   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
    107                  cal.y[i] = site.y;
   \   000000D8   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   000000E0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E2   0xEB11 0x0186      ADDS     R1,R1,R6, LSL #+2
   \   000000E6   0x6288             STR      R0,[R1, #+40]
    108              }
   \   000000E8   0x1C76             ADDS     R6,R6,#+1
   \   000000EA   0xE7C9             B.N      ??touch_calibrate_0
    109          
    110              LCD_clear(BCOLOUR);                     //清屏
   \                     ??touch_calibrate_1: (+1)
   \   000000EC   0xF44F 0x4078      MOV      R0,#+63488
   \   000000F0   0x.... 0x....      BL       LCD_clear
    111          
    112          
    113              //进行触摸校正
    114              if( perform_calibration(&cal) )
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   000000F8   0x.... 0x....      BL       perform_calibration
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD001             BEQ.N    ??touch_calibrate_3
    115              {
    116                  return 1;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0xE000             B.N      ??touch_calibrate_4
    117              }
    118              else
    119              {
    120                  return 0;
   \                     ??touch_calibrate_3: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \                     ??touch_calibrate_4: (+1)
   \   00000106   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    121              }
    122          }
    123          

   \                                 In section .text, align 2, keep-with-next
    124          int touch_get_point(Site_t *site)
    125          {
   \                     touch_get_point: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    126              Site_t sitetmp;
    127          
    128              if(xpt2046_read(&sitetmp))
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      BL       xpt2046_read
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD053             BEQ.N    ??touch_get_point_0
    129              {
    130          #if (USE_TSLIB )
    131                  site->x =( cal.a[0]
    132                           + cal.a[1] * sitetmp.x
    133                           + cal.a[2] * sitetmp.y)/cal.a[6];
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   00000014   0x6D00             LDR      R0,[R0, #+80]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   0000001A   0x6D49             LDR      R1,[R1, #+84]
   \   0000001C   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   00000020   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000028   0x6D89             LDR      R1,[R1, #+88]
   \   0000002A   0xF8BD 0x2002      LDRH     R2,[SP, #+2]
   \   0000002E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000036   0x6E89             LDR      R1,[R1, #+104]
   \   00000038   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000003C   0x8020             STRH     R0,[R4, #+0]
    134                  site->y =( cal.a[3]
    135                           + cal.a[4] * sitetmp.x
    136                           + cal.a[5] * sitetmp.y)/cal.a[6];
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   00000042   0x6DC0             LDR      R0,[R0, #+92]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000048   0x6E09             LDR      R1,[R1, #+96]
   \   0000004A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   0000004E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000056   0x6E49             LDR      R1,[R1, #+100]
   \   00000058   0xF8BD 0x2002      LDRH     R2,[SP, #+2]
   \   0000005C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \   00000064   0x6E89             LDR      R1,[R1, #+104]
   \   00000066   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000006A   0x8060             STRH     R0,[R4, #+2]
    137          #else
    138                  site->x =( cal.a[0] * sitetmp.x
    139                           + cal.a[1] * sitetmp.y
    140                           + cal.a[2]             )/cal.a[6];
    141                  site->y =( cal.a[3] * sitetmp.x
    142                           + cal.a[4] * sitetmp.y
    143                           + cal.a[5]             )/cal.a[6];
    144          
    145          #endif
    146                  if((int16)site->x < 0)site->x = 0;
   \   0000006C   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   00000070   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD502             BPL.N    ??touch_get_point_1
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x8020             STRH     R0,[R4, #+0]
   \   0000007A   0xE009             B.N      ??touch_get_point_2
    147                  else if(site->x >= LCD_W ) site->x = LCD_W-1;
   \                     ??touch_get_point_1: (+1)
   \   0000007C   0x.... 0x....      BL       ILI9341_get_w
   \   00000080   0x8821             LDRH     R1,[R4, #+0]
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x4281             CMP      R1,R0
   \   00000086   0xD303             BCC.N    ??touch_get_point_2
   \   00000088   0x.... 0x....      BL       ILI9341_get_w
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x8020             STRH     R0,[R4, #+0]
    148                  if((int16)site->y < 0)site->y = 0;
   \                     ??touch_get_point_2: (+1)
   \   00000090   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \   00000094   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD502             BPL.N    ??touch_get_point_3
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x8060             STRH     R0,[R4, #+2]
   \   0000009E   0xE009             B.N      ??touch_get_point_4
    149                  else if(site->y >= LCD_H ) site->y = LCD_H-1;
   \                     ??touch_get_point_3: (+1)
   \   000000A0   0x.... 0x....      BL       ILI9341_get_h
   \   000000A4   0x8861             LDRH     R1,[R4, #+2]
   \   000000A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A8   0x4281             CMP      R1,R0
   \   000000AA   0xD303             BCC.N    ??touch_get_point_4
   \   000000AC   0x.... 0x....      BL       ILI9341_get_h
   \   000000B0   0x1E40             SUBS     R0,R0,#+1
   \   000000B2   0x8060             STRH     R0,[R4, #+2]
    150                  return 1;
   \                     ??touch_get_point_4: (+1)
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xE000             B.N      ??touch_get_point_5
    151              }
    152              else
    153              {
    154                  return 0;
   \                     ??touch_get_point_0: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \                     ??touch_get_point_5: (+1)
   \   000000BA   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    155              }
    156          
    157          }
    158          

   \                                 In section .text, align 2, keep-with-next
    159          int touch_load(touch_call_back_func func)
    160          {
   \                     touch_load: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    161              return func((uint8 *)&(cal.a[0]),sizeof(int)*7);
   \   00000004   0x211C             MOVS     R1,#+28
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   0000000A   0x47A0             BLX      R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          int touch_save(touch_call_back_func func)
    165          {
   \                     touch_save: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    166              return func((uint8 *)&(cal.a[0]),sizeof(int)*7);
   \   00000004   0x211C             MOVS     R1,#+28
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   0000000A   0x47A0             BLX      R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    167          }
    168          
    169          
    170          //tslib (touchscreen library)

   \                                 In section .text, align 2, keep-with-next
    171          int perform_calibration(calibration *cal) {
   \                     perform_calibration: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x0004             MOVS     R4,R0
    172          #if (USE_TSLIB )
    173          
    174              int j;
    175              float n, x, y, x2, y2, xy, z, zx, zy;
    176              float det, a, b, c, e, f, i;
    177              float scaling = 65536.0;
   \   00000008   0xF05F 0x408F      MOVS     R0,#+1199570944
   \   0000000C   0x9004             STR      R0,[SP, #+16]
    178          
    179          // Get sums for matrix
    180              n = x = y = x2 = y2 = xy = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0x9005             STR      R0,[SP, #+20]
   \   00000014   0x9006             STR      R0,[SP, #+24]
   \   00000016   0x4682             MOV      R10,R0
   \   00000018   0x9002             STR      R0,[SP, #+8]
   \   0000001A   0x4683             MOV      R11,R0
    181              for(j=0;j<5;j++) {
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0005             MOVS     R5,R0
   \                     ??perform_calibration_0: (+1)
   \   00000020   0x2D05             CMP      R5,#+5
   \   00000022   0xDA41             BGE.N    ??perform_calibration_1
    182                  n += 1.0;
   \   00000024   0x4658             MOV      R0,R11
   \   00000026   0x.... 0x....      BL       __aeabi_f2d
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable6_7  ;; 0x3ff00000
   \   00000030   0x.... 0x....      BL       __aeabi_dadd
   \   00000034   0x.... 0x....      BL       __aeabi_d2f
   \   00000038   0x4683             MOV      R11,R0
    183                  x += (float)cal->x[j];
   \   0000003A   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   0000003E   0x.... 0x....      BL       __aeabi_i2f
   \   00000042   0x9902             LDR      R1,[SP, #+8]
   \   00000044   0x.... 0x....      BL       __aeabi_fadd
   \   00000048   0x9002             STR      R0,[SP, #+8]
    184                  y += (float)cal->y[j];
   \   0000004A   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000004E   0x6A80             LDR      R0,[R0, #+40]
   \   00000050   0x.... 0x....      BL       __aeabi_i2f
   \   00000054   0x4651             MOV      R1,R10
   \   00000056   0x.... 0x....      BL       __aeabi_fadd
   \   0000005A   0x4682             MOV      R10,R0
    185                  x2 += (float)(cal->x[j]*cal->x[j]);
   \   0000005C   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   00000060   0xF854 0x1025      LDR      R1,[R4, R5, LSL #+2]
   \   00000064   0x4348             MULS     R0,R1,R0
   \   00000066   0x.... 0x....      BL       __aeabi_i2f
   \   0000006A   0x9906             LDR      R1,[SP, #+24]
   \   0000006C   0x.... 0x....      BL       __aeabi_fadd
   \   00000070   0x9006             STR      R0,[SP, #+24]
    186                  y2 += (float)(cal->y[j]*cal->y[j]);
   \   00000072   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000076   0x6A80             LDR      R0,[R0, #+40]
   \   00000078   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   0000007C   0x6A89             LDR      R1,[R1, #+40]
   \   0000007E   0x4348             MULS     R0,R1,R0
   \   00000080   0x.... 0x....      BL       __aeabi_i2f
   \   00000084   0x9905             LDR      R1,[SP, #+20]
   \   00000086   0x.... 0x....      BL       __aeabi_fadd
   \   0000008A   0x9005             STR      R0,[SP, #+20]
    187                  xy += (float)(cal->x[j]*cal->y[j]);
   \   0000008C   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   00000090   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000094   0x6A89             LDR      R1,[R1, #+40]
   \   00000096   0x4348             MULS     R0,R1,R0
   \   00000098   0x.... 0x....      BL       __aeabi_i2f
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fadd
   \   000000A2   0x4681             MOV      R9,R0
    188              }
   \   000000A4   0x1C6D             ADDS     R5,R5,#+1
   \   000000A6   0xE7BB             B.N      ??perform_calibration_0
    189          
    190          // Get determinant of matrix -- check if determinant is too small
    191              det = n*(x2*y2 - xy*xy) + x*(xy*y - x*y2) + y*(x*xy - y*x2);
   \                     ??perform_calibration_1: (+1)
   \   000000A8   0x9906             LDR      R1,[SP, #+24]
   \   000000AA   0x9805             LDR      R0,[SP, #+20]
   \   000000AC   0x.... 0x....      BL       __aeabi_fmul
   \   000000B0   0x9000             STR      R0,[SP, #+0]
   \   000000B2   0x4648             MOV      R0,R9
   \   000000B4   0x4649             MOV      R1,R9
   \   000000B6   0x.... 0x....      BL       __aeabi_fmul
   \   000000BA   0x0001             MOVS     R1,R0
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   \   000000BE   0x.... 0x....      BL       __aeabi_fsub
   \   000000C2   0x4659             MOV      R1,R11
   \   000000C4   0x.... 0x....      BL       __aeabi_fmul
   \   000000C8   0x9001             STR      R0,[SP, #+4]
   \   000000CA   0x4648             MOV      R0,R9
   \   000000CC   0x4651             MOV      R1,R10
   \   000000CE   0x.... 0x....      BL       __aeabi_fmul
   \   000000D2   0x9000             STR      R0,[SP, #+0]
   \   000000D4   0x9902             LDR      R1,[SP, #+8]
   \   000000D6   0x9805             LDR      R0,[SP, #+20]
   \   000000D8   0x.... 0x....      BL       __aeabi_fmul
   \   000000DC   0x0001             MOVS     R1,R0
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   \   000000E0   0x.... 0x....      BL       __aeabi_fsub
   \   000000E4   0x9902             LDR      R1,[SP, #+8]
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x9901             LDR      R1,[SP, #+4]
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x9001             STR      R0,[SP, #+4]
   \   000000F2   0x9802             LDR      R0,[SP, #+8]
   \   000000F4   0x4649             MOV      R1,R9
   \   000000F6   0x.... 0x....      BL       __aeabi_fmul
   \   000000FA   0x9000             STR      R0,[SP, #+0]
   \   000000FC   0x9806             LDR      R0,[SP, #+24]
   \   000000FE   0x4651             MOV      R1,R10
   \   00000100   0x.... 0x....      BL       __aeabi_fmul
   \   00000104   0x0001             MOVS     R1,R0
   \   00000106   0x9800             LDR      R0,[SP, #+0]
   \   00000108   0x.... 0x....      BL       __aeabi_fsub
   \   0000010C   0x4651             MOV      R1,R10
   \   0000010E   0x.... 0x....      BL       __aeabi_fmul
   \   00000112   0x9901             LDR      R1,[SP, #+4]
   \   00000114   0x.... 0x....      BL       __aeabi_fadd
   \   00000118   0x9003             STR      R0,[SP, #+12]
    192              if(det < 0.1 && det > -0.1) {
   \   0000011A   0x9803             LDR      R0,[SP, #+12]
   \   0000011C   0x....             LDR.N    R1,??DataTable6_8  ;; 0x3dcccccd
   \   0000011E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000122   0xD206             BCS.N    ??perform_calibration_2
   \   00000124   0x9803             LDR      R0,[SP, #+12]
   \   00000126   0x....             LDR.N    R1,??DataTable6_9  ;; 0xbdcccccc
   \   00000128   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000012C   0xD801             BHI.N    ??perform_calibration_2
    193                  //printf("ts_calibrate: determinant is too small -- %f\n",det);
    194                  return 0;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xE15E             B.N      ??perform_calibration_3
    195              }
    196          
    197          // Get elements of inverse matrix
    198              a = (x2*y2 - xy*xy)/det;
   \                     ??perform_calibration_2: (+1)
   \   00000132   0x9906             LDR      R1,[SP, #+24]
   \   00000134   0x9805             LDR      R0,[SP, #+20]
   \   00000136   0x.... 0x....      BL       __aeabi_fmul
   \   0000013A   0x9000             STR      R0,[SP, #+0]
   \   0000013C   0x4648             MOV      R0,R9
   \   0000013E   0x4649             MOV      R1,R9
   \   00000140   0x.... 0x....      BL       __aeabi_fmul
   \   00000144   0x0001             MOVS     R1,R0
   \   00000146   0x9800             LDR      R0,[SP, #+0]
   \   00000148   0x.... 0x....      BL       __aeabi_fsub
   \   0000014C   0x9903             LDR      R1,[SP, #+12]
   \   0000014E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000152   0x900C             STR      R0,[SP, #+48]
    199              b = (xy*y - x*y2)/det;
   \   00000154   0x4648             MOV      R0,R9
   \   00000156   0x4651             MOV      R1,R10
   \   00000158   0x.... 0x....      BL       __aeabi_fmul
   \   0000015C   0x9000             STR      R0,[SP, #+0]
   \   0000015E   0x9902             LDR      R1,[SP, #+8]
   \   00000160   0x9805             LDR      R0,[SP, #+20]
   \   00000162   0x.... 0x....      BL       __aeabi_fmul
   \   00000166   0x0001             MOVS     R1,R0
   \   00000168   0x9800             LDR      R0,[SP, #+0]
   \   0000016A   0x.... 0x....      BL       __aeabi_fsub
   \   0000016E   0x9903             LDR      R1,[SP, #+12]
   \   00000170   0x.... 0x....      BL       __aeabi_fdiv
   \   00000174   0x9009             STR      R0,[SP, #+36]
    200              c = (x*xy - y*x2)/det;
   \   00000176   0x9802             LDR      R0,[SP, #+8]
   \   00000178   0x4649             MOV      R1,R9
   \   0000017A   0x.... 0x....      BL       __aeabi_fmul
   \   0000017E   0x9000             STR      R0,[SP, #+0]
   \   00000180   0x9806             LDR      R0,[SP, #+24]
   \   00000182   0x4651             MOV      R1,R10
   \   00000184   0x.... 0x....      BL       __aeabi_fmul
   \   00000188   0x0001             MOVS     R1,R0
   \   0000018A   0x9800             LDR      R0,[SP, #+0]
   \   0000018C   0x.... 0x....      BL       __aeabi_fsub
   \   00000190   0x9903             LDR      R1,[SP, #+12]
   \   00000192   0x.... 0x....      BL       __aeabi_fdiv
   \   00000196   0x9008             STR      R0,[SP, #+32]
    201              e = (n*y2 - y*y)/det;
   \   00000198   0x9805             LDR      R0,[SP, #+20]
   \   0000019A   0x4659             MOV      R1,R11
   \   0000019C   0x.... 0x....      BL       __aeabi_fmul
   \   000001A0   0x9000             STR      R0,[SP, #+0]
   \   000001A2   0x4650             MOV      R0,R10
   \   000001A4   0x4651             MOV      R1,R10
   \   000001A6   0x.... 0x....      BL       __aeabi_fmul
   \   000001AA   0x0001             MOVS     R1,R0
   \   000001AC   0x9800             LDR      R0,[SP, #+0]
   \   000001AE   0x.... 0x....      BL       __aeabi_fsub
   \   000001B2   0x9903             LDR      R1,[SP, #+12]
   \   000001B4   0x.... 0x....      BL       __aeabi_fdiv
   \   000001B8   0x900B             STR      R0,[SP, #+44]
    202              f = (x*y - n*xy)/det;
   \   000001BA   0x9802             LDR      R0,[SP, #+8]
   \   000001BC   0x4651             MOV      R1,R10
   \   000001BE   0x.... 0x....      BL       __aeabi_fmul
   \   000001C2   0x9000             STR      R0,[SP, #+0]
   \   000001C4   0x4658             MOV      R0,R11
   \   000001C6   0x4649             MOV      R1,R9
   \   000001C8   0x.... 0x....      BL       __aeabi_fmul
   \   000001CC   0x0001             MOVS     R1,R0
   \   000001CE   0x9800             LDR      R0,[SP, #+0]
   \   000001D0   0x.... 0x....      BL       __aeabi_fsub
   \   000001D4   0x9903             LDR      R1,[SP, #+12]
   \   000001D6   0x.... 0x....      BL       __aeabi_fdiv
   \   000001DA   0x9007             STR      R0,[SP, #+28]
    203              i = (n*x2 - x*x)/det;
   \   000001DC   0x9806             LDR      R0,[SP, #+24]
   \   000001DE   0x4659             MOV      R1,R11
   \   000001E0   0x.... 0x....      BL       __aeabi_fmul
   \   000001E4   0x9000             STR      R0,[SP, #+0]
   \   000001E6   0x9902             LDR      R1,[SP, #+8]
   \   000001E8   0x9802             LDR      R0,[SP, #+8]
   \   000001EA   0x.... 0x....      BL       __aeabi_fmul
   \   000001EE   0x0001             MOVS     R1,R0
   \   000001F0   0x9800             LDR      R0,[SP, #+0]
   \   000001F2   0x.... 0x....      BL       __aeabi_fsub
   \   000001F6   0x9903             LDR      R1,[SP, #+12]
   \   000001F8   0x.... 0x....      BL       __aeabi_fdiv
   \   000001FC   0x900A             STR      R0,[SP, #+40]
    204          
    205          // Get sums for x calibration
    206              z = zx = zy = 0;
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x0007             MOVS     R7,R0
   \   00000202   0x0006             MOVS     R6,R0
   \   00000204   0x4680             MOV      R8,R0
    207              for(j=0;j<5;j++) {
   \   00000206   0x2000             MOVS     R0,#+0
   \   00000208   0x0005             MOVS     R5,R0
   \                     ??perform_calibration_4: (+1)
   \   0000020A   0x2D05             CMP      R5,#+5
   \   0000020C   0xDA23             BGE.N    ??perform_calibration_5
    208                  z += (float)cal->xfb[j];
   \   0000020E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000212   0x6940             LDR      R0,[R0, #+20]
   \   00000214   0x.... 0x....      BL       __aeabi_i2f
   \   00000218   0x4641             MOV      R1,R8
   \   0000021A   0x.... 0x....      BL       __aeabi_fadd
   \   0000021E   0x4680             MOV      R8,R0
    209                  zx += (float)(cal->xfb[j]*cal->x[j]);
   \   00000220   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000224   0x6940             LDR      R0,[R0, #+20]
   \   00000226   0xF854 0x1025      LDR      R1,[R4, R5, LSL #+2]
   \   0000022A   0x4348             MULS     R0,R1,R0
   \   0000022C   0x.... 0x....      BL       __aeabi_i2f
   \   00000230   0x0031             MOVS     R1,R6
   \   00000232   0x.... 0x....      BL       __aeabi_fadd
   \   00000236   0x0006             MOVS     R6,R0
    210                  zy += (float)(cal->xfb[j]*cal->y[j]);
   \   00000238   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000023C   0x6940             LDR      R0,[R0, #+20]
   \   0000023E   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000242   0x6A89             LDR      R1,[R1, #+40]
   \   00000244   0x4348             MULS     R0,R1,R0
   \   00000246   0x.... 0x....      BL       __aeabi_i2f
   \   0000024A   0x0039             MOVS     R1,R7
   \   0000024C   0x.... 0x....      BL       __aeabi_fadd
   \   00000250   0x0007             MOVS     R7,R0
    211              }
   \   00000252   0x1C6D             ADDS     R5,R5,#+1
   \   00000254   0xE7D9             B.N      ??perform_calibration_4
    212          
    213          // Now multiply out to get the calibration for framebuffer x coord
    214              cal->a[0] = (int)((a*z + b*zx + c*zy)*(scaling));
   \                     ??perform_calibration_5: (+1)
   \   00000256   0x980C             LDR      R0,[SP, #+48]
   \   00000258   0x4641             MOV      R1,R8
   \   0000025A   0x.... 0x....      BL       __aeabi_fmul
   \   0000025E   0x9000             STR      R0,[SP, #+0]
   \   00000260   0x9809             LDR      R0,[SP, #+36]
   \   00000262   0x0031             MOVS     R1,R6
   \   00000264   0x.... 0x....      BL       __aeabi_fmul
   \   00000268   0x9900             LDR      R1,[SP, #+0]
   \   0000026A   0x.... 0x....      BL       __aeabi_fadd
   \   0000026E   0x9000             STR      R0,[SP, #+0]
   \   00000270   0x9808             LDR      R0,[SP, #+32]
   \   00000272   0x0039             MOVS     R1,R7
   \   00000274   0x.... 0x....      BL       __aeabi_fmul
   \   00000278   0x9900             LDR      R1,[SP, #+0]
   \   0000027A   0x.... 0x....      BL       __aeabi_fadd
   \   0000027E   0x9904             LDR      R1,[SP, #+16]
   \   00000280   0x.... 0x....      BL       __aeabi_fmul
   \   00000284   0x.... 0x....      BL       __aeabi_f2iz
   \   00000288   0x6520             STR      R0,[R4, #+80]
    215              cal->a[1] = (int)((b*z + e*zx + f*zy)*(scaling));
   \   0000028A   0x9809             LDR      R0,[SP, #+36]
   \   0000028C   0x4641             MOV      R1,R8
   \   0000028E   0x.... 0x....      BL       __aeabi_fmul
   \   00000292   0x9000             STR      R0,[SP, #+0]
   \   00000294   0x980B             LDR      R0,[SP, #+44]
   \   00000296   0x0031             MOVS     R1,R6
   \   00000298   0x.... 0x....      BL       __aeabi_fmul
   \   0000029C   0x9900             LDR      R1,[SP, #+0]
   \   0000029E   0x.... 0x....      BL       __aeabi_fadd
   \   000002A2   0x9000             STR      R0,[SP, #+0]
   \   000002A4   0x9807             LDR      R0,[SP, #+28]
   \   000002A6   0x0039             MOVS     R1,R7
   \   000002A8   0x.... 0x....      BL       __aeabi_fmul
   \   000002AC   0x9900             LDR      R1,[SP, #+0]
   \   000002AE   0x.... 0x....      BL       __aeabi_fadd
   \   000002B2   0x9904             LDR      R1,[SP, #+16]
   \   000002B4   0x.... 0x....      BL       __aeabi_fmul
   \   000002B8   0x.... 0x....      BL       __aeabi_f2iz
   \   000002BC   0x6560             STR      R0,[R4, #+84]
    216              cal->a[2] = (int)((c*z + f*zx + i*zy)*(scaling));
   \   000002BE   0x9808             LDR      R0,[SP, #+32]
   \   000002C0   0x4641             MOV      R1,R8
   \   000002C2   0x.... 0x....      BL       __aeabi_fmul
   \   000002C6   0x9000             STR      R0,[SP, #+0]
   \   000002C8   0x9807             LDR      R0,[SP, #+28]
   \   000002CA   0x0031             MOVS     R1,R6
   \   000002CC   0x.... 0x....      BL       __aeabi_fmul
   \   000002D0   0x9900             LDR      R1,[SP, #+0]
   \   000002D2   0x.... 0x....      BL       __aeabi_fadd
   \   000002D6   0x9000             STR      R0,[SP, #+0]
   \   000002D8   0x980A             LDR      R0,[SP, #+40]
   \   000002DA   0x0039             MOVS     R1,R7
   \   000002DC   0x.... 0x....      BL       __aeabi_fmul
   \   000002E0   0x9900             LDR      R1,[SP, #+0]
   \   000002E2   0x.... 0x....      BL       __aeabi_fadd
   \   000002E6   0x9904             LDR      R1,[SP, #+16]
   \   000002E8   0x.... 0x....      BL       __aeabi_fmul
   \   000002EC   0x.... 0x....      BL       __aeabi_f2iz
   \   000002F0   0x65A0             STR      R0,[R4, #+88]
    217          
    218          //    printf("%f %f %f\n",(a*z + b*zx + c*zy),
    219          //                (b*z + e*zx + f*zy),
    220          //                (c*z + f*zx + i*zy));
    221          
    222          // Get sums for y calibration
    223              z = zx = zy = 0;
   \   000002F2   0x2000             MOVS     R0,#+0
   \   000002F4   0x0007             MOVS     R7,R0
   \   000002F6   0x0006             MOVS     R6,R0
   \   000002F8   0x4680             MOV      R8,R0
    224              for(j=0;j<5;j++) {
   \   000002FA   0x2000             MOVS     R0,#+0
   \   000002FC   0x0005             MOVS     R5,R0
   \                     ??perform_calibration_6: (+1)
   \   000002FE   0x2D05             CMP      R5,#+5
   \   00000300   0xDA23             BGE.N    ??perform_calibration_7
    225                  z += (float)cal->yfb[j];
   \   00000302   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000306   0x6BC0             LDR      R0,[R0, #+60]
   \   00000308   0x.... 0x....      BL       __aeabi_i2f
   \   0000030C   0x4641             MOV      R1,R8
   \   0000030E   0x.... 0x....      BL       __aeabi_fadd
   \   00000312   0x4680             MOV      R8,R0
    226                  zx += (float)(cal->yfb[j]*cal->x[j]);
   \   00000314   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000318   0x6BC0             LDR      R0,[R0, #+60]
   \   0000031A   0xF854 0x1025      LDR      R1,[R4, R5, LSL #+2]
   \   0000031E   0x4348             MULS     R0,R1,R0
   \   00000320   0x.... 0x....      BL       __aeabi_i2f
   \   00000324   0x0031             MOVS     R1,R6
   \   00000326   0x.... 0x....      BL       __aeabi_fadd
   \   0000032A   0x0006             MOVS     R6,R0
    227                  zy += (float)(cal->yfb[j]*cal->y[j]);
   \   0000032C   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000330   0x6BC0             LDR      R0,[R0, #+60]
   \   00000332   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000336   0x6A89             LDR      R1,[R1, #+40]
   \   00000338   0x4348             MULS     R0,R1,R0
   \   0000033A   0x.... 0x....      BL       __aeabi_i2f
   \   0000033E   0x0039             MOVS     R1,R7
   \   00000340   0x.... 0x....      BL       __aeabi_fadd
   \   00000344   0x0007             MOVS     R7,R0
    228              }
   \   00000346   0x1C6D             ADDS     R5,R5,#+1
   \   00000348   0xE7D9             B.N      ??perform_calibration_6
    229          
    230          // Now multiply out to get the calibration for framebuffer y coord
    231              cal->a[3] = (int)((a*z + b*zx + c*zy)*(scaling));
   \                     ??perform_calibration_7: (+1)
   \   0000034A   0x980C             LDR      R0,[SP, #+48]
   \   0000034C   0x4641             MOV      R1,R8
   \   0000034E   0x.... 0x....      BL       __aeabi_fmul
   \   00000352   0x9000             STR      R0,[SP, #+0]
   \   00000354   0x9809             LDR      R0,[SP, #+36]
   \   00000356   0x0031             MOVS     R1,R6
   \   00000358   0x.... 0x....      BL       __aeabi_fmul
   \   0000035C   0x9900             LDR      R1,[SP, #+0]
   \   0000035E   0x.... 0x....      BL       __aeabi_fadd
   \   00000362   0x9000             STR      R0,[SP, #+0]
   \   00000364   0x9808             LDR      R0,[SP, #+32]
   \   00000366   0x0039             MOVS     R1,R7
   \   00000368   0x.... 0x....      BL       __aeabi_fmul
   \   0000036C   0x9900             LDR      R1,[SP, #+0]
   \   0000036E   0x.... 0x....      BL       __aeabi_fadd
   \   00000372   0x9904             LDR      R1,[SP, #+16]
   \   00000374   0x.... 0x....      BL       __aeabi_fmul
   \   00000378   0x.... 0x....      BL       __aeabi_f2iz
   \   0000037C   0x65E0             STR      R0,[R4, #+92]
    232              cal->a[4] = (int)((b*z + e*zx + f*zy)*(scaling));
   \   0000037E   0x9809             LDR      R0,[SP, #+36]
   \   00000380   0x4641             MOV      R1,R8
   \   00000382   0x.... 0x....      BL       __aeabi_fmul
   \   00000386   0x9000             STR      R0,[SP, #+0]
   \   00000388   0x980B             LDR      R0,[SP, #+44]
   \   0000038A   0x0031             MOVS     R1,R6
   \   0000038C   0x.... 0x....      BL       __aeabi_fmul
   \   00000390   0x9900             LDR      R1,[SP, #+0]
   \   00000392   0x.... 0x....      BL       __aeabi_fadd
   \   00000396   0x9000             STR      R0,[SP, #+0]
   \   00000398   0x9807             LDR      R0,[SP, #+28]
   \   0000039A   0x0039             MOVS     R1,R7
   \   0000039C   0x.... 0x....      BL       __aeabi_fmul
   \   000003A0   0x9900             LDR      R1,[SP, #+0]
   \   000003A2   0x.... 0x....      BL       __aeabi_fadd
   \   000003A6   0x9904             LDR      R1,[SP, #+16]
   \   000003A8   0x.... 0x....      BL       __aeabi_fmul
   \   000003AC   0x.... 0x....      BL       __aeabi_f2iz
   \   000003B0   0x6620             STR      R0,[R4, #+96]
    233              cal->a[5] = (int)((c*z + f*zx + i*zy)*(scaling));
   \   000003B2   0x9808             LDR      R0,[SP, #+32]
   \   000003B4   0x4641             MOV      R1,R8
   \   000003B6   0x.... 0x....      BL       __aeabi_fmul
   \   000003BA   0x9000             STR      R0,[SP, #+0]
   \   000003BC   0x9807             LDR      R0,[SP, #+28]
   \   000003BE   0x0031             MOVS     R1,R6
   \   000003C0   0x.... 0x....      BL       __aeabi_fmul
   \   000003C4   0x9900             LDR      R1,[SP, #+0]
   \   000003C6   0x.... 0x....      BL       __aeabi_fadd
   \   000003CA   0x9000             STR      R0,[SP, #+0]
   \   000003CC   0x980A             LDR      R0,[SP, #+40]
   \   000003CE   0x0039             MOVS     R1,R7
   \   000003D0   0x.... 0x....      BL       __aeabi_fmul
   \   000003D4   0x9900             LDR      R1,[SP, #+0]
   \   000003D6   0x.... 0x....      BL       __aeabi_fadd
   \   000003DA   0x9904             LDR      R1,[SP, #+16]
   \   000003DC   0x.... 0x....      BL       __aeabi_fmul
   \   000003E0   0x.... 0x....      BL       __aeabi_f2iz
   \   000003E4   0x6660             STR      R0,[R4, #+100]
    234          
    235          //    printf("%f %f %f\n",(a*z + b*zx + c*zy),
    236          //                (b*z + e*zx + f*zy),
    237          //                (c*z + f*zx + i*zy));
    238          
    239          // If we got here, we're OK, so assign scaling to a[6] and return
    240              cal->a[6] = (int)scaling;
   \   000003E6   0x9804             LDR      R0,[SP, #+16]
   \   000003E8   0x.... 0x....      BL       __aeabi_f2iz
   \   000003EC   0x66A0             STR      R0,[R4, #+104]
    241              return 1;
   \   000003EE   0x2001             MOVS     R0,#+1
   \                     ??perform_calibration_3: (+1)
   \   000003F0   0xB00D             ADD      SP,SP,#+52
   \   000003F2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    242          /*
    243          // This code was here originally to just insert default values
    244              for(j=0;j<7;j++) {
    245                  c->a[j]=0;
    246              }
    247              c->a[1] = c->a[5] = c->a[6] = 1;
    248              return 1;
    249          */
    250          
    251          #else
    252          //#define  TOUXCH_DIV    (65536.0)
    253          
    254              uint16 test_x=0, test_y=0;
    255              uint16 gap_x=0, gap_y=0;
    256          
    257          
    258              /* K＝(X0－X2) (Y1－Y2)－(X1－X2) (Y0－Y2) */
    259              cal->a[6] = ((cal->x[0] - cal->x[2]) * (cal->y[1] - cal->y[2])) -
    260                              ((cal->x[1] - cal->x[2]) * (cal->y[0] - cal->y[2])) ;
    261          
    262              if( cal->a[6]  == 0 )
    263              {
    264                  return 0;
    265              }
    266              else
    267              {
    268                  /* A＝((XD0－XD2) (Y1－Y2)－(XD1－XD2) (Y0－Y2))／K */
    269                  cal->a[0] = (((cal->xfb[0] - cal->xfb[2]) * (cal->y[1] - cal->y[2])) -
    270                             ((cal->xfb[1] - cal->xfb[2]) * (cal->y[0] - cal->y[2])));
    271          
    272                  /* B＝((X0－X2) (XD1－XD2)－(XD0－XD2) (X1－X2))／K */
    273                  cal->a[1] = (((cal->x[0] - cal->x[2]) * (cal->xfb[1] - cal->xfb[2])) -
    274                             ((cal->xfb[0] - cal->xfb[2]) * (cal->x[1] - cal->x[2])));
    275          
    276                  /* C＝(Y0(X2XD1－X1XD2)+Y1(X0XD2－X2XD0)+Y2(X1XD0－X0XD1))／K */
    277                  cal->a[2] = ((cal->x[2] * cal->xfb[1] - cal->x[1] * cal->xfb[2]) * cal->y[0] +
    278                             (cal->x[0] * cal->xfb[2] - cal->x[2] * cal->xfb[0]) * cal->y[1] +
    279                             (cal->x[1] * cal->xfb[0] - cal->x[0] * cal->xfb[1]) * cal->y[2]);
    280          
    281                  /* D＝((YD0－YD2) (Y1－Y2)－(YD1－YD2) (Y0－Y2))／K */
    282                  cal->a[3] = (((cal->yfb[0] - cal->yfb[2]) * (cal->y[1] - cal->y[2])) -
    283                             ((cal->yfb[1] - cal->yfb[2]) * (cal->y[0] - cal->y[2]))) ;
    284          
    285                  /* E＝((X0－X2) (YD1－YD2)－(YD0－YD2) (X1－X2))／K */
    286                  cal->a[4] = (((cal->x[0] - cal->x[2]) * (cal->yfb[1] - cal->yfb[2])) -
    287                             ((cal->yfb[0] - cal->yfb[2]) * (cal->x[1] - cal->x[2]))) ;
    288          
    289          
    290                  /* F＝(Y0(X2YD1－X1YD2)+Y1(X0YD2－X2YD0)+Y2(X1YD0－X0YD1))／K */
    291                  cal->a[5] = ((cal->x[2] * cal->yfb[1] - cal->x[1] * cal->yfb[2]) * cal->y[0] +
    292                             (cal->x[0] * cal->yfb[2] - cal->x[2] * cal->yfb[0]) * cal->y[1] +
    293                             (cal->x[1] * cal->yfb[0] - cal->x[0] * cal->yfb[1]) * cal->y[2]);
    294          
    295                  //校验第4个点
    296                      /*取一个点计算X值*/
    297                  test_x = (( (cal->a[0] * cal->x[3]) +
    298                             (cal->a[1] * cal->y[3]) +
    299                              cal->a[2]
    300                           )) / cal->a[6] ;
    301          
    302                      /*取一个点计算Y值*/
    303                  test_y = (( (cal->a[3] * cal->x[3]) +
    304                             (cal->a[4] * cal->y[3]) +
    305                             cal->a[5]
    306                           )) / cal->a[6] ;
    307          
    308                  /* 实际坐标与计算坐标的差 */
    309                  gap_x = abs(test_x - cal->xfb[3]);
    310                  if(gap_x > 10)return 0;
    311                  gap_y = abs(test_y - cal->yfb[3]);
    312                  if(gap_y > 10)return 0;
    313          
    314              }
    315              return 1 ;
    316          
    317          #endif
    318          
    319          }
    320          
    321          
    322          /*
    323          *********************************************************************************************************
    324          *   函 数 名: TSC2046_ReadAdc
    325          *   功能说明: 选择一个模拟通道，启动ADC，并返回ADC采样结果
    326          *   形    参：_ucCh = 0x90 表示Y通道； 0xd0 表示X通道
    327          *   返 回 值: 12位ADC值
    328          *********************************************************************************************************
    329          */

   \                                 In section .text, align 2, keep-with-next
    330          uint16 xpt2046_read_ch(uint8_t _ucCh)
    331          {
   \                     xpt2046_read_ch: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    332              uint16 tmp;
    333              uint8 buff[2]={0,0};
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    334              spi_mosi_cmd(TOUCH_SPI,TOUCH_CS, &_ucCh ,NULL ,buff, buff, 1 , 2); //SPI发送接收函数
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x9003             STR      R0,[SP, #+12]
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x9002             STR      R0,[SP, #+8]
   \   00000012   0xA804             ADD      R0,SP,#+16
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0xA804             ADD      R0,SP,#+16
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0xAA05             ADD      R2,SP,#+20
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       spi_mosi_cmd
    335                                                                                          //发送命令 _ucCh ，读2个数据
    336          
    337          #if 1
    338              //if(_ucCh == 0x90)
    339              {
    340                  //tmp =  (buff[0]<<5);
    341                  //tmp |= (buff[1]>>3);
    342                  //tmp >>= 4;
    343                  tmp = buff[0] <<8;
   \   00000026   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000002A   0x0200             LSLS     R0,R0,#+8
   \   0000002C   0x0004             MOVS     R4,R0
    344                  tmp |= buff[1];
   \   0000002E   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \   00000032   0x4304             ORRS     R4,R0,R4
    345                  tmp >>= 3;
   \   00000034   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   0x08E4             LSRS     R4,R4,#+3
    346          
    347                  return tmp ;
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0xB006             ADD      SP,SP,#+24
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    348              }
    349          //    else
    350          //    {
    351          //        return (buff[0]<<4) | (buff[1]>>4);
    352          //    }
    353          #else
    354          
    355          #endif
    356          
    357          
    358          }
    359          
    360          
    361          /*
    362           * 读取TP x y 的AD值(12bit，最大是4096)
    363           */

   \                                 In section .text, align 2, keep-with-next
    364          void xpt2046_get_xy(Site_t * site)
    365          {
   \                     xpt2046_get_xy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    366              DELAY_US(touch_delay);
   \   00000004   0x....             LDR.N    R0,??DataTable6_4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable6_10
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4348             MULS     R0,R1,R0
   \   0000000E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000012   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000016   0x.... 0x....      BL       systick_delay
    367          
    368              site->x= xpt2046_read_ch(TOUCH_XCh_12bit);
   \   0000001A   0x20D0             MOVS     R0,#+208
   \   0000001C   0x.... 0x....      BL       xpt2046_read_ch
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    369          
    370              DELAY_US(touch_delay);
   \   00000022   0x....             LDR.N    R0,??DataTable6_4
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable6_10
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x4348             MULS     R0,R1,R0
   \   0000002C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000030   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000034   0x.... 0x....      BL       systick_delay
    371          
    372              site->y = xpt2046_read_ch(TOUCH_YCh_12bit);
   \   00000038   0x2090             MOVS     R0,#+144
   \   0000003A   0x.... 0x....      BL       xpt2046_read_ch
   \   0000003E   0x8060             STRH     R0,[R4, #+2]
    373          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    374          
    375          
    376          /******************************************************
    377          * 函数名：Read_2046
    378          * 描述  ：得到简单滤波之后的X Y
    379          * 输入  ：Coordinate结构体地址
    380          * 输出  ：1成功，0失败
    381          * 举例  ：无
    382          * 注意  ：”画板应用实例"专用,不是很精准，但是速度比较快
    383          *********************************************************/
    384          

   \                                 In section .text, align 2, keep-with-next
    385          uint8 xpt2046_read(Site_t * site )
    386          {
   \                     xpt2046_read: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
    387          #define READ_COUNT      3
    388          #define XPT2046_ERROR   40
    389              //static Site_t screen;
    390              uint8 count=0,i;
   \   00000008   0x2600             MOVS     R6,#+0
    391              Site_t  sitexy;
    392          
    393              uint32 sumx,sumy;
    394          
    395              int buffer[2][READ_COUNT]={{0},{0}};  /*坐标X和Y进行多次采样*/
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x2118             MOVS     R1,#+24
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    396          
    397              /* 循环采样 READ_COUNT 次 */
    398              do{
    399                  xpt2046_get_xy(&sitexy);
   \                     ??xpt2046_read_0: (+1)
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       xpt2046_get_xy
    400                  if((sitexy.x == 0) || (sitexy.y == 0xFFF))return 0;//松手
   \   00000018   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??xpt2046_read_1
   \   00000020   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000024   0xF640 0x71FF      MOVW     R1,#+4095
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD101             BNE.N    ??xpt2046_read_2
   \                     ??xpt2046_read_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE055             B.N      ??xpt2046_read_3
    401                  buffer[0][count]=sitexy.x;
   \                     ??xpt2046_read_2: (+1)
   \   00000030   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000034   0xA901             ADD      R1,SP,#+4
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
    402                  buffer[1][count]=sitexy.y;
   \   0000003C   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0xEB11 0x0186      ADDS     R1,R1,R6, LSL #+2
   \   00000048   0x60C8             STR      R0,[R1, #+12]
    403                  count++;
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
    404              }while(count<READ_COUNT); //用户点击触摸屏时即TP_INT_IN信号为低 并且 count<10
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E03             CMP      R6,#+3
   \   00000050   0xDBDF             BLT.N    ??xpt2046_read_0
    405          
    406              if(count == READ_COUNT)
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E03             CMP      R6,#+3
   \   00000056   0xD140             BNE.N    ??xpt2046_read_4
    407              {
    408                  //去掉最小值 和 最大值 ,并求平均值
    409                  sumx = buffer[0][0];
   \   00000058   0x9801             LDR      R0,[SP, #+4]
   \   0000005A   0x0007             MOVS     R7,R0
    410                  sumy = buffer[1][0];
   \   0000005C   0x9804             LDR      R0,[SP, #+16]
   \   0000005E   0x4680             MOV      R8,R0
    411                  for(i=1;i<READ_COUNT;i++)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x0005             MOVS     R5,R0
   \                     ??xpt2046_read_5: (+1)
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D03             CMP      R5,#+3
   \   00000068   0xDA0D             BGE.N    ??xpt2046_read_6
    412                  {
    413                      sumx += buffer[0][i];
   \   0000006A   0xA801             ADD      R0,SP,#+4
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000072   0x19C7             ADDS     R7,R0,R7
    414                      sumy += buffer[1][i];
   \   00000074   0xA801             ADD      R0,SP,#+4
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0xEB10 0x0085      ADDS     R0,R0,R5, LSL #+2
   \   0000007C   0x68C0             LDR      R0,[R0, #+12]
   \   0000007E   0xEB10 0x0808      ADDS     R8,R0,R8
    415                  }
   \   00000082   0x1C6D             ADDS     R5,R5,#+1
   \   00000084   0xE7EE             B.N      ??xpt2046_read_5
    416                  site->x = sumx /READ_COUNT;
   \                     ??xpt2046_read_6: (+1)
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   0000008C   0x8020             STRH     R0,[R4, #+0]
    417                  site->y = sumy /READ_COUNT;
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0xFBB8 0xF0F0      UDIV     R0,R8,R0
   \   00000094   0x8060             STRH     R0,[R4, #+2]
    418          
    419          
    420                  //校验。判断有没有其他点超过 误差值
    421                  for(i=1;i<READ_COUNT;i++)
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x0005             MOVS     R5,R0
   \                     ??xpt2046_read_7: (+1)
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x2D03             CMP      R5,#+3
   \   0000009E   0xDA1A             BGE.N    ??xpt2046_read_8
    422                  {
    423                      if(abs(buffer[0][i] -site->x ) > XPT2046_ERROR)
   \   000000A0   0xA801             ADD      R0,SP,#+4
   \   000000A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A4   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000000A8   0x8821             LDRH     R1,[R4, #+0]
   \   000000AA   0x1A40             SUBS     R0,R0,R1
   \   000000AC   0x.... 0x....      BL       abs
   \   000000B0   0x2829             CMP      R0,#+41
   \   000000B2   0xDB01             BLT.N    ??xpt2046_read_9
    424                      {
    425                          return 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xE011             B.N      ??xpt2046_read_3
    426                      }
    427                      if(abs(buffer[1][i] -site->y ) > XPT2046_ERROR)
   \                     ??xpt2046_read_9: (+1)
   \   000000B8   0xA801             ADD      R0,SP,#+4
   \   000000BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BC   0xEB10 0x0085      ADDS     R0,R0,R5, LSL #+2
   \   000000C0   0x68C0             LDR      R0,[R0, #+12]
   \   000000C2   0x8861             LDRH     R1,[R4, #+2]
   \   000000C4   0x1A40             SUBS     R0,R0,R1
   \   000000C6   0x.... 0x....      BL       abs
   \   000000CA   0x2829             CMP      R0,#+41
   \   000000CC   0xDB01             BLT.N    ??xpt2046_read_10
    428                      {
    429                          return 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xE004             B.N      ??xpt2046_read_3
    430                      }
    431          
    432                  }
   \                     ??xpt2046_read_10: (+1)
   \   000000D2   0x1C6D             ADDS     R5,R5,#+1
   \   000000D4   0xE7E1             B.N      ??xpt2046_read_7
    433          
    434                  return 1;
   \                     ??xpt2046_read_8: (+1)
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xE000             B.N      ??xpt2046_read_3
    435          
    436                  //
    437              }
    438              return 0;
   \                     ??xpt2046_read_4: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??xpt2046_read_3: (+1)
   \   000000DC   0xB008             ADD      SP,SP,#+32
   \   000000DE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    439          
    440          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x000249F0         DC32     0x249f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     touch_baud

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x000A0103         DC32     0xa0103

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     touch_delay

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     cal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     cal+0x50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x3DCCCCCD         DC32     0x3dcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0xBDCCCCCC         DC32     0xbdcccccc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
    441          
    442          
    443          
    444          
    445          
    446          
    447          
    448          
    449          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      88   perform_calibration
        88   -> __aeabi_d2f
        88   -> __aeabi_dadd
        88   -> __aeabi_f2d
        88   -> __aeabi_f2iz
        88   -> __aeabi_fadd
        88   -> __aeabi_fdiv
        88   -> __aeabi_fmul
        88   -> __aeabi_fsub
        88   -> __aeabi_i2f
        88 __aeabi_cfcmple
        88 __aeabi_cfrcmple
      24   touch_calibrate
        24   -> ILI9341_get_h
        24   -> ILI9341_get_w
        24   -> LCD_clear
        24   -> LCD_cross
        24   -> perform_calibration
        24   -> systick_delay_ms
        24   -> xpt2046_read
      16   touch_get_point
        16   -> ILI9341_get_h
        16   -> ILI9341_get_w
        16   -> xpt2046_read
       8   touch_init
         8   -> port_init
         8   -> spi_init
       8   touch_load
         8   -- Indirect call
       8   touch_save
         8   -- Indirect call
       8   xpt2046_get_xy
         8   -> systick_delay
         8   -> xpt2046_read_ch
      56   xpt2046_read
        56   -> __aeabi_memclr4
        56   -> abs
        56   -> xpt2046_get_xy
      32   xpt2046_read_ch
        32   -> spi_mosi_cmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       2  ?_0
      24  ?_1
     108  cal
    1014  perform_calibration
       4  touch_baud
     264  touch_calibrate
       4  touch_delay
     188  touch_get_point
      54  touch_init
      14  touch_load
      14  touch_save
      66  xpt2046_get_xy
     226  xpt2046_read
      64  xpt2046_read_ch

 
   116 bytes in section .bss
    26 bytes in section .rodata
 1 948 bytes in section .text
 
 1 948 bytes of CODE  memory
    26 bytes of CONST memory
   116 bytes of DATA  memory

Errors: none
Warnings: none
