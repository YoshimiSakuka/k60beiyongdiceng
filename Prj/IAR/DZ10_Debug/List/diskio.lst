###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:22
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Lib\FatFs\diskio.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Lib\FatFs\diskio.c -D DEBUG
#        -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\diskio.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\diskio.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Lib\FatFs\diskio.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           *     本驱动由brtos代码提取并修改而成:http://code.google.com/p/brtos/downloads/detail?name=BRTOS%201.66%20Kinetis%20-%20SD%20card%20-%20BMP%2024%20bit.rar&can=2&q=
     11           *
     12           * @file       diskio.c
     13           * @brief      FATFS 底层接口实现函数
     14           * @author     山外科技 & gustavo(brtos作者)
     15           * @version    v5.0
     16           * @date       2013-09-19
     17           */
     18          
     19          #include "common.h"
     20          #include "MK60_sdhc.h"
     21          #include "diskio.h"
     22          
     23          

   \                                 In section .data, align 1
     24          static volatile DSTATUS   Stat             = STA_NOINIT;    /* 硬盘状态         */
   \                     Stat:
   \   00000000   0x01               DC8 1
     25          
     26          /*!
     27           *  @brief      硬盘初始化
     28           *  @param      drv                 设备号(目前代码仅支持为 0)
     29           *  @since      v5.0
     30           */

   \                                 In section .text, align 2, keep-with-next
     31          DSTATUS disk_initialize (unsigned char drv)
     32          {
   \                     disk_initialize: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
     33              uint32                      param, c_size, c_size_mult, read_bl_len;
     34              ESDHC_CMD_t                 command;
     35          
     36              if (drv) return STA_NOINIT;         /* 目前代码仅支持1个设备 */
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD001             BEQ.N    ??disk_initialize_0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE135             B.N      ??disk_initialize_1
     37              if (Stat & STA_NODISK) return Stat; /* 没有插入卡 */
   \                     ??disk_initialize_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x0780             LSLS     R0,R0,#+30
   \   00000018   0xD503             BPL.N    ??disk_initialize_2
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0xE12C             B.N      ??disk_initialize_1
     38              if ((Stat & STA_NOINIT) == 0)   return 0;/* 没有初始化 */
   \                     ??disk_initialize_2: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD401             BMI.N    ??disk_initialize_3
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE125             B.N      ??disk_initialize_1
     39          
     40              SDHC_card.SD_TIMEOUT = 0;
   \                     ??disk_initialize_3: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000036   0x6048             STR      R0,[R1, #+4]
     41              SDHC_card.NUM_BLOCKS = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000003E   0x6088             STR      R0,[R1, #+8]
     42              SDHC_card.ADDRESS = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000046   0x60C8             STR      R0,[R1, #+12]
     43              SDHC_card.SDHC = FALSE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000004E   0x7408             STRB     R0,[R1, #+16]
     44              SDHC_card.VERSION2 = FALSE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000056   0x7448             STRB     R0,[R1, #+17]
     45          
     46              /* 初始化和检测卡 */
     47              if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_INIT, NULL))
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       SDHC_ioctl
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD001             BEQ.N    ??disk_initialize_4
     48              {
     49                  return FALSE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE109             B.N      ??disk_initialize_1
     50              }
     51          
     52              /* SDHC 检测 */
     53              param = 0;
   \                     ??disk_initialize_4: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
     54              if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_GET_CARD, &param))
   \   0000006C   0xA900             ADD      R1,SP,#+0
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x.... 0x....      BL       SDHC_ioctl
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD001             BEQ.N    ??disk_initialize_5
     55              {
     56                  return FALSE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE0FF             B.N      ??disk_initialize_1
     57              }
     58              if ((ESDHC_CARD_SD == param) || (ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDCOMBO == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_5: (+1)
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD008             BEQ.N    ??disk_initialize_6
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x2803             CMP      R0,#+3
   \   00000086   0xD005             BEQ.N    ??disk_initialize_6
   \   00000088   0x9800             LDR      R0,[SP, #+0]
   \   0000008A   0x2805             CMP      R0,#+5
   \   0000008C   0xD002             BEQ.N    ??disk_initialize_6
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0x2806             CMP      R0,#+6
   \   00000092   0xD11D             BNE.N    ??disk_initialize_7
     59              {
     60                  if ((ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_6: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x2803             CMP      R0,#+3
   \   00000098   0xD002             BEQ.N    ??disk_initialize_8
   \   0000009A   0x9800             LDR      R0,[SP, #+0]
   \   0000009C   0x2806             CMP      R0,#+6
   \   0000009E   0xD103             BNE.N    ??disk_initialize_9
     61                  {
     62                      SDHC_card.SDHC = TRUE;
   \                     ??disk_initialize_8: (+1)
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   000000A6   0x7408             STRB     R0,[R1, #+16]
     63                  }
     64              }
     65              else
     66              {
     67                  return FALSE;
     68              }
     69          
     70              /* 卡识别 */
     71              command.COMMAND = ESDHC_CMD2;
   \                     ??disk_initialize_9: (+1)
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0xF88D 0x0004      STRB     R0,[SP, #+4]
     72              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF88D 0x0005      STRB     R0,[SP, #+5]
     73              command.ARGUMENT = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x9002             STR      R0,[SP, #+8]
     74              command.READ = FALSE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF88D 0x0006      STRB     R0,[SP, #+6]
     75              command.BLOCKS = 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x9003             STR      R0,[SP, #+12]
     76              if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   000000C2   0xA901             ADD      R1,SP,#+4
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x.... 0x....      BL       SDHC_ioctl
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD102             BNE.N    ??disk_initialize_10
   \   000000CE   0xE003             B.N      ??disk_initialize_11
   \                     ??disk_initialize_7: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE0D3             B.N      ??disk_initialize_1
     77              {
     78                  return FALSE;
   \                     ??disk_initialize_10: (+1)
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xE0D1             B.N      ??disk_initialize_1
     79              }
     80          
     81              /* 获得卡地址 */
     82              command.COMMAND = ESDHC_CMD3;
   \                     ??disk_initialize_11: (+1)
   \   000000D8   0x2003             MOVS     R0,#+3
   \   000000DA   0xF88D 0x0004      STRB     R0,[SP, #+4]
     83              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF88D 0x0005      STRB     R0,[SP, #+5]
     84              command.ARGUMENT = 0;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x9002             STR      R0,[SP, #+8]
     85              command.READ = FALSE;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF88D 0x0006      STRB     R0,[SP, #+6]
     86              command.BLOCKS = 0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x9003             STR      R0,[SP, #+12]
     87              if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   000000F2   0xA901             ADD      R1,SP,#+4
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0x.... 0x....      BL       SDHC_ioctl
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD001             BEQ.N    ??disk_initialize_12
     88              {
     89                  return FALSE;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xE0BC             B.N      ??disk_initialize_1
     90              }
     91              SDHC_card.ADDRESS = command.RESPONSE[0] & 0xFFFF0000;
   \                     ??disk_initialize_12: (+1)
   \   00000102   0x9804             LDR      R0,[SP, #+16]
   \   00000104   0x0C00             LSRS     R0,R0,#+16
   \   00000106   0x0400             LSLS     R0,R0,#+16
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000010C   0x60C8             STR      R0,[R1, #+12]
     92          
     93              /* 获得卡参数 */
     94              command.COMMAND = ESDHC_CMD9;
   \   0000010E   0x2009             MOVS     R0,#+9
   \   00000110   0xF88D 0x0004      STRB     R0,[SP, #+4]
     95              command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xF88D 0x0005      STRB     R0,[SP, #+5]
     96              command.ARGUMENT = SDHC_card.ADDRESS;
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000011E   0x68C0             LDR      R0,[R0, #+12]
   \   00000120   0x9002             STR      R0,[SP, #+8]
     97              command.READ = FALSE;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF88D 0x0006      STRB     R0,[SP, #+6]
     98              command.BLOCKS = 0;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x9003             STR      R0,[SP, #+12]
     99              if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   0000012C   0xA901             ADD      R1,SP,#+4
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x.... 0x....      BL       SDHC_ioctl
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD001             BEQ.N    ??disk_initialize_13
    100              {
    101                  return FALSE;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE09F             B.N      ??disk_initialize_1
    102              }
    103              if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??disk_initialize_13: (+1)
   \   0000013C   0x9807             LDR      R0,[SP, #+28]
   \   0000013E   0xF410 0x0F40      TST      R0,#0xC00000
   \   00000142   0xD11E             BNE.N    ??disk_initialize_14
    104              {
    105                  read_bl_len = (command.RESPONSE[2] >> 8) & 0x0F;
   \   00000144   0x9806             LDR      R0,[SP, #+24]
   \   00000146   0xF3C0 0x2003      UBFX     R0,R0,#+8,#+4
   \   0000014A   0x0006             MOVS     R6,R0
    106                  c_size = command.RESPONSE[2] & 0x03;
   \   0000014C   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000150   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000154   0x0007             MOVS     R7,R0
    107                  c_size = (c_size << 10) | (command.RESPONSE[1] >> 22);
   \   00000156   0x9805             LDR      R0,[SP, #+20]
   \   00000158   0x0D80             LSRS     R0,R0,#+22
   \   0000015A   0xEA50 0x2787      ORRS     R7,R0,R7, LSL #+10
    108                  c_size_mult = (command.RESPONSE[1] >> 7) & 0x07;
   \   0000015E   0x9805             LDR      R0,[SP, #+20]
   \   00000160   0xF3C0 0x10C2      UBFX     R0,R0,#+7,#+3
   \   00000164   0x0005             MOVS     R5,R0
    109                  SDHC_card.NUM_BLOCKS = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
   \   00000166   0x1C78             ADDS     R0,R7,#+1
   \   00000168   0x2101             MOVS     R1,#+1
   \   0000016A   0x1CAA             ADDS     R2,R5,#+2
   \   0000016C   0x4091             LSLS     R1,R1,R2
   \   0000016E   0x4348             MULS     R0,R1,R0
   \   00000170   0x2101             MOVS     R1,#+1
   \   00000172   0x0032             MOVS     R2,R6
   \   00000174   0x3A09             SUBS     R2,R2,#+9
   \   00000176   0x4091             LSLS     R1,R1,R2
   \   00000178   0x4348             MULS     R0,R1,R0
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000017E   0x6088             STR      R0,[R1, #+8]
   \   00000180   0xE00C             B.N      ??disk_initialize_15
    110              }
    111              else
    112              {
    113                  SDHC_card.VERSION2 = TRUE;
   \                     ??disk_initialize_14: (+1)
   \   00000182   0x2001             MOVS     R0,#+1
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000188   0x7448             STRB     R0,[R1, #+17]
    114                  c_size = (command.RESPONSE[1] >> 8) & 0x003FFFFF;
   \   0000018A   0x9805             LDR      R0,[SP, #+20]
   \   0000018C   0xF3C0 0x2015      UBFX     R0,R0,#+8,#+22
   \   00000190   0x0007             MOVS     R7,R0
    115                  SDHC_card.NUM_BLOCKS = (c_size + 1) << 10;
   \   00000192   0x1C78             ADDS     R0,R7,#+1
   \   00000194   0x0280             LSLS     R0,R0,#+10
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000019A   0x6088             STR      R0,[R1, #+8]
    116              }
    117          
    118              /* 选择卡 */
    119              command.COMMAND = ESDHC_CMD7;
   \                     ??disk_initialize_15: (+1)
   \   0000019C   0x2007             MOVS     R0,#+7
   \   0000019E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    120              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001A2   0x2000             MOVS     R0,#+0
   \   000001A4   0xF88D 0x0005      STRB     R0,[SP, #+5]
    121              command.ARGUMENT = SDHC_card.ADDRESS;
   \   000001A8   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   000001AC   0x68C0             LDR      R0,[R0, #+12]
   \   000001AE   0x9002             STR      R0,[SP, #+8]
    122              command.READ = FALSE;
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0xF88D 0x0006      STRB     R0,[SP, #+6]
    123              command.BLOCKS = 0;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x9003             STR      R0,[SP, #+12]
    124              if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   000001BA   0xA901             ADD      R1,SP,#+4
   \   000001BC   0x2001             MOVS     R0,#+1
   \   000001BE   0x.... 0x....      BL       SDHC_ioctl
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD001             BEQ.N    ??disk_initialize_16
    125              {
    126                  return FALSE;
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0xE058             B.N      ??disk_initialize_1
    127              }
    128          
    129              /* 设置块的大小 */
    130              command.COMMAND = ESDHC_CMD16;
   \                     ??disk_initialize_16: (+1)
   \   000001CA   0x2010             MOVS     R0,#+16
   \   000001CC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    131              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0xF88D 0x0005      STRB     R0,[SP, #+5]
    132              command.ARGUMENT = SDCARD_BLOCK_SIZE;
   \   000001D6   0xF44F 0x7000      MOV      R0,#+512
   \   000001DA   0x9002             STR      R0,[SP, #+8]
    133              command.READ = FALSE;
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0xF88D 0x0006      STRB     R0,[SP, #+6]
    134              command.BLOCKS = 0;
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0x9003             STR      R0,[SP, #+12]
    135              if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   000001E6   0xA901             ADD      R1,SP,#+4
   \   000001E8   0x2001             MOVS     R0,#+1
   \   000001EA   0x.... 0x....      BL       SDHC_ioctl
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD001             BEQ.N    ??disk_initialize_17
    136              {
    137                  return FALSE;
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0xE042             B.N      ??disk_initialize_1
    138              }
    139          
    140              if (ESDHC_BUS_WIDTH_4BIT == SDHC_BUS_WIDTH)
    141              {
    142                  /* 应用程序特定的命令 */
    143                  command.COMMAND = ESDHC_CMD55;
   \                     ??disk_initialize_17: (+1)
   \   000001F6   0x2037             MOVS     R0,#+55
   \   000001F8   0xF88D 0x0004      STRB     R0,[SP, #+4]
    144                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001FC   0x2000             MOVS     R0,#+0
   \   000001FE   0xF88D 0x0005      STRB     R0,[SP, #+5]
    145                  command.ARGUMENT = SDHC_card.ADDRESS;
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   00000206   0x68C0             LDR      R0,[R0, #+12]
   \   00000208   0x9002             STR      R0,[SP, #+8]
    146                  command.READ = FALSE;
   \   0000020A   0x2000             MOVS     R0,#+0
   \   0000020C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    147                  command.BLOCKS = 0;
   \   00000210   0x2000             MOVS     R0,#+0
   \   00000212   0x9003             STR      R0,[SP, #+12]
    148                  if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   00000214   0xA901             ADD      R1,SP,#+4
   \   00000216   0x2001             MOVS     R0,#+1
   \   00000218   0x.... 0x....      BL       SDHC_ioctl
   \   0000021C   0x2800             CMP      R0,#+0
   \   0000021E   0xD001             BEQ.N    ??disk_initialize_18
    149                  {
    150                      return FALSE;
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0xE02B             B.N      ??disk_initialize_1
    151                  }
    152          
    153                  /* 设置总线带宽 == 4 */
    154                  command.COMMAND = ESDHC_ACMD6;
   \                     ??disk_initialize_18: (+1)
   \   00000224   0x2006             MOVS     R0,#+6
   \   00000226   0xF88D 0x0004      STRB     R0,[SP, #+4]
    155                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000022A   0x2000             MOVS     R0,#+0
   \   0000022C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    156                  command.ARGUMENT = 2;
   \   00000230   0x2002             MOVS     R0,#+2
   \   00000232   0x9002             STR      R0,[SP, #+8]
    157                  command.READ = FALSE;
   \   00000234   0x2000             MOVS     R0,#+0
   \   00000236   0xF88D 0x0006      STRB     R0,[SP, #+6]
    158                  command.BLOCKS = 0;
   \   0000023A   0x2000             MOVS     R0,#+0
   \   0000023C   0x9003             STR      R0,[SP, #+12]
    159                  if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   0000023E   0xA901             ADD      R1,SP,#+4
   \   00000240   0x2001             MOVS     R0,#+1
   \   00000242   0x.... 0x....      BL       SDHC_ioctl
   \   00000246   0x2800             CMP      R0,#+0
   \   00000248   0xD001             BEQ.N    ??disk_initialize_19
    160                  {
    161                      return FALSE;
   \   0000024A   0x2000             MOVS     R0,#+0
   \   0000024C   0xE016             B.N      ??disk_initialize_1
    162                  }
    163          
    164                  param = ESDHC_BUS_WIDTH_4BIT;
   \                     ??disk_initialize_19: (+1)
   \   0000024E   0x2001             MOVS     R0,#+1
   \   00000250   0x9000             STR      R0,[SP, #+0]
    165                  if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SET_BUS_WIDTH, &param))
   \   00000252   0xA900             ADD      R1,SP,#+0
   \   00000254   0x2004             MOVS     R0,#+4
   \   00000256   0x.... 0x....      BL       SDHC_ioctl
   \   0000025A   0x2800             CMP      R0,#+0
   \   0000025C   0xD001             BEQ.N    ??disk_initialize_20
    166                  {
    167                      return FALSE;
   \   0000025E   0x2000             MOVS     R0,#+0
   \   00000260   0xE00C             B.N      ??disk_initialize_1
    168                  }
    169              }
    170          
    171              Stat &= ~STA_NOINIT;        /* 清 STA_NOINIT */
   \                     ??disk_initialize_20: (+1)
   \   00000262   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000266   0x7800             LDRB     R0,[R0, #+0]
   \   00000268   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000026C   0x.... 0x....      LDR.W    R1,??DataTable6
   \   00000270   0x7008             STRB     R0,[R1, #+0]
    172          
    173              return (Stat & 0x03);
   \   00000272   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000276   0x7800             LDRB     R0,[R0, #+0]
   \   00000278   0xF010 0x0003      ANDS     R0,R0,#0x3
   \                     ??disk_initialize_1: (+1)
   \   0000027C   0xB009             ADD      SP,SP,#+36
   \   0000027E   0xBDF0             POP      {R4-R7,PC}       ;; return
    174          }
    175          
    176          /*!
    177           *  @brief      从MMC接收数据包
    178           *  @param      buff                接收 SDCARD_BLOCK_SIZE 个字节的数据块到数据缓冲区地址
    179           *  @param      btr                 字节数目(必须是 4 的倍数)
    180           *  @since      v5.0
    181           */

   \                                 In section .text, align 2, keep-with-next
    182          static int rcvr_datablock (uint8   *buff, uint32  btr)
    183          {
   \                     rcvr_datablock: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
    184              uint32  bytes, i, j;
    185              uint32  *ptr = (uint32 *)buff;
   \   00000004   0x0015             MOVS     R5,R2
    186          
    187          
    188              /* Workaround for random bit polling failures - not suitable for IO cards    */
    189          
    190              while(!(SDHC_IRQSTAT & SDHC_IRQSTAT_BRR_MASK));
   \                     ??rcvr_datablock_0: (+1)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x400b1030
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0680             LSLS     R0,R0,#+26
   \   0000000E   0xD5FA             BPL.N    ??rcvr_datablock_0
    191              SDHC_IRQSTAT =  SDHC_IRQSTAT_BRR_MASK ;
   \   00000010   0x2020             MOVS     R0,#+32
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable6_2  ;; 0x400b1030
   \   00000016   0x6038             STR      R0,[R7, #+0]
    192          
    193              /* Read data in 4 byte counts */
    194              bytes = btr;
   \   00000018   0x000B             MOVS     R3,R1
    195              while (bytes)
   \                     ??rcvr_datablock_1: (+1)
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD02B             BEQ.N    ??rcvr_datablock_2
    196              {
    197                  i = bytes > SDCARD_BLOCK_SIZE ? SDCARD_BLOCK_SIZE : bytes;
   \   0000001E   0xF5B3 0x7F00      CMP      R3,#+512
   \   00000022   0xD902             BLS.N    ??rcvr_datablock_3
   \   00000024   0xF44F 0x7600      MOV      R6,#+512
   \   00000028   0xE000             B.N      ??rcvr_datablock_4
   \                     ??rcvr_datablock_3: (+1)
   \   0000002A   0x001E             MOVS     R6,R3
    198                  for (j = (i + 3) >> 2; j != 0; j--)
   \                     ??rcvr_datablock_4: (+1)
   \   0000002C   0x1CF0             ADDS     R0,R6,#+3
   \   0000002E   0x0880             LSRS     R0,R0,#+2
   \   00000030   0x0004             MOVS     R4,R0
   \                     ??rcvr_datablock_5: (+1)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD01D             BEQ.N    ??rcvr_datablock_6
    199                  {
    200                      if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x400b1030
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF410 0x0FE0      TST      R0,#0x700000
   \   00000040   0xD00B             BEQ.N    ??rcvr_datablock_7
    201                      {
    202                          SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x400b1030
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000004C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000050   0x.... 0x....      LDR.W    R7,??DataTable6_2  ;; 0x400b1030
   \   00000054   0x6038             STR      R0,[R7, #+0]
    203                          return 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE00E             B.N      ??rcvr_datablock_8
    204                      }
    205          
    206                      while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) {};
   \                     ??rcvr_datablock_7: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable6_3  ;; 0x400b1024
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x0500             LSLS     R0,R0,#+20
   \   00000062   0xD5FA             BPL.N    ??rcvr_datablock_7
    207          
    208                      //小端
    209                      *ptr++ = SDHC_DATPORT;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable6_4  ;; 0x400b1020
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x6028             STR      R0,[R5, #+0]
   \   0000006C   0x1D2D             ADDS     R5,R5,#+4
    210                  }
   \   0000006E   0x1E64             SUBS     R4,R4,#+1
   \   00000070   0xE7DF             B.N      ??rcvr_datablock_5
    211                  bytes -= i;
   \                     ??rcvr_datablock_6: (+1)
   \   00000072   0x1B9B             SUBS     R3,R3,R6
   \   00000074   0xE7D1             B.N      ??rcvr_datablock_1
    212              }
    213          
    214              return 1;                       /* Return with success */
   \                     ??rcvr_datablock_2: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   \                     ??rcvr_datablock_8: (+1)
   \   00000078   0xBCF0             POP      {R4-R7}
   \   0000007A   0x4770             BX       LR               ;; return
    215          }
    216          
    217          /*!
    218           *  @brief      读扇区
    219           *  @param      drv                 驱动号(目前代码仅支持为 0)
    220           *  @param      buff                缓冲区地址
    221           *  @param      sector              扇区号
    222           *  @param      count               扇区数(1~255)
    223           *  @return     DRESULT             执行结果
    224           *  @since      v5.0
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          DRESULT disk_read (         //读磁盘扇区
    227              uint8  drv,             /* 物理驱动编号 (0) */
    228              uint8  *buff,           /* 指向数据缓冲区来存储读到的数据 */
    229              uint32 sector,          /* 开始的扇区号 (LBA) */
    230              uint8  count            /* 扇区总数(1..255) */
    231          )
    232          {
   \                     disk_read: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001E             MOVS     R6,R3
    233              ESDHC_CMD_t command;
    234          
    235              if (drv || (!count)) return RES_PARERR;       //drv 只能为 0， count 必须不等于0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD102             BNE.N    ??disk_read_0
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD101             BNE.N    ??disk_read_1
   \                     ??disk_read_0: (+1)
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE054             B.N      ??disk_read_2
    236              if (Stat & STA_NOINIT) return RES_NOTRDY;     //未就绪
   \                     ??disk_read_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable6
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD501             BPL.N    ??disk_read_3
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xE04E             B.N      ??disk_read_2
    237          
    238              /* 检测参数 */
    239              if ((NULL == buff))
   \                     ??disk_read_3: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD101             BNE.N    ??disk_read_4
    240              {
    241                  return RES_PARERR;//参数无效
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xE04A             B.N      ??disk_read_2
    242              }
    243          
    244              if (!SDHC_card.SDHC)
   \                     ??disk_read_4: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable6_1
   \   00000032   0x7C00             LDRB     R0,[R0, #+16]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD102             BNE.N    ??disk_read_5
    245              {
    246                  sector *= SDCARD_BLOCK_SIZE;    /* 如果需要,转换为字节地址 */
   \   00000038   0xF44F 0x7000      MOV      R0,#+512
   \   0000003C   0x4347             MULS     R7,R0,R7
    247              }
    248          
    249              if (count == 1) /* 单块读 */
   \                     ??disk_read_5: (+1)
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E01             CMP      R6,#+1
   \   00000042   0xD11B             BNE.N    ??disk_read_6
    250              {
    251                  command.COMMAND = ESDHC_CMD17;
   \   00000044   0x2011             MOVS     R0,#+17
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
    252                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    253                  command.ARGUMENT = sector;
   \   00000050   0x9701             STR      R7,[SP, #+4]
    254                  command.READ = TRUE;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF88D 0x0002      STRB     R0,[SP, #+2]
    255                  command.BLOCKS = count;
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0x9602             STR      R6,[SP, #+8]
    256          
    257                  if (ESDHC_IOCTL_OK == SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   0000005C   0xA900             ADD      R1,SP,#+0
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x.... 0x....      BL       SDHC_ioctl
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD127             BNE.N    ??disk_read_7
    258                  {
    259                      if (rcvr_datablock(buff, SDCARD_BLOCK_SIZE))
   \   00000068   0xF44F 0x7100      MOV      R1,#+512
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       rcvr_datablock
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD020             BEQ.N    ??disk_read_7
    260                      {
    261                          count = 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x0006             MOVS     R6,R0
   \   0000007A   0xE01D             B.N      ??disk_read_7
    262                      }
    263                  }
    264              }
    265              else
    266              {
    267                  /* 多块读 */
    268                  //
    269                  command.COMMAND = ESDHC_CMD18;
   \                     ??disk_read_6: (+1)
   \   0000007C   0x2012             MOVS     R0,#+18
   \   0000007E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    270                  //command.COMMAND = ESDHC_CMD17;
    271                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF88D 0x0001      STRB     R0,[SP, #+1]
    272                  command.ARGUMENT = sector;
   \   00000088   0x9701             STR      R7,[SP, #+4]
    273                  command.READ = TRUE;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    274                  command.BLOCKS = count;
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x9602             STR      R6,[SP, #+8]
    275          
    276                  if (ESDHC_IOCTL_OK == SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   00000094   0xA900             ADD      R1,SP,#+0
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x.... 0x....      BL       SDHC_ioctl
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD10B             BNE.N    ??disk_read_7
    277                  {
    278                      if (rcvr_datablock(buff, SDCARD_BLOCK_SIZE * count))
   \   000000A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A2   0xF44F 0x7000      MOV      R0,#+512
   \   000000A6   0xFB00 0xF106      MUL      R1,R0,R6
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       rcvr_datablock
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??disk_read_7
    279                      {
    280                          count = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x0006             MOVS     R6,R0
    281                      }
    282                  }
    283              }
    284          
    285              return count ? RES_ERROR : RES_OK;
   \                     ??disk_read_7: (+1)
   \   000000B8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BA   0x2E00             CMP      R6,#+0
   \   000000BC   0xD001             BEQ.N    ??disk_read_8
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE000             B.N      ??disk_read_9
   \                     ??disk_read_8: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \                     ??disk_read_9: (+1)
   \   000000C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_read_2: (+1)
   \   000000C6   0xB007             ADD      SP,SP,#+28
   \   000000C8   0xBDF0             POP      {R4-R7,PC}       ;; return
    286          }
    287          
    288          /*!
    289           *  @brief      发送数据包到 MMC
    290           *  @param      buff                发送 SDCARD_BLOCK_SIZE 个字节的数据块的数据缓冲区地址
    291           *  @param      btr                 字节数目(必须是 4 的倍数)
    292           *  @since      v5.0
    293           */

   \                                 In section .text, align 2, keep-with-next
    294          static int xmit_datablock (const uint8 *buff, uint32 btr    )
    295          {
   \                     xmit_datablock: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    296              uint32  bytes, i;
    297              uint32  *ptr = (uint32 *)buff;
   \   00000004   0x0013             MOVS     R3,R2
    298          
    299              /* Write data in 4 byte counts */
    300              bytes = btr;
   \   00000006   0x000C             MOVS     R4,R1
    301              while (bytes)
   \                     ??xmit_datablock_0: (+1)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD025             BEQ.N    ??xmit_datablock_1
    302              {
    303                  i = bytes > SDCARD_BLOCK_SIZE ? SDCARD_BLOCK_SIZE : bytes;
   \   0000000C   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000010   0xD902             BLS.N    ??xmit_datablock_2
   \   00000012   0xF44F 0x7500      MOV      R5,#+512
   \   00000016   0xE000             B.N      ??xmit_datablock_3
   \                     ??xmit_datablock_2: (+1)
   \   00000018   0x0025             MOVS     R5,R4
    304                  bytes -= i;
   \                     ??xmit_datablock_3: (+1)
   \   0000001A   0x1B64             SUBS     R4,R4,R5
    305                  for (i = (i + 3) >> 2; i != 0; i--)
   \   0000001C   0x1CE8             ADDS     R0,R5,#+3
   \   0000001E   0x0885             LSRS     R5,R0,#+2
   \                     ??xmit_datablock_4: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD0F1             BEQ.N    ??xmit_datablock_0
    306                  {
    307                      if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000024   0x....             LDR.N    R0,??DataTable6_2  ;; 0x400b1030
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF410 0x0FE0      TST      R0,#0x700000
   \   0000002C   0xD00A             BEQ.N    ??xmit_datablock_5
    308                      {
    309                          SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   0000002E   0x....             LDR.N    R0,??DataTable6_2  ;; 0x400b1030
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000036   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000003A   0x....             LDR.N    R6,??DataTable6_2  ;; 0x400b1030
   \   0000003C   0x6030             STR      R0,[R6, #+0]
    310                          return IO_ERROR;
   \   0000003E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000042   0xE00A             B.N      ??xmit_datablock_6
    311                      }
    312                      while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN_MASK)) {};
   \                     ??xmit_datablock_5: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable6_3  ;; 0x400b1024
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x0540             LSLS     R0,R0,#+21
   \   0000004A   0xD5FB             BPL.N    ??xmit_datablock_5
    313          
    314                      SDHC_DATPORT = *ptr++;
   \   0000004C   0x6818             LDR      R0,[R3, #+0]
   \   0000004E   0x....             LDR.N    R6,??DataTable6_4  ;; 0x400b1020
   \   00000050   0x6030             STR      R0,[R6, #+0]
   \   00000052   0x1D1B             ADDS     R3,R3,#+4
    315                  }
   \   00000054   0x1E6D             SUBS     R5,R5,#+1
   \   00000056   0xE7E3             B.N      ??xmit_datablock_4
    316              }
    317          
    318              return 1;
   \                     ??xmit_datablock_1: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \                     ??xmit_datablock_6: (+1)
   \   0000005A   0xBC70             POP      {R4-R6}
   \   0000005C   0x4770             BX       LR               ;; return
    319          }
    320          
    321          
    322          
    323          /*!
    324           *  @brief      写扇区
    325           *  @param      drv                 驱动号(目前代码仅支持为 0)
    326           *  @param      buff                缓冲区地址
    327           *  @param      sector              扇区号
    328           *  @param      count               扇区数(1~255)
    329           *  @return     DRESULT             执行结果
    330           *  @since      v5.0
    331           */

   \                                 In section .text, align 2, keep-with-next
    332          DRESULT disk_write (uint8  drv, const uint8  *buff, uint32 sector, uint8  count)
    333          {
   \                     disk_write: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001E             MOVS     R6,R3
    334              ESDHC_CMD_t command;
    335              //pSDCARD_t    sdcard_ptr = (pSDCARD_t)&SDHC_card;
    336          
    337              if (drv || !count) return RES_PARERR;
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD102             BNE.N    ??disk_write_0
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD101             BNE.N    ??disk_write_1
   \                     ??disk_write_0: (+1)
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE091             B.N      ??disk_write_2
    338              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_write_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable6
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD501             BPL.N    ??disk_write_3
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xE08B             B.N      ??disk_write_2
    339              if (Stat & STA_PROTECT) return RES_WRPRT;
   \                     ??disk_write_3: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable6
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x0740             LSLS     R0,R0,#+29
   \   0000002E   0xD501             BPL.N    ??disk_write_4
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xE085             B.N      ??disk_write_2
    340          
    341              /* Check parameters */
    342              if ((NULL == buff))
   \                     ??disk_write_4: (+1)
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD101             BNE.N    ??disk_write_5
    343              {
    344                  return RES_PARERR;      // 参数无效
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xE081             B.N      ??disk_write_2
    345              }
    346          
    347              if (!SDHC_card.SDHC)
   \                     ??disk_write_5: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable6_1
   \   0000003E   0x7C00             LDRB     R0,[R0, #+16]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD102             BNE.N    ??disk_write_6
    348              {
    349                  sector *= SDCARD_BLOCK_SIZE;    /* Convert to byte address if needed */
   \   00000044   0xF44F 0x7000      MOV      R0,#+512
   \   00000048   0x4347             MULS     R7,R0,R7
    350              }
    351          
    352              if (count == 1) /* Single block write */
   \                     ??disk_write_6: (+1)
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x2E01             CMP      R6,#+1
   \   0000004E   0xD11B             BNE.N    ??disk_write_7
    353              {
    354                  command.COMMAND = ESDHC_CMD24;
   \   00000050   0x2018             MOVS     R0,#+24
   \   00000052   0xF88D 0x0000      STRB     R0,[SP, #+0]
    355                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF88D 0x0001      STRB     R0,[SP, #+1]
    356                  command.ARGUMENT = sector;
   \   0000005C   0x9701             STR      R7,[SP, #+4]
    357                  command.READ = FALSE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF88D 0x0002      STRB     R0,[SP, #+2]
    358                  command.BLOCKS = count;
   \   00000064   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000066   0x9602             STR      R6,[SP, #+8]
    359          
    360                  if (ESDHC_IOCTL_OK == SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   00000068   0xA900             ADD      R1,SP,#+0
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x.... 0x....      BL       SDHC_ioctl
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD13C             BNE.N    ??disk_write_8
    361                  {
    362                      if (xmit_datablock(buff, SDCARD_BLOCK_SIZE))
   \   00000074   0xF44F 0x7100      MOV      R1,#+512
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x.... 0x....      BL       xmit_datablock
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD035             BEQ.N    ??disk_write_8
    363                      {
    364                          count = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0006             MOVS     R6,R0
   \   00000086   0xE032             B.N      ??disk_write_8
    365                      }
    366                  }
    367              }
    368              else
    369              {
    370                  command.COMMAND = ESDHC_CMD25;
   \                     ??disk_write_7: (+1)
   \   00000088   0x2019             MOVS     R0,#+25
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    371                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xF88D 0x0001      STRB     R0,[SP, #+1]
    372                  command.ARGUMENT = sector;
   \   00000094   0x9701             STR      R7,[SP, #+4]
    373                  command.READ = FALSE;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF88D 0x0002      STRB     R0,[SP, #+2]
    374                  command.BLOCKS = count;
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0x9602             STR      R6,[SP, #+8]
    375          
    376                  if (ESDHC_IOCTL_OK == SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   000000A0   0xA900             ADD      R1,SP,#+0
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x.... 0x....      BL       SDHC_ioctl
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD120             BNE.N    ??disk_write_8
    377                  {
    378                      if (xmit_datablock(buff, SDCARD_BLOCK_SIZE * count))
   \   000000AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AE   0xF44F 0x7000      MOV      R0,#+512
   \   000000B2   0xFB00 0xF106      MUL      R1,R0,R6
   \   000000B6   0x0028             MOVS     R0,R5
   \   000000B8   0x.... 0x....      BL       xmit_datablock
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD001             BEQ.N    ??disk_write_9
    379                      {
    380                          count = 0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x0006             MOVS     R6,R0
    381                      }
    382                      while((SDHC_IRQSTAT & SDHC_IRQSTAT_TC_MASK)==0);
   \                     ??disk_write_9: (+1)
   \   000000C4   0x....             LDR.N    R0,??DataTable6_2  ;; 0x400b1030
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0x0780             LSLS     R0,R0,#+30
   \   000000CA   0xD5FB             BPL.N    ??disk_write_9
    383          
    384                      if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000000CC   0x....             LDR.N    R0,??DataTable6_2  ;; 0x400b1030
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000D4   0xD005             BEQ.N    ??disk_write_10
    385                      {
    386                          SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK;
   \   000000D6   0x....             LDR.N    R0,??DataTable6_2  ;; 0x400b1030
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0xF450 0x00E0      ORRS     R0,R0,#0x700000
   \   000000DE   0x....             LDR.N    R1,??DataTable6_2  ;; 0x400b1030
   \   000000E0   0x6008             STR      R0,[R1, #+0]
    387                      }
    388                      SDHC_IRQSTAT |= SDHC_IRQSTAT_TC_MASK | SDHC_IRQSTAT_BRR_MASK | SDHC_IRQSTAT_BWR_MASK;
   \                     ??disk_write_10: (+1)
   \   000000E2   0x....             LDR.N    R0,??DataTable6_2  ;; 0x400b1030
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF050 0x0032      ORRS     R0,R0,#0x32
   \   000000EA   0x....             LDR.N    R1,??DataTable6_2  ;; 0x400b1030
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    389          
    390          
    391                  }
    392              }
    393          
    394              /* Wait for card ready / transaction state */
    395              do
    396              {
    397                  command.COMMAND = ESDHC_CMD13;
   \                     ??disk_write_8: (+1)
   \   000000EE   0x200D             MOVS     R0,#+13
   \   000000F0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    398                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xF88D 0x0001      STRB     R0,[SP, #+1]
    399                  command.ARGUMENT = SDHC_card.ADDRESS;
   \   000000FA   0x....             LDR.N    R0,??DataTable6_1
   \   000000FC   0x68C0             LDR      R0,[R0, #+12]
   \   000000FE   0x9001             STR      R0,[SP, #+4]
    400                  command.READ = FALSE;
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xF88D 0x0002      STRB     R0,[SP, #+2]
    401                  command.BLOCKS = 0;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x9002             STR      R0,[SP, #+8]
    402                  if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   0000010A   0xA900             ADD      R1,SP,#+0
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x.... 0x....      BL       SDHC_ioctl
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD001             BEQ.N    ??disk_write_11
    403                  {
    404                      return RES_ERROR;
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0xE012             B.N      ??disk_write_2
    405                  }
    406          
    407                  /* Card status error check */
    408                  if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??disk_write_11: (+1)
   \   0000011A   0x9803             LDR      R0,[SP, #+12]
   \   0000011C   0x....             LDR.N    R1,??DataTable6_5  ;; 0xffd98008
   \   0000011E   0x4208             TST      R0,R1
   \   00000120   0xD001             BEQ.N    ??disk_write_12
    409                  {
    410                      return RES_ERROR;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xE00C             B.N      ??disk_write_2
    411                  }
    412              }
    413              while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));
   \                     ??disk_write_12: (+1)
   \   00000126   0x9803             LDR      R0,[SP, #+12]
   \   00000128   0xF410 0x50F8      ANDS     R0,R0,#0x1F00
   \   0000012C   0xF5B0 0x6F10      CMP      R0,#+2304
   \   00000130   0xD1DD             BNE.N    ??disk_write_8
    414          
    415              return count ? RES_ERROR : RES_OK;
   \   00000132   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000134   0x2E00             CMP      R6,#+0
   \   00000136   0xD001             BEQ.N    ??disk_write_13
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xE000             B.N      ??disk_write_14
   \                     ??disk_write_13: (+1)
   \   0000013C   0x2000             MOVS     R0,#+0
   \                     ??disk_write_14: (+1)
   \   0000013E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_write_2: (+1)
   \   00000140   0xB007             ADD      SP,SP,#+28
   \   00000142   0xBDF0             POP      {R4-R7,PC}       ;; return
    416          }
    417          
    418          
    419          /*!
    420           *  @brief      硬盘 控制命令
    421           *  @param      drv                 驱动号
    422           *  @param      ctrl                控制命令
    423           *  @param      buff                缓冲区地址，用于接收和发送控制数据
    424           *  @since      v5.0
    425           */

   \                                 In section .text, align 2, keep-with-next
    426          DRESULT disk_ioctl (
    427              uint8 drv,      /* Physical drive nmuber (0) */
    428              uint8 ctrl,     /* Control code */
    429              void  *buff     /* Buffer to send/receive control data */
    430          )
    431          {
   \                     disk_ioctl: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    432              DRESULT              res;
    433              ESDHC_CMD_t command;
    434              //pSDCARD_t  sdcard_ptr = (pSDCARD_t)&SDHC_card;
    435          
    436              if (drv) return RES_PARERR;
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??disk_ioctl_0
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE04B             B.N      ??disk_ioctl_1
    437          
    438              res = RES_ERROR;
   \                     ??disk_ioctl_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x0007             MOVS     R7,R0
    439          
    440              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \   00000018   0x....             LDR.N    R0,??DataTable6
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD501             BPL.N    ??disk_ioctl_2
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0xE043             B.N      ??disk_ioctl_1
    441          
    442              switch (ctrl)
   \                     ??disk_ioctl_2: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD005             BEQ.N    ??disk_ioctl_3
   \   0000002A   0x2D02             CMP      R5,#+2
   \   0000002C   0xD00C             BEQ.N    ??disk_ioctl_4
   \   0000002E   0xD305             BCC.N    ??disk_ioctl_5
   \   00000030   0x2D03             CMP      R5,#+3
   \   00000032   0xD00F             BEQ.N    ??disk_ioctl_6
   \   00000034   0xE036             B.N      ??disk_ioctl_7
    443              {
    444              case CTRL_SYNC :        /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
    445                  res = RES_OK;
   \                     ??disk_ioctl_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0007             MOVS     R7,R0
    446                  break;
   \   0000003A   0xE035             B.N      ??disk_ioctl_8
    447          
    448              case GET_SECTOR_COUNT : /* Get number of sectors on the disk (uint32) */
    449                  *(unsigned long *)buff = SDHC_card.NUM_BLOCKS;
   \                     ??disk_ioctl_5: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable6_1
   \   0000003E   0x6880             LDR      R0,[R0, #+8]
   \   00000040   0x6030             STR      R0,[R6, #+0]
    450                  res = RES_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0007             MOVS     R7,R0
    451                  break;
   \   00000046   0xE02F             B.N      ??disk_ioctl_8
    452          
    453              case GET_SECTOR_SIZE :  /* Get R/W sector size (WORD) */
    454                  *(unsigned short *)buff = SDCARD_BLOCK_SIZE;
   \                     ??disk_ioctl_4: (+1)
   \   00000048   0xF44F 0x7000      MOV      R0,#+512
   \   0000004C   0x8030             STRH     R0,[R6, #+0]
    455                  res = RES_OK;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0007             MOVS     R7,R0
    456                  break;
   \   00000052   0xE029             B.N      ??disk_ioctl_8
    457          
    458              case GET_BLOCK_SIZE :           /* Get erase block size in unit of sector (uint32) */
    459                  // Implementar
    460                  command.COMMAND = ESDHC_CMD9;
   \                     ??disk_ioctl_6: (+1)
   \   00000054   0x2009             MOVS     R0,#+9
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
    461                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    462                  command.ARGUMENT = SDHC_card.ADDRESS;
   \   00000060   0x....             LDR.N    R0,??DataTable6_1
   \   00000062   0x68C0             LDR      R0,[R0, #+12]
   \   00000064   0x9001             STR      R0,[SP, #+4]
    463                  command.READ = FALSE;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF88D 0x0002      STRB     R0,[SP, #+2]
    464                  command.BLOCKS = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x9002             STR      R0,[SP, #+8]
    465                  if (ESDHC_IOCTL_OK != SDHC_ioctl (ESDHC_IOCTL_SEND_CMD, &command))
   \   00000070   0xA900             ADD      R1,SP,#+0
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      BL       SDHC_ioctl
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD001             BEQ.N    ??disk_ioctl_9
    466                  {
    467                      return RES_ERROR;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE015             B.N      ??disk_ioctl_1
    468                  }
    469                  if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??disk_ioctl_9: (+1)
   \   00000080   0x9806             LDR      R0,[SP, #+24]
   \   00000082   0xF410 0x0F40      TST      R0,#0xC00000
   \   00000086   0xD10A             BNE.N    ??disk_ioctl_10
    470                  {
    471                      //SD V1
    472                      *(unsigned long *)buff = ((((command.RESPONSE[2] >> 18) & 0x7F) + 1) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));
   \   00000088   0x9805             LDR      R0,[SP, #+20]
   \   0000008A   0xF3C0 0x4086      UBFX     R0,R0,#+18,#+7
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0x9906             LDR      R1,[SP, #+24]
   \   00000092   0x0A09             LSRS     R1,R1,#+8
   \   00000094   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   00000098   0x1E49             SUBS     R1,R1,#+1
   \   0000009A   0x4088             LSLS     R0,R0,R1
   \   0000009C   0x6030             STR      R0,[R6, #+0]
    473                  }
    474                  else
    475                  {
    476                      //SD V2
    477                      // Implementar
    478                      //*(uint32*)buff = (((command.RESPONSE[2] >> 18) & 0x7F) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));
    479                  }
    480                  res = RES_OK;
   \                     ??disk_ioctl_10: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0007             MOVS     R7,R0
    481                  break;
   \   000000A2   0xE001             B.N      ??disk_ioctl_8
    482          
    483              default:
    484                  res = RES_PARERR;
   \                     ??disk_ioctl_7: (+1)
   \   000000A4   0x2004             MOVS     R0,#+4
   \   000000A6   0x0007             MOVS     R7,R0
    485              }
    486          
    487              return res;
   \                     ??disk_ioctl_8: (+1)
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_ioctl_1: (+1)
   \   000000AC   0xB007             ADD      SP,SP,#+28
   \   000000AE   0xBDF0             POP      {R4-R7,PC}       ;; return
    488          }
    489          
    490          
    491          /*!
    492           *  @brief      获取硬盘状态
    493           *  @return     硬盘状态
    494           *  @since      v5.0
    495           */

   \                                 In section .text, align 2, keep-with-next
    496          DSTATUS disk_status (
    497              uint8 drv       /* Physical drive nmuber (0) */
    498          )
    499          {
   \                     disk_status: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    500              if (drv) return STA_NOINIT;     /* Supports only single drive */
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??disk_status_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE001             B.N      ??disk_status_1
    501              return Stat;
   \                     ??disk_status_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \                     ??disk_status_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    502          }
    503          
    504          
    505          /*!
    506           *  @brief      获取时间(为了满足接口需要而添加，实际上并没用实现功能)
    507           *  @return     结果总是为 0
    508           *  @since      v5.0
    509           */

   \                                 In section .text, align 2, keep-with-next
    510          uint32  get_fattime (void)
    511          {
    512              return   0;
   \                     get_fattime: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    513          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     SDHC_card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x400B1020         DC32     0x400b1020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0xFFD98008         DC32     0xffd98008
    514          
    515          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   disk_initialize
        56   -> SDHC_ioctl
      48   disk_ioctl
        48   -> SDHC_ioctl
      48   disk_read
        48   -> SDHC_ioctl
        48   -> rcvr_datablock
       0   disk_status
      48   disk_write
        48   -> SDHC_ioctl
        48   -> xmit_datablock
       0   get_fattime
      16   rcvr_datablock
      12   xmit_datablock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       1  Stat
     640  disk_initialize
     176  disk_ioctl
     202  disk_read
      18  disk_status
     324  disk_write
       4  get_fattime
     124  rcvr_datablock
      94  xmit_datablock

 
     1 byte  in section .data
 1 606 bytes in section .text
 
 1 606 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
