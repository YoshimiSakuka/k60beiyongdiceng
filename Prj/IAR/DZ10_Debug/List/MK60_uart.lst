###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:31
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_uart.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_uart.c -D
#        DEBUG -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\MK60_uart.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\MK60_uart.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_uart.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       MK60_uart.c
     11           * @brief      uart串口函数
     12           * @author     山外科技
     13           * @version    v5.2
     14           * @date       2014-10-09
     15           */
     16          
     17          
     18          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     19          #include "MK60_uart.h"
     20          

   \                                 In section .data, align 4
     21          UART_MemMapPtr UARTN[UART_MAX] = {UART0_BASE_PTR, UART1_BASE_PTR, UART2_BASE_PTR, UART3_BASE_PTR, UART4_BASE_PTR, UART5_BASE_PTR}; //定义五个指针数组保存 UARTN 的地址
   \                     UARTN:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H, 4006D000H, 400EA000H, 400EB000H
   \              0x4006B000   
   \              0x4006C000   
   \              0x4006D000   
   \              0x400EA000   
   \              0x400EB000   
     22          
     23          
     24          /*!
     25           *  @brief      初始化串口，设置波特率
     26           *  @param      UARTn_e       模块号（UART0~UART5）
     27           *  @param      baud        波特率，如9600、19200、56000、115200等
     28           *  @since      v5.0
     29           *  @note       UART所用的管脚在 App\Inc\PORT_cfg.h 里进行配置，
     30                          printf所用的管脚和波特率在 App\Inc\MK60_conf.h 里进行配置
     31           *  Sample usage:       uart_init (UART3, 9600);        //初始化串口3，波特率为9600
     32           */

   \                                 In section .text, align 2, keep-with-next
     33          void uart_init (UARTn_e uratn, uint32 baud)
     34          {
   \                     uart_init: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     35              register uint16 sbr, brfa;
     36              uint8 temp;
     37              uint32 sysclk;     //时钟
     38          
     39              /* 配置 UART功能的 复用管脚 */
     40              switch(uratn)
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??uart_init_0
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD02C             BEQ.N    ??uart_init_1
   \   00000012   0xD318             BCC.N    ??uart_init_2
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD04F             BEQ.N    ??uart_init_3
   \   00000018   0xD33B             BCC.N    ??uart_init_4
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD05F             BEQ.N    ??uart_init_5
   \   0000001E   0xE071             B.N      ??uart_init_6
     41              {
     42              case UART0:
     43                  SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;      //使能 UART0 时钟
   \                     ??uart_init_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40048034
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x40048034
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     44          
     45                  if(UART0_RX_PIN == PTA1)
     46                  {
     47                      port_init( UART0_RX_PIN, ALT2);
     48                  }
     49                  else if((UART0_RX_PIN == PTA15) || (UART0_RX_PIN == PTB16) || (UART0_RX_PIN == PTD6)  )
     50                  {
     51                      port_init( UART0_RX_PIN, ALT3);
   \   00000030   0xF44F 0x7140      MOV      R1,#+768
   \   00000034   0x2066             MOVS     R0,#+102
   \   00000036   0x.... 0x....      BL       port_init
     52                  }
     53                  else
     54                  {
     55                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
     56                  }
     57          
     58                  if(UART0_TX_PIN == PTA2)
     59                  {
     60                      port_init( UART0_TX_PIN, ALT2);
     61                  }
     62                  else if((UART0_TX_PIN == PTA14) || (UART0_TX_PIN == PTB17) || (UART0_TX_PIN == PTD7) )
     63                  {
     64                      port_init( UART0_TX_PIN, ALT3);
   \   0000003A   0xF44F 0x7140      MOV      R1,#+768
   \   0000003E   0x2067             MOVS     R0,#+103
   \   00000040   0x.... 0x....      BL       port_init
     65                  }
     66                  else
     67                  {
     68                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
     69                  }
     70          
     71                  break;
   \   00000044   0xE05E             B.N      ??uart_init_7
     72          
     73              case UART1:
     74                  SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
   \                     ??uart_init_2: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40048034
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x40048034
   \   00000054   0x6008             STR      R0,[R1, #+0]
     75          
     76                  if((UART1_RX_PIN == PTC3) || (UART1_RX_PIN == PTE1))
     77                  {
     78                      port_init( UART1_RX_PIN, ALT3);
   \   00000056   0xF44F 0x7140      MOV      R1,#+768
   \   0000005A   0x2043             MOVS     R0,#+67
   \   0000005C   0x.... 0x....      BL       port_init
     79                  }
     80                  else
     81                  {
     82                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
     83                  }
     84          
     85                  if((UART1_TX_PIN == PTC4) || (UART1_TX_PIN == PTE0))
     86                  {
     87                      port_init( UART1_TX_PIN, ALT3);
   \   00000060   0xF44F 0x7140      MOV      R1,#+768
   \   00000064   0x2044             MOVS     R0,#+68
   \   00000066   0x.... 0x....      BL       port_init
     88                  }
     89                  else
     90                  {
     91                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
     92                  }
     93          
     94                  break;
   \   0000006A   0xE04B             B.N      ??uart_init_7
     95          
     96              case UART2:
     97                  SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
   \                     ??uart_init_1: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40048034
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x40048034
   \   0000007A   0x6008             STR      R0,[R1, #+0]
     98                  if(UART2_TX_PIN == PTD3)
     99                  {
    100                      port_init( UART2_TX_PIN, ALT3);
   \   0000007C   0xF44F 0x7140      MOV      R1,#+768
   \   00000080   0x2063             MOVS     R0,#+99
   \   00000082   0x.... 0x....      BL       port_init
    101                  }
    102                  else
    103                  {
    104                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    105                  }
    106          
    107          
    108                  if(UART2_RX_PIN == PTD2)
    109                  {
    110                      port_init( UART2_RX_PIN, ALT3);
   \   00000086   0xF44F 0x7140      MOV      R1,#+768
   \   0000008A   0x2062             MOVS     R0,#+98
   \   0000008C   0x.... 0x....      BL       port_init
    111                  }
    112                  else
    113                  {
    114                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    115                  }
    116          
    117                  break;
   \   00000090   0xE038             B.N      ??uart_init_7
    118          
    119              case UART3:
    120                  SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \                     ??uart_init_4: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x40048034
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x40048034
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    121          
    122                  if((UART3_RX_PIN == PTB10)|| (UART3_RX_PIN == PTC16) || (UART3_RX_PIN == PTE5) )
    123                  {
    124                      port_init( UART3_RX_PIN, ALT3);
   \   000000A2   0xF44F 0x7140      MOV      R1,#+768
   \   000000A6   0x2050             MOVS     R0,#+80
   \   000000A8   0x.... 0x....      BL       port_init
    125                  }
    126                  else
    127                  {
    128                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    129                  }
    130          
    131                  if((UART3_TX_PIN == PTB11) || (UART3_TX_PIN == PTC17) || (UART3_TX_PIN == PTE4) )
    132                  {
    133                      port_init( UART3_TX_PIN, ALT3);             //在PTB11上使能UART3_RXD
   \   000000AC   0xF44F 0x7140      MOV      R1,#+768
   \   000000B0   0x2051             MOVS     R0,#+81
   \   000000B2   0x.... 0x....      BL       port_init
    134                  }
    135                  else
    136                  {
    137                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    138                  }
    139                  break;
   \   000000B6   0xE025             B.N      ??uart_init_7
    140          
    141              case UART4:
    142                  SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
   \                     ??uart_init_3: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40048028
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40048028
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    143          
    144                  if((UART4_RX_PIN == PTC14) || (UART4_RX_PIN == PTE25)  )
    145                  {
    146                      port_init( UART4_RX_PIN, ALT3);            //在PTC14上使能UART4_RXD
   \   000000C8   0xF44F 0x7140      MOV      R1,#+768
   \   000000CC   0x204E             MOVS     R0,#+78
   \   000000CE   0x.... 0x....      BL       port_init
    147                  }
    148                  else
    149                  {
    150                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    151                  }
    152          
    153                  if((UART4_TX_PIN == PTC15) || (UART4_TX_PIN == PTE24)  )
    154                  {
    155                      port_init( UART4_TX_PIN, ALT3);
   \   000000D2   0xF44F 0x7140      MOV      R1,#+768
   \   000000D6   0x204F             MOVS     R0,#+79
   \   000000D8   0x.... 0x....      BL       port_init
    156                  }
    157                  else
    158                  {
    159                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    160                  }
    161                  break;
   \   000000DC   0xE012             B.N      ??uart_init_7
    162          
    163              case UART5:
    164                  SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
   \                     ??uart_init_5: (+1)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40048028
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40048028
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    165          
    166                  if((UART5_RX_PIN == PTD8) || (UART5_RX_PIN == PTE9))
    167                  {
    168                      port_init( UART5_RX_PIN, ALT3);
   \   000000EE   0xF44F 0x7140      MOV      R1,#+768
   \   000000F2   0x2089             MOVS     R0,#+137
   \   000000F4   0x.... 0x....      BL       port_init
    169                  }
    170                  else
    171                  {
    172                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    173                  }
    174          
    175                  if((UART5_TX_PIN == PTD9) ||(UART5_TX_PIN == PTE8))
    176                  {
    177                      port_init( UART5_TX_PIN, ALT3);             //在PTD9上使能UART5_RXD
   \   000000F8   0xF44F 0x7140      MOV      R1,#+768
   \   000000FC   0x2088             MOVS     R0,#+136
   \   000000FE   0x.... 0x....      BL       port_init
    178                  }
    179                  else
    180                  {
    181                      ASSERT(0);                           //上诉条件都不满足，直接断言失败了，设置管脚有误？
    182                  }
    183                  break;
   \   00000102   0xE7FF             B.N      ??uart_init_7
    184              default:
    185                  break;
    186              }
    187          
    188              //设置的时候，应该禁止发送接受
    189              UART_C2_REG(UARTN[uratn]) &= ~(0
    190                                             | UART_C2_TE_MASK
    191                                             | UART_C2_RE_MASK
    192                                            );
   \                     ??uart_init_6: (+1)
   \                     ??uart_init_7: (+1)
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000108   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000010E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000110   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000118   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000011E   0x70C8             STRB     R0,[R1, #+3]
    193          
    194          
    195              //配置成8位无校验模式
    196              //设置 UART 数据格式、校验方式和停止位位数。通过设置 UART 模块控制寄存器 C1 实现；
    197              UART_C1_REG(UARTN[uratn]) |= (0
    198                                            //| UART_C1_M_MASK                    //9 位或 8 位模式选择 : 0 为 8位 ，1 为 9位（注释了表示0，即8位） （如果是9位，位8在UARTx_C3里）
    199                                            //| UART_C1_PE_MASK                   //奇偶校验使能（注释了表示禁用）
    200                                            //| UART_C1_PT_MASK                   //校验位类型 : 0 为 偶校验 ，1 为 奇校验
    201                                           );
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000124   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000126   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000012A   0x7880             LDRB     R0,[R0, #+2]
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000130   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000132   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000136   0x7088             STRB     R0,[R1, #+2]
    202          
    203              //计算波特率，串口0、1使用内核时钟，其它串口使用bus时钟
    204              if ((uratn == UART0) || (uratn == UART1))
   \   00000138   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013A   0x2C00             CMP      R4,#+0
   \   0000013C   0xD002             BEQ.N    ??uart_init_8
   \   0000013E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000140   0x2C01             CMP      R4,#+1
   \   00000142   0xD107             BNE.N    ??uart_init_9
    205              {
    206                  sysclk = core_clk_khz * 1000;                                   //内核时钟
   \                     ??uart_init_8: (+1)
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000014E   0x4348             MULS     R0,R1,R0
   \   00000150   0x4681             MOV      R9,R0
   \   00000152   0xE005             B.N      ??uart_init_10
    207              }
    208              else
    209              {
    210                  sysclk = bus_clk_khz * 1000;                                    //bus时钟
   \                     ??uart_init_9: (+1)
   \   00000154   0x....             LDR.N    R0,??DataTable13_6
   \   00000156   0x6800             LDR      R0,[R0, #+0]
   \   00000158   0xF44F 0x717A      MOV      R1,#+1000
   \   0000015C   0x4348             MULS     R0,R1,R0
   \   0000015E   0x4681             MOV      R9,R0
    211              }
    212          
    213              //UART 波特率 = UART 模块时钟 / (16 × (SBR[12:0] + BRFA))
    214              //不考虑 BRFA 的情况下， SBR = UART 模块时钟 / (16 * UART 波特率)
    215              sbr = (uint16)(sysclk / (baud * 16));
   \                     ??uart_init_10: (+1)
   \   00000160   0x0128             LSLS     R0,R5,#+4
   \   00000162   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   00000166   0x0006             MOVS     R6,R0
    216              if(sbr > 0x1FFF)sbr = 0x1FFF;                                       //SBR 是 13bit，最大为 0x1FFF
   \   00000168   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000016A   0xF5B6 0x5F00      CMP      R6,#+8192
   \   0000016E   0xDB02             BLT.N    ??uart_init_11
   \   00000170   0xF641 0x70FF      MOVW     R0,#+8191
   \   00000174   0x0006             MOVS     R6,R0
    217          
    218              //已知 SBR ，则 BRFA =  = UART 模块时钟 / UART 波特率 - 16 ×SBR[12:0]
    219              brfa = (sysclk / baud)  - (sbr * 16);
   \                     ??uart_init_11: (+1)
   \   00000176   0xFBB9 0xF0F5      UDIV     R0,R9,R5
   \   0000017A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000017C   0xEBB0 0x1006      SUBS     R0,R0,R6, LSL #+4
   \   00000180   0x0007             MOVS     R7,R0
    220              ASSERT( brfa <= 0x1F);                  //断言，如果此值不符合条件，则设置的条件不满足寄存器的设置
   \   00000182   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000184   0x2F20             CMP      R7,#+32
   \   00000186   0xDB03             BLT.N    ??uart_init_12
   \   00000188   0x21DC             MOVS     R1,#+220
   \   0000018A   0x....             LDR.N    R0,??DataTable13_7
   \   0000018C   0x.... 0x....      BL       assert_failed
    221                                                      //可以通过增大波特率来解决这个问题
    222          
    223              //写 SBR
    224              temp = UART_BDH_REG(UARTN[uratn]) & (~UART_BDH_SBR_MASK);           //缓存 清空 SBR 的 UARTx_BDH的值
   \                     ??uart_init_12: (+1)
   \   00000190   0x....             LDR.N    R0,??DataTable13_4
   \   00000192   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000194   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000198   0x7800             LDRB     R0,[R0, #+0]
   \   0000019A   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000019E   0x4680             MOV      R8,R0
    225              UART_BDH_REG(UARTN[uratn]) = temp |  UART_BDH_SBR(sbr >> 8);        //先写入SBR高位
   \   000001A0   0xF3C6 0x2004      UBFX     R0,R6,#+8,#+5
   \   000001A4   0xEA50 0x0008      ORRS     R0,R0,R8
   \   000001A8   0x....             LDR.N    R1,??DataTable13_4
   \   000001AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001AC   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000001B0   0x7008             STRB     R0,[R1, #+0]
    226              UART_BDL_REG(UARTN[uratn]) = UART_BDL_SBR(sbr);                     //再写入SBR低位
   \   000001B2   0x....             LDR.N    R0,??DataTable13_4
   \   000001B4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B6   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000001BA   0x7046             STRB     R6,[R0, #+1]
    227          
    228              //写 BRFD
    229              temp = UART_C4_REG(UARTN[uratn]) & (~UART_C4_BRFA_MASK) ;           //缓存 清空 BRFA 的 UARTx_C4 的值
   \   000001BC   0x....             LDR.N    R0,??DataTable13_4
   \   000001BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001C0   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000001C4   0x7A80             LDRB     R0,[R0, #+10]
   \   000001C6   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   000001CA   0x4680             MOV      R8,R0
    230              UART_C4_REG(UARTN[uratn]) = temp |  UART_C4_BRFA(brfa);             //写入BRFA
   \   000001CC   0xF017 0x001F      ANDS     R0,R7,#0x1F
   \   000001D0   0xEA50 0x0008      ORRS     R0,R0,R8
   \   000001D4   0x....             LDR.N    R1,??DataTable13_4
   \   000001D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D8   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000001DC   0x7288             STRB     R0,[R1, #+10]
    231          
    232          
    233          
    234              //设置FIFO(FIFO的深度是由硬件决定的，软件不能设置)
    235              UART_PFIFO_REG(UARTN[uratn]) |= (0
    236                                               | UART_PFIFO_TXFE_MASK               //使能TX FIFO(注释表示禁止)
    237                                               //| UART_PFIFO_TXFIFOSIZE(0)         //（只读）TX FIFO 大小，0为1字节，1~6为 2^(n+1)字节
    238                                               | UART_PFIFO_RXFE_MASK               //使能RX FIFO(注释表示禁止)
    239                                               //| UART_PFIFO_RXFIFOSIZE(0)         //（只读）RX FIFO 大小，0为1字节，1~6为 2^(n+1)字节
    240                                              );
   \   000001DE   0x....             LDR.N    R0,??DataTable13_4
   \   000001E0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001E2   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000001E6   0x7C00             LDRB     R0,[R0, #+16]
   \   000001E8   0xF050 0x0088      ORRS     R0,R0,#0x88
   \   000001EC   0x....             LDR.N    R1,??DataTable13_4
   \   000001EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F0   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000001F4   0x7408             STRB     R0,[R1, #+16]
    241          
    242              /* 允许发送和接收 */
    243              UART_C2_REG(UARTN[uratn]) |= (0
    244                                            | UART_C2_TE_MASK                     //发送使能
    245                                            | UART_C2_RE_MASK                     //接收使能
    246                                            //| UART_C2_TIE_MASK                  //发送中断或DMA传输请求使能（注释了表示禁用）
    247                                            //| UART_C2_TCIE_MASK                 //发送完成中断使能（注释了表示禁用）
    248                                            //| UART_C2_RIE_MASK                  //接收满中断或DMA传输请求使能（注释了表示禁用）
    249                                           );
   \   000001F6   0x....             LDR.N    R0,??DataTable13_4
   \   000001F8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001FA   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000001FE   0x78C0             LDRB     R0,[R0, #+3]
   \   00000200   0xF050 0x000C      ORRS     R0,R0,#0xC
   \   00000204   0x....             LDR.N    R1,??DataTable13_4
   \   00000206   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000208   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000020C   0x70C8             STRB     R0,[R1, #+3]
    250          
    251              //设置是否允许接收和发送中断。通过设置 UART 模块的 C2 寄存器的
    252              //RIE 和 TIE 位实现。如果使能中断，必须首先实现中断服务程序；
    253          }
   \   0000020E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    254          
    255          /*!
    256           *  @brief      等待接受1个字节
    257           *  @param      UARTn_e       模块号（UART0~UART5）
    258           *  @param      ch          接收地址
    259           *  @since      v5.0
    260           *  @note       如果需要查询接收状态，可用 uart_query ，
    261                          如果需要查询接收数据，可用 uart_querychar
    262           *  Sample usage:
    263                                  char ch;
    264                                  uart_getchar (UART3,&ch);   //等待接受1个字节，保存到 ch里
    265           */

   \                                 In section .text, align 2, keep-with-next
    266          void uart_getchar (UARTn_e uratn, char *ch)
    267          {
    268              //等待接收到数据（使能了FIFO后，以下两种方法都可行，都是一样的意思）
    269              //while( !UART_RCFIFO_REG(UARTN[uratn]) );                                //等待接收到数据数量非0
    270              //while( (UART_SFIFO_REG(UARTN[uratn]) & UART_SFIFO_RXEMPT_MASK)) ;     //等待接收缓冲区/FIFO 非空的
    271          
    272              //如下方法是飞思卡尔官方例程提供的方法
    273              while (!(UART_S1_REG(UARTN[uratn]) & UART_S1_RDRF_MASK));       //等待接收满了
   \                     uart_getchar: (+1)
   \                     ??uart_getchar_0: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable13_4
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000008   0x7912             LDRB     R2,[R2, #+4]
   \   0000000A   0x0692             LSLS     R2,R2,#+26
   \   0000000C   0xD5F8             BPL.N    ??uart_getchar_0
    274          
    275              // 获取接收到的8位数据
    276              *ch =  UART_D_REG(UARTN[uratn]);
   \   0000000E   0x....             LDR.N    R2,??DataTable13_4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000016   0x79D2             LDRB     R2,[R2, #+7]
   \   00000018   0x700A             STRB     R2,[R1, #+0]
    277          
    278              // 获取 9位数据，应该是（需要修改函数的返回类型）：
    279              // *ch =   ((( UARTx_C3_REG(UARTN[uratn]) & UART_C3_R8_MASK ) >> UART_C3_R8_SHIFT ) << 8)   |   UART_D_REG(UARTN[uratn]);  //返回9bit
    280          
    281          }
   \   0000001A   0x4770             BX       LR               ;; return
    282          
    283          
    284          /*!
    285           *  @brief      查询接收1个字符
    286           *  @param      UARTn_e       模块号（UART0~UART5）
    287           *  @param      ch          接收地址
    288           *  @return     1为接收成功，0为接收失败
    289           *  @since      v5.0
    290           *  @note       如果需要等待接收，可用 uart_getchar
    291           *  Sample usage:       char ch ;
    292                                  if( uart_querychar (UART3,&ch) == 1)     //查询接收1个字符，保存到 ch里
    293                                  {
    294                                      printf("成功接收到一个字节");
    295                                  }
    296           */

   \                                 In section .text, align 2, keep-with-next
    297          char uart_querychar (UARTn_e uratn, char *ch)
    298          {
   \                     uart_querychar: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    299              if( UART_RCFIFO_REG(UARTN[uratn]) )         //查询是否接受到数据
   \   00000002   0x....             LDR.N    R0,??DataTable13_4
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   0000000A   0x7D80             LDRB     R0,[R0, #+22]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD007             BEQ.N    ??uart_querychar_0
    300              {
    301                  *ch  =   UART_D_REG(UARTN[uratn]);      //接受到8位的数据
   \   00000010   0x....             LDR.N    R0,??DataTable13_4
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000018   0x79C0             LDRB     R0,[R0, #+7]
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    302                  return  1;                              //返回 1 表示接收成功
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE002             B.N      ??uart_querychar_1
    303              }
    304          
    305              *ch = 0;                                    //接收不到，应该清空了接收区
   \                     ??uart_querychar_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    306              return 0;                                   //返回0表示接收失败
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??uart_querychar_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    307          }
    308          
    309          /*!
    310           *  @brief      查询接收字符串
    311           *  @param      UARTn_e       模块号（UART0~UART5）
    312           *  @param      str         接收地址
    313           *  @param      max_len     最大接收长度
    314           *  @return     接收到的字节数目
    315           *  @since      v5.0
    316           *  Sample usage:       char str[100];
    317                                  uint32 num;
    318                                  num = uart_querystr (UART3,&str,100);
    319                                  if( num != 0 )
    320                                  {
    321                                      printf("成功接收到%d个字节:%s",num,str);
    322                                  }
    323           */

   \                                 In section .text, align 2, keep-with-next
    324          uint32 uart_querystr (UARTn_e uratn, char *str, uint32 max_len)
    325          {
   \                     uart_querystr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    326              uint32 i = 0,j;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    327          
    328              for(j=0;j<10000;j++)                 // 10000 的作用是延时，可自行根据情况修改
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0007             MOVS     R7,R0
   \                     ??uart_querystr_0: (+1)
   \   00000012   0xF242 0x7010      MOVW     R0,#+10000
   \   00000016   0x4287             CMP      R7,R0
   \   00000018   0xD21A             BCS.N    ??uart_querystr_1
    329              {
    330                  while(uart_querychar(uratn, str + i)  )
   \                     ??uart_querystr_2: (+1)
   \   0000001A   0xEB18 0x0105      ADDS     R1,R8,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       uart_querychar
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD010             BEQ.N    ??uart_querystr_3
    331                  {
    332                      j=0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0007             MOVS     R7,R0
    333                      if( *(str + i) == NULL )    //接收到字符串结束符
   \   0000002E   0xF818 0x0005      LDRB     R0,[R8, R5]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD101             BNE.N    ??uart_querystr_4
    334                      {
    335                          return i;
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xE00E             B.N      ??uart_querystr_5
    336                      }
    337          
    338                      i++;
   \                     ??uart_querystr_4: (+1)
   \   0000003A   0xF118 0x0801      ADDS     R8,R8,#+1
    339                      if(i >= max_len)            //超过设定的最大值，退出
   \   0000003E   0x45B0             CMP      R8,R6
   \   00000040   0xD3EB             BCC.N    ??uart_querystr_2
    340                      {
    341                          *(str + i) = 0;     //确保字符串结尾是0x00
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF808 0x0005      STRB     R0,[R8, R5]
    342                          return i;
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0xE005             B.N      ??uart_querystr_5
    343                      }
    344                  }
    345              }
   \                     ??uart_querystr_3: (+1)
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   \   0000004E   0xE7E0             B.N      ??uart_querystr_0
    346          
    347              *(str + i) = 0;                     //确保字符串结尾是0x00
   \                     ??uart_querystr_1: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF808 0x0005      STRB     R0,[R8, R5]
    348              return i;
   \   00000056   0x4640             MOV      R0,R8
   \                     ??uart_querystr_5: (+1)
   \   00000058   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    349          }
    350          
    351          
    352          /*!
    353           *  @brief      查询接收buff
    354           *  @param      UARTn_e       模块号（UART0~UART5）
    355           *  @param      str         接收地址
    356           *  @param      max_len     最大接收长度
    357           *  @return     接收到的字节数目
    358           *  @since      v5.0
    359           *  Sample usage:       char buff[100];
    360                                  uint32 num;
    361                                  num = uart_querybuff (UART3,&buff,100);
    362                                  if( num != 0 )
    363                                  {
    364                                      printf("成功接收到%d个字节:%s",num,buff);
    365                                  }
    366           */

   \                                 In section .text, align 2, keep-with-next
    367          uint32 uart_querybuff (UARTn_e uratn, char *buff, uint32 max_len)
    368          {
   \                     uart_querybuff: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    369              uint32 i = 0,j;
   \   0000000A   0x2700             MOVS     R7,#+0
    370              for(j=0;j<10000;j++)                 // 10000 的作用是延时，可自行根据情况修改
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4680             MOV      R8,R0
   \                     ??uart_querybuff_0: (+1)
   \   00000010   0xF242 0x7010      MOVW     R0,#+10000
   \   00000014   0x4580             CMP      R8,R0
   \   00000016   0xD20E             BCS.N    ??uart_querybuff_1
    371              {
    372                  while(uart_querychar(uratn, buff + i)  )
   \                     ??uart_querybuff_2: (+1)
   \   00000018   0x1979             ADDS     R1,R7,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       uart_querychar
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??uart_querybuff_3
    373                  {
    374                      i++;
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
    375                      if(i >= max_len)            //超过设定的最大值，退出
   \   00000028   0x42B7             CMP      R7,R6
   \   0000002A   0xD3F5             BCC.N    ??uart_querybuff_2
    376                      {
    377                          return i;
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0xE003             B.N      ??uart_querybuff_4
    378                      }
    379                  }
    380              }
   \                     ??uart_querybuff_3: (+1)
   \   00000030   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000034   0xE7EC             B.N      ??uart_querybuff_0
    381          
    382              return i;
   \                     ??uart_querybuff_1: (+1)
   \   00000036   0x0038             MOVS     R0,R7
   \                     ??uart_querybuff_4: (+1)
   \   00000038   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    383          }
    384          
    385          
    386          /*!
    387           *  @brief      串口发送一个字节
    388           *  @param      UARTn_e       模块号（UART0~UART5）
    389           *  @param      ch          需要发送的字节
    390           *  @since      v5.0
    391           *  @note       printf需要用到此函数
    392           *  @see        fputc
    393           *  Sample usage:       uart_putchar (UART3, 'A');  //发送字节'A'
    394           */

   \                                 In section .text, align 2, keep-with-next
    395          void uart_putchar (UARTn_e uratn, char ch)
    396          {
    397              //等待发送缓冲区空
    398              while(!(UART_S1_REG(UARTN[uratn]) & UART_S1_TDRE_MASK));
   \                     uart_putchar: (+1)
   \                     ??uart_putchar_0: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable13_4
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000008   0x7912             LDRB     R2,[R2, #+4]
   \   0000000A   0x0612             LSLS     R2,R2,#+24
   \   0000000C   0xD5F8             BPL.N    ??uart_putchar_0
    399          
    400              //发送数据
    401              UART_D_REG(UARTN[uratn]) = (uint8)ch;
   \   0000000E   0x....             LDR.N    R2,??DataTable13_4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000016   0x71D1             STRB     R1,[R2, #+7]
    402          }
   \   00000018   0x4770             BX       LR               ;; return
    403          
    404          /*!
    405           *  @brief      查询是否接受到一个字节
    406           *  @param      UARTn_e       模块号（UART0~UART5）
    407           *  @return     接收到数据返回1，没接收到数据返回0
    408           *  @since      v5.0
    409           *  Sample usage:       char ch;
    410                                  if(uart_query (UART3) == 1)     //查询是否接收到数据
    411                                  {
    412                                      ch = uart_getchar (UART3);  //等待接收一个数据，保存到 ch里
    413                                  }
    414           */

   \                                 In section .text, align 2, keep-with-next
    415          char uart_query (UARTn_e uratn)
    416          {
   \                     uart_query: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    417              if(UART_RCFIFO_REG(UARTN[uratn]))                 //接收到数据数量非0
   \   00000002   0x....             LDR.N    R0,??DataTable13_4
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000000A   0x7D80             LDRB     R0,[R0, #+22]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??uart_query_0
    418                  //if(!(UART_SFIFO_REG(UARTN[uratn]) & UART_SFIFO_RXEMPT_MASK))
    419                  //if(UART_S1_REG(UARTN[uratn]) & UART_S1_TDRE_MASK)
    420              {
    421                  return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??uart_query_1
    422              }
    423              else
    424              {
    425                  return 0;
   \                     ??uart_query_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??uart_query_1: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    426              }
    427              //return UART_RCFIFO_REG(UARTN[uratn]);
    428          }
    429          
    430          /*!
    431           *  @brief      发送指定len个字节长度数组 （包括 NULL 也会发送）
    432           *  @param      UARTn_e       模块号（UART0~UART5）
    433           *  @param      buff        数组地址
    434           *  @param      len         发送数组的长度
    435           *  @since      v5.0
    436           *  Sample usage:       uart_putbuff (UART3,"1234567", 3); //实际发送了3个字节'1','2','3'
    437           */

   \                                 In section .text, align 2, keep-with-next
    438          void uart_putbuff (UARTn_e uratn, uint8 *buff, uint32 len)
    439          {
   \                     uart_putbuff: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    440              while(len--)
   \                     ??uart_putbuff_0: (+1)
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x1E46             SUBS     R6,R0,#+1
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD006             BEQ.N    ??uart_putbuff_1
    441              {
    442                  uart_putchar(uratn, *buff);
   \   00000010   0x7829             LDRB     R1,[R5, #+0]
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       uart_putchar
    443                  buff++;
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \   0000001C   0xE7F4             B.N      ??uart_putbuff_0
    444              }
    445          }
   \                     ??uart_putbuff_1: (+1)
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    446          
    447          
    448          /*!
    449           *  @brief      发送字符串(遇 NULL 停止发送)
    450           *  @param      UARTn_e       模块号（UART0~UART5）
    451           *  @param      str         字符串地址
    452           *  @since      v5.0
    453           *  Sample usage:       uart_putstr (UART3,"1234567"); //实际发送了7个字节
    454           */

   \                                 In section .text, align 2, keep-with-next
    455          void uart_putstr (UARTn_e uratn, const uint8 *str)
    456          {
   \                     uart_putstr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    457              while(*str)
   \                     ??uart_putstr_0: (+1)
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??uart_putstr_1
    458              {
    459                  uart_putchar(uratn, *str++);
   \   0000000C   0x7829             LDRB     R1,[R5, #+0]
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       uart_putchar
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0xE7F5             B.N      ??uart_putstr_0
    460              }
    461          }
   \                     ??uart_putstr_1: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    462          
    463          /*!
    464           *  @brief      开串口接收中断
    465           *  @param      UARTn_e       模块号（UART0~UART5）
    466           *  @since      v5.0
    467           *  Sample usage:       uart_rx_irq_en(UART3);         //开串口3接收中断
    468           */

   \                                 In section .text, align 2, keep-with-next
    469          void uart_rx_irq_en(UARTn_e uratn)
    470          {
   \                     uart_rx_irq_en: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    471              UART_C2_REG(UARTN[uratn]) |= UART_C2_RIE_MASK;                          //使能UART接收中断
   \   00000004   0x....             LDR.N    R0,??DataTable13_4
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000012   0x....             LDR.N    R1,??DataTable13_4
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    472              enable_irq((IRQn_t)((uratn << 1) + UART0_RX_TX_IRQn));                  //使能IRQ中断
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0060             LSLS     R0,R4,#+1
   \   00000020   0x302D             ADDS     R0,R0,#+45
   \   00000022   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       NVIC_EnableIRQ
    473          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    474          
    475          /*!
    476           *  @brief      开串口发送中断
    477           *  @param      UARTn_e       模块号（UART0~UART5）
    478           *  @since      v5.0
    479           *  Sample usage:       uart_tx_irq_en(UART3);         //开串口3发送中断
    480           */

   \                                 In section .text, align 2, keep-with-next
    481          void uart_tx_irq_en(UARTn_e uratn)
    482          {
   \                     uart_tx_irq_en: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    483              UART_C2_REG(UARTN[uratn]) |= UART_C2_TIE_MASK;                          //使能UART发送中断
   \   00000004   0x....             LDR.N    R0,??DataTable13_4
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000012   0x....             LDR.N    R1,??DataTable13_4
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    484              enable_irq((IRQn_t)((uratn << 1) + UART0_RX_TX_IRQn));                  //使能IRQ中断
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0060             LSLS     R0,R4,#+1
   \   00000020   0x302D             ADDS     R0,R0,#+45
   \   00000022   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       NVIC_EnableIRQ
    485          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    486          
    487          /*!
    488           *  @brief      开串口发送完成中断
    489           *  @param      UARTn_e       模块号（UART0~UART5）
    490           *  @since      v5.0
    491           *  Sample usage:       uart_tx_irq_en(UART3);         //开串口3发送中断
    492           */

   \                                 In section .text, align 2, keep-with-next
    493          void uart_txc_irq_en(UARTn_e uratn)
    494          {
   \                     uart_txc_irq_en: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    495              UART_C2_REG(UARTN[uratn]) |= UART_C2_TCIE_MASK;                         //使能UART发送中断
   \   00000004   0x....             LDR.N    R0,??DataTable13_4
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000012   0x....             LDR.N    R1,??DataTable13_4
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    496              enable_irq((IRQn_t)((uratn << 1) + UART0_RX_TX_IRQn));                  //使能IRQ中断
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0060             LSLS     R0,R4,#+1
   \   00000020   0x302D             ADDS     R0,R0,#+45
   \   00000022   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       NVIC_EnableIRQ
    497          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    498          
    499          /*!
    500           *  @brief      关串口接收中断
    501           *  @param      UARTn_e       模块号（UART0~UART5）
    502           *  @since      v5.0
    503           *  Sample usage:       uart_rx_irq_dis(UART3);         //关串口3接收中断
    504           */

   \                                 In section .text, align 2, keep-with-next
    505          void uart_rx_irq_dis(UARTn_e uratn)
    506          {
   \                     uart_rx_irq_dis: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    507              UART_C2_REG(UARTN[uratn]) &= ~UART_C2_RIE_MASK;                         //禁止UART接收中断
   \   00000004   0x....             LDR.N    R0,??DataTable13_4
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000012   0x....             LDR.N    R1,??DataTable13_4
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    508          
    509              //如果发送中断还没有关，则不关闭IRQ
    510              if(!(UART_C2_REG(UARTN[uratn]) & (UART_C2_TIE_MASK | UART_C2_TCIE_MASK)) )
   \   0000001C   0x....             LDR.N    R0,??DataTable13_4
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000024   0x78C0             LDRB     R0,[R0, #+3]
   \   00000026   0x21C0             MOVS     R1,#+192
   \   00000028   0x4208             TST      R0,R1
   \   0000002A   0xD105             BNE.N    ??uart_rx_irq_dis_0
    511              {
    512                  disable_irq((IRQn_t)((uratn << 1) + UART0_RX_TX_IRQn));             //关IRQ中断
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x0060             LSLS     R0,R4,#+1
   \   00000030   0x302D             ADDS     R0,R0,#+45
   \   00000032   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       NVIC_DisableIRQ
    513              }
    514          }
   \                     ??uart_rx_irq_dis_0: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    515          
    516          /*!
    517           *  @brief      关串口发送中断
    518           *  @param      UARTn_e       模块号（UART0~UART5）
    519           *  @since      v5.0
    520           *  Sample usage:       uart_tx_irq_dis(UART3);         //关串口3发送中断
    521           */

   \                                 In section .text, align 2, keep-with-next
    522          void uart_txc_irq_dis(UARTn_e uratn)
    523          {
   \                     uart_txc_irq_dis: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    524              UART_C2_REG(UARTN[uratn]) &= ~UART_C2_TCIE_MASK;                        //禁止UART发送完成中断
   \   00000004   0x....             LDR.N    R0,??DataTable13_4
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000012   0x....             LDR.N    R1,??DataTable13_4
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    525          
    526              //如果接收中断还没有关，则不关闭IRQ
    527              if(!(UART_C2_REG(UARTN[uratn]) & UART_C2_RIE_MASK) )
   \   0000001C   0x....             LDR.N    R0,??DataTable13_4
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000024   0x78C0             LDRB     R0,[R0, #+3]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD405             BMI.N    ??uart_txc_irq_dis_0
    528              {
    529                  disable_irq((IRQn_t)((uratn << 1) + UART0_RX_TX_IRQn));             //关IRQ中断
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x0060             LSLS     R0,R4,#+1
   \   0000002E   0x302D             ADDS     R0,R0,#+45
   \   00000030   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       NVIC_DisableIRQ
    530              }
    531          }
   \                     ??uart_txc_irq_dis_0: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    532          
    533          /*!
    534           *  @brief      关串口发送中断
    535           *  @param      UARTn_e       模块号（UART0~UART5）
    536           *  @since      v5.0
    537           *  Sample usage:       uart_tx_irq_dis(UART3);         //关串口3发送中断
    538           */

   \                                 In section .text, align 2, keep-with-next
    539          void uart_tx_irq_dis(UARTn_e uratn)
    540          {
   \                     uart_tx_irq_dis: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    541              UART_C2_REG(UARTN[uratn]) &= ~UART_C2_TIE_MASK;                         //禁止UART发送中断
   \   00000004   0x....             LDR.N    R0,??DataTable13_4
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000000E   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000012   0x....             LDR.N    R1,??DataTable13_4
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001A   0x70C8             STRB     R0,[R1, #+3]
    542          
    543              //如果接收中断还没有关，则不关闭IRQ
    544              if(!(UART_C2_REG(UARTN[uratn]) & UART_C2_RIE_MASK) )
   \   0000001C   0x....             LDR.N    R0,??DataTable13_4
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000024   0x78C0             LDRB     R0,[R0, #+3]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD405             BMI.N    ??uart_tx_irq_dis_0
    545              {
    546                  disable_irq((IRQn_t)((uratn << 1) + UART0_RX_TX_IRQn));             //关IRQ中断
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x0060             LSLS     R0,R4,#+1
   \   0000002E   0x302D             ADDS     R0,R0,#+45
   \   00000030   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       NVIC_DisableIRQ
    547              }
    548          }
   \                     ??uart_tx_irq_dis_0: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    549          
    550          /*!
    551           *  @brief      UART3测试中断服务函数
    552           *  @since      v5.0
    553           *  @warning    此函数需要用户根据自己需求完成，这里仅仅是提供一个模版
    554           *  Sample usage:       set_vector_handler(UART3_RX_TX_VECTORn , uart3_test_handler);    //把 uart3_handler 函数添加到中断向量表，不需要我们手动调用
    555           */

   \                                 In section .text, align 2, keep-with-next
    556          void uart3_test_handler(void)
    557          {
    558              UARTn_e uratn = UART3;
   \                     uart3_test_handler: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
    559          
    560              if(UART_S1_REG(UARTN[uratn]) & UART_S1_RDRF_MASK)   //接收数据寄存器满
   \   00000002   0x....             LDR.N    R1,??DataTable13_4
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000000A   0x7909             LDRB     R1,[R1, #+4]
    561              {
    562                  //用户需要处理接收数据
    563          
    564              }
    565          
    566              if(UART_S1_REG(UARTN[uratn]) & UART_S1_TDRE_MASK )  //发送数据寄存器空
   \   0000000C   0x....             LDR.N    R1,??DataTable13_4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000014   0x7909             LDRB     R1,[R1, #+4]
    567              {
    568                  //用户需要处理发送数据
    569          
    570              }
    571          }
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     UARTN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 53H, 74H, 75H, 64H, 79H
   \              0x5C 0x53    
   \              0x74 0x75    
   \              0x64 0x79    
   \   00000008   0x5C 0x32          DC8 5CH, 32H, 30H, 31H, 36H, 0B5H, 0E7H, 0D7H
   \              0x30 0x31    
   \              0x36 0xB5    
   \              0xE7 0xD7    
   \   00000010   0xD3 0xC9          DC8 0D3H, 0C9H, 0E8H, 0BCH, 0C6H, 0B4H, 0F3H, 0C8H
   \              0xE8 0xBC    
   \              0xC6 0xB4    
   \              0xF3 0xC8    
   \   00000018   0xFC 0x5C          DC8 0FCH, 5CH, 54H, 69H, 5CH, 0B5H, 0E7H, 0C8H
   \              0x54 0x69    
   \              0x5C 0xB5    
   \              0xE7 0xC8    
   \   00000020   0xFC 0xB1          DC8 0FCH, 0B1H, 0B8H, 0D3H, 0C3H, 0B5H, 0D7H, 0B2H
   \              0xB8 0xD3    
   \              0xC3 0xB5    
   \              0xD7 0xB2    
   \   00000028   0xE3 0x5C          DC8 0E3H, 5CH, 43H, 68H, 69H, 70H, 5CH, 73H
   \              0x43 0x68    
   \              0x69 0x70    
   \              0x5C 0x73    
   \   00000030   0x72 0x63          DC8 72H, 63H, 5CH, 4DH, 4BH, 36H, 30H, 5FH
   \              0x5C 0x4D    
   \              0x4B 0x36    
   \              0x30 0x5F    
   \   00000038   0x75 0x61          DC8 75H, 61H, 72H, 74H, 2EH, 63H, 0
   \              0x72 0x74    
   \              0x2E 0x63    
   \              0x00         
   \   0000003F   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       0   uart3_test_handler
       0   uart_getchar
      32   uart_init
        32   -> assert_failed
        32   -> port_init
      16   uart_putbuff
        16   -> uart_putchar
       0   uart_putchar
      16   uart_putstr
        16   -> uart_putchar
       0   uart_query
      24   uart_querybuff
        24   -> uart_querychar
       0   uart_querychar
      24   uart_querystr
        24   -> uart_querychar
       8   uart_rx_irq_dis
         8   -> NVIC_DisableIRQ
       8   uart_rx_irq_en
         8   -> NVIC_EnableIRQ
       8   uart_tx_irq_dis
         8   -> NVIC_DisableIRQ
       8   uart_tx_irq_en
         8   -> NVIC_EnableIRQ
       8   uart_txc_irq_dis
         8   -> NVIC_DisableIRQ
       8   uart_txc_irq_en
         8   -> NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
      64  ?_0
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      24  UARTN
      24  uart3_test_handler
      28  uart_getchar
     530  uart_init
      32  uart_putbuff
      26  uart_putchar
      28  uart_putstr
      24  uart_query
      60  uart_querybuff
      40  uart_querychar
      92  uart_querystr
      58  uart_rx_irq_dis
      42  uart_rx_irq_en
      56  uart_tx_irq_dis
      42  uart_tx_irq_en
      56  uart_txc_irq_dis
      42  uart_txc_irq_en

 
    24 bytes in section .data
    64 bytes in section .rodata
 1 256 bytes in section .text
 
 1 256 bytes of CODE  memory
    64 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
