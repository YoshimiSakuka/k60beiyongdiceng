###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_spi.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_spi.c -D DEBUG
#        -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\MK60_spi.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\MK60_spi.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_spi.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       MK60_spi.c
     11           * @brief      SPI驱动函数
     12           * @author     山外科技
     13           * @version    v5.0
     14           * @date       2013-07-16
     15           */
     16          
     17          #include "common.h"
     18          #include "MK60_port.h"
     19          #include "MK60_spi.h"
     20          
     21          

   \                                 In section .data, align 4
     22          SPI_MemMapPtr SPIN[3] = {SPI0_BASE_PTR, SPI1_BASE_PTR, SPI2_BASE_PTR}; //定义三个指针数组保存 SPIx 的地址
   \                     SPIN:
   \   00000000   0x4002C000         DC32 4002C000H, 4002D000H, 400AC000H
   \              0x4002D000   
   \              0x400AC000   
     23          
     24          
     25          
     26          #define SPI_TX_WAIT(SPIn)     while(  ( SPI_SR_REG(SPIN[SPIn]) & SPI_SR_TXRXS_MASK ) == 1 ) //等待发送 完成
     27          #define SPI_RX_WAIT(SPIn)     while(  ( SPI_SR_REG(SPIN[SPIn]) & SPI_SR_RFDF_MASK ) == 0 )  //等待发送 FIFO为非空
     28          #define SPI_EOQF_WAIT(SPIn)   while(  (SPI_SR_REG(SPIN[SPIn]) & SPI_SR_EOQF_MASK ) == 0 )   //等待传输完成
     29          
     30          
     31          /*!
     32           *  @brief      SPI初始化，设置模式
     33           *  @param      SPIn_e          SPI模块(SPI0、SPI1、SPI2)
     34           *  @param      SPIn_PCSn_e     片选管脚编号
     35           *  @param      SPI_CFG         SPI主从机模式选择
     36           *  @since      v5.0
     37           *  Sample usage:       uint32 baud = spi_init(SPI0,SPIn_PCS0, MASTER,10*1000*1000);              //初始化SPI,选择CS0,主机模式, 波特率为1M ,返回真实波特率到baud变量
     38           */

   \                                 In section .text, align 2, keep-with-next
     39          uint32 spi_init(SPIn_e spin, SPI_PCSn_e pcs, SPI_CFG master,uint32 baud)
     40          {
   \                     spi_init: (+1)
   \   00000000   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \   00000004   0xB097             SUB      SP,SP,#+92
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
     41              uint8  br,pbr;
     42              uint32 clk = bus_clk_khz*1000/baud;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable2
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF44F 0x717A      MOV      R1,#+1000
   \   00000014   0x4348             MULS     R0,R1,R0
   \   00000016   0x9918             LDR      R1,[SP, #+96]
   \   00000018   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000001C   0x9001             STR      R0,[SP, #+4]
     43              uint32 Scaler[] = {2,4,6,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};
   \   0000001E   0xA806             ADD      R0,SP,#+24
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable2_1
   \   00000024   0x2240             MOVS     R2,#+64
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
     44              uint8  Prescaler[] = {2,3,5,7};
   \   0000002A   0xA805             ADD      R0,SP,#+20
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable2_2
   \   00000030   0x680A             LDR      R2,[R1, #0]
   \   00000032   0x6002             STR      R2,[R0, #+0]
     45              uint32 fit_clk,fit_br=0,fit_pbr,min_diff =~0,diff;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9002             STR      R0,[SP, #+8]
   \   00000038   0xF05F 0x39FF      MOVS     R9,#-1
     46              uint32 tmp;
     47          
     48              //计算CS到第一个SCK的时间
     49              uint8 pcssck,cssck,fit_pcssck,fit_cssck;
     50          
     51              //使能SPI模块时钟，配置SPI引脚功能
     52              if(spin == SPI0)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD141             BNE.N    ??spi_init_0
     53              {
     54                  SIM_SCGC6 |= SIM_SCGC6_DSPI0_MASK;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable2_3  ;; 0x4004803c
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable2_3  ;; 0x4004803c
   \   00000050   0x6008             STR      R0,[R1, #+0]
     55          
     56                  //进行管脚复用
     57                  port_init(SPI0_SCK_PIN , ALT2  );
   \   00000052   0xF44F 0x7100      MOV      R1,#+512
   \   00000056   0x200F             MOVS     R0,#+15
   \   00000058   0x.... 0x....      BL       port_init
     58                  port_init(SPI0_SOUT_PIN, ALT2  );
   \   0000005C   0xF44F 0x7100      MOV      R1,#+512
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0x.... 0x....      BL       port_init
     59                  port_init(SPI0_SIN_PIN , ALT2  );
   \   00000066   0xF44F 0x7100      MOV      R1,#+512
   \   0000006A   0x2011             MOVS     R0,#+17
   \   0000006C   0x.... 0x....      BL       port_init
     60          
     61                  if(pcs & SPI_PCS0)
   \   00000070   0x07E8             LSLS     R0,R5,#+31
   \   00000072   0xD504             BPL.N    ??spi_init_1
     62                      port_init(SPI0_PCS0_PIN, ALT2  );
   \   00000074   0xF44F 0x7100      MOV      R1,#+512
   \   00000078   0x200E             MOVS     R0,#+14
   \   0000007A   0x.... 0x....      BL       port_init
     63          
     64                  if(pcs & SPI_PCS1)
   \                     ??spi_init_1: (+1)
   \   0000007E   0x07A8             LSLS     R0,R5,#+30
   \   00000080   0xD504             BPL.N    ??spi_init_2
     65                      port_init(SPI0_PCS1_PIN, ALT2  );
   \   00000082   0xF44F 0x7100      MOV      R1,#+512
   \   00000086   0x2043             MOVS     R0,#+67
   \   00000088   0x.... 0x....      BL       port_init
     66          
     67                  if(pcs & SPI_PCS2)
   \                     ??spi_init_2: (+1)
   \   0000008C   0x0768             LSLS     R0,R5,#+29
   \   0000008E   0xD504             BPL.N    ??spi_init_3
     68                      port_init(SPI0_PCS2_PIN, ALT2  );
   \   00000090   0xF44F 0x7100      MOV      R1,#+512
   \   00000094   0x2042             MOVS     R0,#+66
   \   00000096   0x.... 0x....      BL       port_init
     69          
     70                  if(pcs & SPI_PCS3)
   \                     ??spi_init_3: (+1)
   \   0000009A   0x0728             LSLS     R0,R5,#+28
   \   0000009C   0xD504             BPL.N    ??spi_init_4
     71                      port_init(SPI0_PCS3_PIN, ALT2  );
   \   0000009E   0xF44F 0x7100      MOV      R1,#+512
   \   000000A2   0x2041             MOVS     R0,#+65
   \   000000A4   0x.... 0x....      BL       port_init
     72          
     73                  if(pcs & SPI_PCS4)
   \                     ??spi_init_4: (+1)
   \   000000A8   0x06E8             LSLS     R0,R5,#+27
   \   000000AA   0xD504             BPL.N    ??spi_init_5
     74                      port_init(SPI0_PCS4_PIN, ALT2  );
   \   000000AC   0xF44F 0x7100      MOV      R1,#+512
   \   000000B0   0x2040             MOVS     R0,#+64
   \   000000B2   0x.... 0x....      BL       port_init
     75          
     76                  if(pcs & SPI_PCS5)
   \                     ??spi_init_5: (+1)
   \   000000B6   0x06A8             LSLS     R0,R5,#+26
   \   000000B8   0xD56A             BPL.N    ??spi_init_6
     77                      port_init(SPI0_PCS5_PIN, ALT3  );
   \   000000BA   0xF44F 0x7140      MOV      R1,#+768
   \   000000BE   0x2037             MOVS     R0,#+55
   \   000000C0   0x.... 0x....      BL       port_init
   \   000000C4   0xE064             B.N      ??spi_init_6
     78              }
     79              else if(spin == SPI1)
   \                     ??spi_init_0: (+1)
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0x2C01             CMP      R4,#+1
   \   000000CA   0xD133             BNE.N    ??spi_init_7
     80              {
     81          #if defined(MK60DZ10)
     82                  SIM_SCGC6 |= SIM_SCGC6_SPI1_MASK;
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable2_3  ;; 0x4004803c
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable2_3  ;; 0x4004803c
   \   000000DA   0x6008             STR      R0,[R1, #+0]
     83          #elif defined(MK60F15)
     84                  SIM_SCGC6 |= SIM_SCGC6_DSPI1_MASK;
     85          #endif
     86                  port_init(SPI1_SCK_PIN , ALT2  );
   \   000000DC   0xF44F 0x7100      MOV      R1,#+512
   \   000000E0   0x2082             MOVS     R0,#+130
   \   000000E2   0x.... 0x....      BL       port_init
     87                  port_init(SPI1_SOUT_PIN, ALT2  );
   \   000000E6   0xF44F 0x7100      MOV      R1,#+512
   \   000000EA   0x2081             MOVS     R0,#+129
   \   000000EC   0x.... 0x....      BL       port_init
     88                  port_init(SPI1_SIN_PIN , ALT2  );
   \   000000F0   0xF44F 0x7100      MOV      R1,#+512
   \   000000F4   0x2083             MOVS     R0,#+131
   \   000000F6   0x.... 0x....      BL       port_init
     89          
     90                  if(pcs & SPI_PCS0)
   \   000000FA   0x07E8             LSLS     R0,R5,#+31
   \   000000FC   0xD504             BPL.N    ??spi_init_8
     91                      port_init(SPI1_PCS0_PIN, ALT2  );
   \   000000FE   0xF44F 0x7100      MOV      R1,#+512
   \   00000102   0x2084             MOVS     R0,#+132
   \   00000104   0x.... 0x....      BL       port_init
     92          
     93                  if(pcs & SPI_PCS1)
   \                     ??spi_init_8: (+1)
   \   00000108   0x07A8             LSLS     R0,R5,#+30
   \   0000010A   0xD504             BPL.N    ??spi_init_9
     94                      port_init(SPI1_PCS1_PIN, ALT2  );
   \   0000010C   0xF44F 0x7100      MOV      R1,#+512
   \   00000110   0x2080             MOVS     R0,#+128
   \   00000112   0x.... 0x....      BL       port_init
     95          
     96                  if(pcs & SPI_PCS2)
   \                     ??spi_init_9: (+1)
   \   00000116   0x0768             LSLS     R0,R5,#+29
   \   00000118   0xD504             BPL.N    ??spi_init_10
     97                      port_init(SPI1_PCS2_PIN, ALT2  );
   \   0000011A   0xF44F 0x7100      MOV      R1,#+512
   \   0000011E   0x2085             MOVS     R0,#+133
   \   00000120   0x.... 0x....      BL       port_init
     98          
     99                  if(pcs & SPI_PCS3)
   \                     ??spi_init_10: (+1)
   \   00000124   0x0728             LSLS     R0,R5,#+28
   \   00000126   0xD533             BPL.N    ??spi_init_6
    100                      port_init(SPI1_PCS3_PIN, ALT2  );
   \   00000128   0xF44F 0x7100      MOV      R1,#+512
   \   0000012C   0x2086             MOVS     R0,#+134
   \   0000012E   0x.... 0x....      BL       port_init
   \   00000132   0xE02D             B.N      ??spi_init_6
    101              }
    102              else if(spin == SPI2)
   \                     ??spi_init_7: (+1)
   \   00000134   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000136   0x2C02             CMP      R4,#+2
   \   00000138   0xD125             BNE.N    ??spi_init_11
    103              {
    104          #if defined(MK60DZ10)
    105                  SIM_SCGC3 |= SIM_SCGC3_SPI2_MASK;
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable2_4  ;; 0x40048030
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable2_4  ;; 0x40048030
   \   00000148   0x6008             STR      R0,[R1, #+0]
    106          #elif defined(MK60F15)
    107                  SIM_SCGC3 |= SIM_SCGC3_DSPI2_MASK;
    108          #endif
    109          
    110                  port_init(SPI2_SCK_PIN , ALT2  );
   \   0000014A   0xF44F 0x7100      MOV      R1,#+512
   \   0000014E   0x2035             MOVS     R0,#+53
   \   00000150   0x.... 0x....      BL       port_init
    111                  port_init(SPI2_SOUT_PIN, ALT2  );
   \   00000154   0xF44F 0x7100      MOV      R1,#+512
   \   00000158   0x2036             MOVS     R0,#+54
   \   0000015A   0x.... 0x....      BL       port_init
    112                  port_init(SPI2_SIN_PIN , ALT2  );
   \   0000015E   0xF44F 0x7100      MOV      R1,#+512
   \   00000162   0x2037             MOVS     R0,#+55
   \   00000164   0x.... 0x....      BL       port_init
    113          
    114                  if(pcs & SPI_PCS0)
   \   00000168   0x07E8             LSLS     R0,R5,#+31
   \   0000016A   0xD504             BPL.N    ??spi_init_12
    115                      port_init(SPI2_PCS0_PIN, ALT2  );
   \   0000016C   0xF44F 0x7100      MOV      R1,#+512
   \   00000170   0x2034             MOVS     R0,#+52
   \   00000172   0x.... 0x....      BL       port_init
    116          
    117                  if(pcs & SPI_PCS1)
   \                     ??spi_init_12: (+1)
   \   00000176   0x07A8             LSLS     R0,R5,#+30
   \   00000178   0xD50A             BPL.N    ??spi_init_6
    118                      port_init(SPI2_PCS1_PIN, ALT2  );
   \   0000017A   0xF44F 0x7100      MOV      R1,#+512
   \   0000017E   0x206F             MOVS     R0,#+111
   \   00000180   0x.... 0x....      BL       port_init
   \   00000184   0xE004             B.N      ??spi_init_6
    119              }
    120              else
    121              {
    122                  //传递进来的 spi 模块有误，直接判断断言失败
    123                  ASSERT(0);
   \                     ??spi_init_11: (+1)
   \   00000186   0x217B             MOVS     R1,#+123
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable2_5
   \   0000018C   0x.... 0x....      BL       assert_failed
    124              }
    125          
    126              SPI_MCR_REG(SPIN[spin]) = ( 0
    127                                          | SPI_MCR_CLR_TXF_MASK     //清空 Tx FIFO 计数器
    128                                          | SPI_MCR_CLR_RXF_MASK     //清空 Rx FIFO 计数器
    129                                          | SPI_MCR_HALT_MASK        //停止SPI传输
    130                                        );
   \                     ??spi_init_6: (+1)
   \   00000190   0xF640 0x4001      MOVW     R0,#+3073
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable2_6
   \   00000198   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000019E   0x6008             STR      R0,[R1, #+0]
    131          
    132              /*************  清标志位  ***************/
    133              SPI_SR_REG(SPIN[spin]) = (0
    134                                        | SPI_SR_EOQF_MASK    //发送队列空了，发送完毕
    135                                        | SPI_SR_TFUF_MASK    //传输FIFO下溢标志位，SPI为从机模式，Tx FIFO为空，而外部SPI主机模式启动传输，标志位就会置1，写1清0
    136                                        | SPI_SR_TFFF_MASK    //传输FIFO满标志位。 写1或者DMA控制器发现传输FIFO满了就会清0。 0表示Tx FIFO满了
    137                                        | SPI_SR_RFOF_MASK    //接收FIFO溢出标志位。
    138                                        | SPI_SR_RFDF_MASK    //接收FIFO损耗标志位，写1或者DMA控制器发现传输FIFO空了就会清0。0表示Rx FIFO空
    139                                       );
   \   000001A0   0x.... 0x....      LDR.W    R0,??DataTable2_7  ;; 0x1a0a0000
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable2_6
   \   000001A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001AA   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000001AE   0x62C8             STR      R0,[R1, #+44]
    140          
    141          
    142              //根据主从机模式设置工作模式。MCU提供最大主机频率是1/2主频，最大从机频率是1/4主频
    143              if(master == MASTER)
   \   000001B0   0xF89D 0x005C      LDRB     R0,[SP, #+92]
   \   000001B4   0x2800             CMP      R0,#+0
   \   000001B6   0xF040 0x80A2      BNE.W    ??spi_init_13
    144              {
    145                  SPI_MCR_REG(SPIN[spin]) =  (0
    146                                              |  SPI_MCR_MSTR_MASK        //Master,主机模式
    147                                              |  SPI_MCR_PCSIS(pcs)
    148                                              |  SPI_MCR_PCSIS_MASK
    149                                             );
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable2_8  ;; 0x803f0000
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable2_6
   \   000001C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001C4   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000001C8   0x6008             STR      R0,[R1, #+0]
    150          
    151          
    152                  for(br = 0;br < 0x10;br++)
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x0006             MOVS     R6,R0
   \                     ??spi_init_14: (+1)
   \   000001CE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001D0   0x2E10             CMP      R6,#+16
   \   000001D2   0xDA21             BGE.N    ??spi_init_15
    153                  {
    154                      for(pbr = 0;pbr < 4;pbr++)
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0x0007             MOVS     R7,R0
   \                     ??spi_init_16: (+1)
   \   000001D8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001DA   0x2F04             CMP      R7,#+4
   \   000001DC   0xDA1A             BGE.N    ??spi_init_17
    155                      {
    156                          tmp = Scaler[br] * Prescaler[pbr];
   \   000001DE   0xA806             ADD      R0,SP,#+24
   \   000001E0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001E2   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   000001E6   0xA905             ADD      R1,SP,#+20
   \   000001E8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001EA   0x5C79             LDRB     R1,[R7, R1]
   \   000001EC   0x4348             MULS     R0,R1,R0
   \   000001EE   0x4682             MOV      R10,R0
    157                          diff = abs(tmp - clk);
   \   000001F0   0x9801             LDR      R0,[SP, #+4]
   \   000001F2   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   000001F6   0x.... 0x....      BL       abs
   \   000001FA   0x4680             MOV      R8,R0
    158                          if(min_diff > diff)
   \   000001FC   0x45C8             CMP      R8,R9
   \   000001FE   0xD207             BCS.N    ??spi_init_18
    159                          {
    160                              //记住 最佳配置
    161                              min_diff = diff;
   \   00000200   0x46C1             MOV      R9,R8
    162                              fit_br = br;
   \   00000202   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000204   0x9602             STR      R6,[SP, #+8]
    163                              fit_pbr = pbr;
   \   00000206   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000208   0x9703             STR      R7,[SP, #+12]
    164             
    165                              if(min_diff == 0)
   \   0000020A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000020E   0xD003             BEQ.N    ??spi_init_15
    166                              {
    167                                  //刚好匹配
    168          
    169                                  goto SPI_CLK_EXIT;
    170                              }
    171          
    172                          }
    173          
    174                      }
   \                     ??spi_init_18: (+1)
   \   00000210   0x1C7F             ADDS     R7,R7,#+1
   \   00000212   0xE7E1             B.N      ??spi_init_16
    175                  }
   \                     ??spi_init_17: (+1)
   \   00000214   0x1C76             ADDS     R6,R6,#+1
   \   00000216   0xE7DA             B.N      ??spi_init_14
    176          
    177          SPI_CLK_EXIT:
    178                  fit_clk =  bus_clk_khz *1000 /(Scaler[fit_br] * Prescaler[fit_pbr]);
   \                     ??spi_init_15: (+1)
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable2
   \   0000021C   0x6800             LDR      R0,[R0, #+0]
   \   0000021E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000222   0x4348             MULS     R0,R1,R0
   \   00000224   0xA906             ADD      R1,SP,#+24
   \   00000226   0x9A02             LDR      R2,[SP, #+8]
   \   00000228   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   0000022C   0xAA05             ADD      R2,SP,#+20
   \   0000022E   0x9B03             LDR      R3,[SP, #+12]
   \   00000230   0x5C9A             LDRB     R2,[R3, R2]
   \   00000232   0x4351             MULS     R1,R2,R1
   \   00000234   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000238   0x9004             STR      R0,[SP, #+16]
    179          
    180                  //需要算一下 CS 到 CLK 的时间（波特率的半周期）,满足条件： (1<<(CSSCK + 1 ))*( 2*PCSSCK+1) = fclk /(2*  baud)
    181                  clk =  bus_clk_khz*1000/fit_clk/2;
   \   0000023A   0x.... 0x....      LDR.W    R0,??DataTable2
   \   0000023E   0x6800             LDR      R0,[R0, #+0]
   \   00000240   0xF44F 0x717A      MOV      R1,#+1000
   \   00000244   0x4348             MULS     R0,R1,R0
   \   00000246   0x9904             LDR      R1,[SP, #+16]
   \   00000248   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000024C   0x0840             LSRS     R0,R0,#+1
   \   0000024E   0x9001             STR      R0,[SP, #+4]
    182                  min_diff = ~0;
   \   00000250   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000254   0x4681             MOV      R9,R0
    183                  fit_cssck = 0x0F;
   \   00000256   0x200F             MOVS     R0,#+15
   \   00000258   0xF88D 0x0001      STRB     R0,[SP, #+1]
    184                  fit_pcssck = 3;
   \   0000025C   0x2003             MOVS     R0,#+3
   \   0000025E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    185                  for(cssck = 0;cssck<=0x0F;cssck++)
   \   00000262   0x2000             MOVS     R0,#+0
   \   00000264   0x4683             MOV      R11,R0
   \                     ??spi_init_19: (+1)
   \   00000266   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000026A   0xF1BB 0x0F10      CMP      R11,#+16
   \   0000026E   0xDA2A             BGE.N    ??spi_init_20
    186                  {
    187                      tmp = 1<<(cssck+1) ;
   \   00000270   0x2001             MOVS     R0,#+1
   \   00000272   0xF11B 0x0101      ADDS     R1,R11,#+1
   \   00000276   0x4088             LSLS     R0,R0,R1
   \   00000278   0x4682             MOV      R10,R0
    188                      pcssck = (clk/tmp-1)/2;
   \   0000027A   0x9801             LDR      R0,[SP, #+4]
   \   0000027C   0xFBB0 0xF0FA      UDIV     R0,R0,R10
   \   00000280   0x1E40             SUBS     R0,R0,#+1
   \   00000282   0x0840             LSRS     R0,R0,#+1
   \   00000284   0xF88D 0x0000      STRB     R0,[SP, #+0]
    189                      if(pcssck>3)continue;       //不能超过 3
   \   00000288   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000028C   0x2804             CMP      R0,#+4
   \   0000028E   0xDA17             BGE.N    ??spi_init_21
    190                      tmp = tmp * (2*pcssck+1);
   \                     ??spi_init_22: (+1)
   \   00000290   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000294   0x0040             LSLS     R0,R0,#+1
   \   00000296   0x1C40             ADDS     R0,R0,#+1
   \   00000298   0xFB00 0xFA0A      MUL      R10,R0,R10
    191                      diff = abs(tmp-clk);
   \   0000029C   0x9801             LDR      R0,[SP, #+4]
   \   0000029E   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   000002A2   0x.... 0x....      BL       abs
   \   000002A6   0x4680             MOV      R8,R0
    192                      if(min_diff > diff)
   \   000002A8   0x45C8             CMP      R8,R9
   \   000002AA   0xD209             BCS.N    ??spi_init_21
    193                      {
    194                          //记住 最佳配置
    195                          min_diff = diff;
   \   000002AC   0x46C1             MOV      R9,R8
    196                          fit_cssck = cssck;
   \   000002AE   0xF88D 0xB001      STRB     R11,[SP, #+1]
    197                          fit_pcssck = pcssck;
   \   000002B2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000002B6   0xF88D 0x0002      STRB     R0,[SP, #+2]
    198          
    199                          if(min_diff == 0)
   \   000002BA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002BE   0xD002             BEQ.N    ??spi_init_20
    200                          {
    201                              //刚好匹配
    202                              goto SPI_CSSCK_EXIT;
    203                          }
    204                      }
    205                  }
   \                     ??spi_init_21: (+1)
   \   000002C0   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000002C4   0xE7CF             B.N      ??spi_init_19
    206          
    207          SPI_CSSCK_EXIT:
    208          
    209                  SPI_CTAR_REG(SPIN[spin], 0) = (0
    210                                                 //| SPI_CTAR_DBR_MASK    //双波特率 ，假设 DBR=1，CPHA=1，PBR=00，得SCK Duty Cycle 为 50/50
    211                                                 //| SPI_CTAR_CPHA_MASK   //数据在SCK上升沿改变（输出），在下降沿被捕捉（输入读取）。如果是0，则反之。  w25x16在上升沿读取数据；NRF24L01在上升沿读取数据
    212                                                 | SPI_CTAR_PBR(fit_pbr)        //波特率分频器 ，0~3 对应的分频值Prescaler为 2、3、5、7
    213          
    214                                                 | SPI_CTAR_PDT(0x00)     //延时因子为 PDT*2+1 ，这里PDT为3，即延时因子为7。PDT为2bit
    215                                                 | SPI_CTAR_BR(fit_br)         //波特率计数器值 ,当BR<=3,分频Scaler 为 2*（BR+1） ，当BR>=3，分频Scaler 为 2^BR  。BR为4bit
    216                                                 //SCK 波特率 = (Bus clk/Prescaler) x [(1+DBR)/Scaler ]          fSYS 为 Bus clock
    217                                                 //              50M / 2         x [ 1  /  2  ] = 25M   这里以最大的来算
    218          
    219                                                 //| SPI_CTAR_CPOL_MASK   //时钟极性，1表示 SCK 不活跃状态为高电平,   NRF24L01 不活跃为低电平
    220                                                 | SPI_CTAR_FMSZ(0x07)    //每帧传输 7bit+1 ，即8bit （FMSZ默认就是8）
    221                                                 // | SPI_CTAR_LSBFE_MASK //1为低位在前。
    222          
    223                                                 // 下面两个参数是调整 CS 信号来了到第一个CLK的时间
    224                                                 | SPI_CTAR_CSSCK(fit_cssck)    // x ：0~0x0F
    225                                                 | SPI_CTAR_PCSSCK(fit_pcssck)    //设置片选信号有效到时钟第一个边沿出现的延时的预分频值。tcsc延时预分频 2*x+1； x 0~3
    226                                                );
   \                     ??spi_init_20: (+1)
   \   000002C6   0x9803             LDR      R0,[SP, #+12]
   \   000002C8   0x0400             LSLS     R0,R0,#+16
   \   000002CA   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   000002CE   0x9902             LDR      R1,[SP, #+8]
   \   000002D0   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   000002D4   0x4308             ORRS     R0,R1,R0
   \   000002D6   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000002DA   0x0309             LSLS     R1,R1,#+12
   \   000002DC   0xF411 0x4170      ANDS     R1,R1,#0xF000
   \   000002E0   0x4308             ORRS     R0,R1,R0
   \   000002E2   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000002E6   0x0589             LSLS     R1,R1,#+22
   \   000002E8   0xF411 0x0140      ANDS     R1,R1,#0xC00000
   \   000002EC   0x4308             ORRS     R0,R1,R0
   \   000002EE   0xF050 0x5060      ORRS     R0,R0,#0x38000000
   \   000002F2   0x....             LDR.N    R1,??DataTable2_6
   \   000002F4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002F6   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000002FA   0x60C8             STR      R0,[R1, #+12]
   \   000002FC   0xE006             B.N      ??spi_init_23
    227              }
    228              else
    229              {
    230                  //默认从机模式
    231                  SPI_CTAR_SLAVE_REG(SPIN[spin], 0) = (0
    232                                                       | SPI_CTAR_SLAVE_FMSZ(0x07)
    233                                                       | SPI_CTAR_SLAVE_CPOL_MASK
    234                                                       | SPI_CTAR_SLAVE_CPHA_MASK
    235                                                      );
   \                     ??spi_init_13: (+1)
   \   000002FE   0xF05F 0x5078      MOVS     R0,#+1040187392
   \   00000302   0x....             LDR.N    R1,??DataTable2_6
   \   00000304   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000306   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000030A   0x60C8             STR      R0,[R1, #+12]
    236              }
    237          
    238          
    239              SPI_MCR_REG(SPIN[spin]) &= ~SPI_MCR_HALT_MASK;     //启动SPI传输。1为暂停，0为启动
   \                     ??spi_init_23: (+1)
   \   0000030C   0x....             LDR.N    R0,??DataTable2_6
   \   0000030E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000310   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000314   0x6800             LDR      R0,[R0, #+0]
   \   00000316   0x0840             LSRS     R0,R0,#+1
   \   00000318   0x0040             LSLS     R0,R0,#+1
   \   0000031A   0x....             LDR.N    R1,??DataTable2_6
   \   0000031C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000031E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000322   0x6008             STR      R0,[R1, #+0]
    240          
    241              return fit_clk;
   \   00000324   0x9804             LDR      R0,[SP, #+16]
   \   00000326   0xB019             ADD      SP,SP,#+100
   \   00000328   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    242          
    243          }
    244          
    245          /*!
    246           *  @brief      SPI发送接收函数
    247           *  @param      SPIn_e          SPI模块(SPI0、SPI1、SPI2)
    248           *  @param      SPIn_PCSn_e     片选管脚编号
    249           *  @param      modata          发送的数据缓冲区地址(不需要接收则传 NULL)
    250           *  @param      midata          发送数据时接收到的数据的存储地址(不需要接收则传 NULL)
    251           *  @since      v5.0
    252           *  Sample usage:           spi_mosi(SPI0,SPIn_PCS0,buff,buff,2);    //发送buff的内容，并接收到buff里，长度为2字节
    253           */

   \                                 In section .text, align 2, keep-with-next
    254          void spi_mosi(SPIn_e spin, SPI_PCSn_e pcs, uint8 *modata, uint8 *midata, uint32 len)
    255          {
   \                     spi_mosi: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
    256              uint32 i = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    257              do
    258              {
    259                  /*************  清标志位  ***************/
    260                  SPI_SR_REG(SPIN[spin]) = (0
    261                                            | SPI_SR_EOQF_MASK    //发送队列空了，发送完毕标志
    262                                            | SPI_SR_TFUF_MASK    //传输FIFO下溢标志位，SPI为从机模式，Tx FIFO为空，而外部SPI主机模式启动传输，标志位就会置1，写1清0
    263                                            | SPI_SR_TFFF_MASK    //传输FIFO满标志位。 写1或者DMA控制器发现传输FIFO满了就会清0。 0表示Tx FIFO满了
    264                                            | SPI_SR_RFOF_MASK    //接收FIFO溢出标志位。
    265                                            | SPI_SR_RFDF_MASK    //接收FIFO损耗标志位，写1或者DMA控制器发现传输FIFO空了就会清0。0表示Rx FIFO空
    266                                           );
   \                     ??spi_mosi_0: (+1)
   \   00000006   0x....             LDR.N    R6,??DataTable2_7  ;; 0x1a0a0000
   \   00000008   0x....             LDR.N    R7,??DataTable2_6
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   00000010   0x62FE             STR      R6,[R7, #+44]
    267          
    268          
    269                  /************** 清FIFO计数器 **************/
    270                  SPI_MCR_REG(SPIN[spin])    |=  (0
    271                                                  | SPI_MCR_CLR_TXF_MASK  //写1清 Tx FIFO 计数器
    272                                                  | SPI_MCR_CLR_RXF_MASK  //写1清 Rx FIFO 计数器
    273                                                 );
   \   00000012   0x....             LDR.N    R6,??DataTable2_6
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000001A   0x6836             LDR      R6,[R6, #+0]
   \   0000001C   0xF456 0x6640      ORRS     R6,R6,#0xC00
   \   00000020   0x....             LDR.N    R7,??DataTable2_6
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   00000028   0x603E             STR      R6,[R7, #+0]
    274          
    275              }
    276              while( (SPI_SR_REG(SPIN[spin]) & SPI_SR_RFDF_MASK));            //如果 Rx FIFO 非空，则清FIFO.
   \   0000002A   0x....             LDR.N    R6,??DataTable2_6
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   00000032   0x6AF6             LDR      R6,[R6, #+44]
   \   00000034   0x03B6             LSLS     R6,R6,#+14
   \   00000036   0xD4E6             BMI.N    ??spi_mosi_0
    277          
    278              /***************** 发送len-1个数据 *******************/                                                ;
    279              for(i = 0; i < (len - 1); i++)
   \   00000038   0x2600             MOVS     R6,#+0
   \   0000003A   0x0035             MOVS     R5,R6
   \                     ??spi_mosi_1: (+1)
   \   0000003C   0x1E66             SUBS     R6,R4,#+1
   \   0000003E   0x42B5             CMP      R5,R6
   \   00000040   0xD22F             BCS.N    ??spi_mosi_2
    280              {
    281                  SPI_PUSHR_REG(SPIN[spin]) = (0
    282                                               | SPI_PUSHR_CTAS(0)             //选择CTAR0寄存器
    283                                               | SPI_PUSHR_CONT_MASK           //1为 传输期间保持PCSn信号 ，即继续传输数据
    284                                               | SPI_PUSHR_PCS(pcs)
    285                                               | SPI_PUSHR_TXDATA(modata[i])     //要传输的数据
    286                                              );
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x040E             LSLS     R6,R1,#+16
   \   00000046   0xF416 0x167C      ANDS     R6,R6,#0x3F0000
   \   0000004A   0x5CAF             LDRB     R7,[R5, R2]
   \   0000004C   0x433E             ORRS     R6,R7,R6
   \   0000004E   0xF056 0x4600      ORRS     R6,R6,#0x80000000
   \   00000052   0x....             LDR.N    R7,??DataTable2_6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   0000005A   0x637E             STR      R6,[R7, #+52]
    287          
    288                  while(!(SPI_SR_REG(SPIN[spin]) & SPI_SR_RFDF_MASK));        //RFDF为1，Rx FIFO is not empty.
   \                     ??spi_mosi_3: (+1)
   \   0000005C   0x....             LDR.N    R6,??DataTable2_6
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   00000064   0x6AF6             LDR      R6,[R6, #+44]
   \   00000066   0x03B6             LSLS     R6,R6,#+14
   \   00000068   0xD5F8             BPL.N    ??spi_mosi_3
    289                  if(midata != NULL)
   \   0000006A   0x2B00             CMP      R3,#+0
   \   0000006C   0xD006             BEQ.N    ??spi_mosi_4
    290                  {
    291                      midata[i] = (uint8)SPI_POPR_REG(SPIN[spin]);                  //保存接收到的数据
   \   0000006E   0x....             LDR.N    R6,??DataTable2_6
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   00000076   0x6BB6             LDR      R6,[R6, #+56]
   \   00000078   0x54EE             STRB     R6,[R5, R3]
   \   0000007A   0xE004             B.N      ??spi_mosi_5
    292                  }
    293                  else
    294                  {
    295                      SPI_POPR_REG(SPIN[spin]);
   \                     ??spi_mosi_4: (+1)
   \   0000007C   0x....             LDR.N    R6,??DataTable2_6
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   00000084   0x6BB6             LDR      R6,[R6, #+56]
    296                  }
    297                  SPI_SR_REG(SPIN[spin]) |= SPI_SR_RFDF_MASK;
   \                     ??spi_mosi_5: (+1)
   \   00000086   0x....             LDR.N    R6,??DataTable2_6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000008E   0x6AF6             LDR      R6,[R6, #+44]
   \   00000090   0xF456 0x3600      ORRS     R6,R6,#0x20000
   \   00000094   0x....             LDR.N    R7,??DataTable2_6
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   0000009C   0x62FE             STR      R6,[R7, #+44]
    298              }
   \   0000009E   0x1C6D             ADDS     R5,R5,#+1
   \   000000A0   0xE7CC             B.N      ??spi_mosi_1
    299          
    300              /***************** 发送最后一个数据 *******************/
    301              SPI_PUSHR_REG(SPIN[spin]) = (0
    302                                           | SPI_PUSHR_CTAS(0)                 //选择CTAR0寄存器
    303                                           | SPI_PUSHR_PCS(pcs)
    304                                           | SPI_PUSHR_EOQ_MASK                //1为 传输SPI最后的数据
    305                                           | SPI_PUSHR_TXDATA(modata[i])
    306                                          );
   \                     ??spi_mosi_2: (+1)
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0x040E             LSLS     R6,R1,#+16
   \   000000A6   0xF416 0x167C      ANDS     R6,R6,#0x3F0000
   \   000000AA   0x5CAF             LDRB     R7,[R5, R2]
   \   000000AC   0x433E             ORRS     R6,R7,R6
   \   000000AE   0xF056 0x6600      ORRS     R6,R6,#0x8000000
   \   000000B2   0x....             LDR.N    R7,??DataTable2_6
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   000000BA   0x637E             STR      R6,[R7, #+52]
    307          
    308              SPI_EOQF_WAIT(spin);                                            //等待发送完成。(要及时把RX FIFO的东西清掉，不然这里就无限等待)
   \                     ??spi_mosi_6: (+1)
   \   000000BC   0x....             LDR.N    R6,??DataTable2_6
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000C4   0x6AF6             LDR      R6,[R6, #+44]
   \   000000C6   0x00F6             LSLS     R6,R6,#+3
   \   000000C8   0xD5F8             BPL.N    ??spi_mosi_6
    309          
    310              while( !(SPI_SR_REG(SPIN[spin]) & SPI_SR_RFDF_MASK));           //RFDF为1，Rx FIFO is not empty.
   \                     ??spi_mosi_7: (+1)
   \   000000CA   0x....             LDR.N    R6,??DataTable2_6
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000D2   0x6AF6             LDR      R6,[R6, #+44]
   \   000000D4   0x03B6             LSLS     R6,R6,#+14
   \   000000D6   0xD5F8             BPL.N    ??spi_mosi_7
    311              if(midata != NULL)
   \   000000D8   0x2B00             CMP      R3,#+0
   \   000000DA   0xD006             BEQ.N    ??spi_mosi_8
    312              {
    313                  midata[i] = (uint8)SPI_POPR_REG(SPIN[spin]);                  //保存接收到的数据
   \   000000DC   0x....             LDR.N    R6,??DataTable2_6
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000E4   0x6BB6             LDR      R6,[R6, #+56]
   \   000000E6   0x54EE             STRB     R6,[R5, R3]
   \   000000E8   0xE004             B.N      ??spi_mosi_9
    314              }
    315              else
    316              {
    317                  SPI_POPR_REG(SPIN[spin]);
   \                     ??spi_mosi_8: (+1)
   \   000000EA   0x....             LDR.N    R6,??DataTable2_6
   \   000000EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EE   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000F2   0x6BB6             LDR      R6,[R6, #+56]
    318              }
    319              SPI_SR_REG(SPIN[spin]) |= SPI_SR_RFDF_MASK;                     //写1清空RFDF，标记Rx FIFO 是空的
   \                     ??spi_mosi_9: (+1)
   \   000000F4   0x....             LDR.N    R6,??DataTable2_6
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   000000FC   0x6AF6             LDR      R6,[R6, #+44]
   \   000000FE   0xF456 0x3600      ORRS     R6,R6,#0x20000
   \   00000102   0x....             LDR.N    R7,??DataTable2_6
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000106   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
   \   0000010A   0x62FE             STR      R6,[R7, #+44]
    320          }
   \   0000010C   0xBCF0             POP      {R4-R7}
   \   0000010E   0x4770             BX       LR               ;; return
    321          
    322          /*!
    323           *  @brief      SPI发送接收函数
    324           *  @param      SPIn_e          SPI模块(SPI0、SPI1、SPI2)
    325           *  @param      SPIn_PCSn_e     片选管脚编号
    326           *  @param      mocmd           发送的命令缓冲区地址(不需要接收则传 NULL)
    327           *  @param      micmd           发送命令时接收到的数据的存储地址(不需要接收则传 NULL)
    328           *  @param      modata          发送的数据缓冲区地址(不需要接收则传 NULL)
    329           *  @param      midata          发送数据时接收到的数据的存储地址(不需要接收则传 NULL)
    330           *  @since      v5.0
    331           *  Sample usage:           spi_mosi_cmd(SPI0,SPIn_PCS0,cmd,NULL,buff,buff,1,2);    //发送cmd/buff的内容，不接收cmd发送时的数据，接收buff发送时的数据到buff里，长度分别为1、2字节
    332           */

   \                                 In section .text, align 2, keep-with-next
    333          void spi_mosi_cmd(SPIn_e spin, SPI_PCSn_e pcs, uint8 *mocmd , uint8 *micmd , uint8 *modata , uint8 *midata, uint32 cmdlen , uint32 len)
    334          {
   \                     spi_mosi_cmd: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x9C06             LDR      R4,[SP, #+24]
   \   00000006   0x9D07             LDR      R5,[SP, #+28]
   \   00000008   0x9E08             LDR      R6,[SP, #+32]
   \   0000000A   0x9F09             LDR      R7,[SP, #+36]
    335              uint32 i = 0;
   \   0000000C   0xF05F 0x0C00      MOVS     R12,#+0
    336              do
    337              {
    338                  /*************  清标志位  ***************/
    339                  SPI_SR_REG(SPIN[spin]) = (0
    340                                            | SPI_SR_EOQF_MASK    //发送队列空了，发送完毕标志
    341                                            | SPI_SR_TFUF_MASK    //传输FIFO下溢标志位，SPI为从机模式，Tx FIFO为空，而外部SPI主机模式启动传输，标志位就会置1，写1清0
    342                                            | SPI_SR_TFFF_MASK    //传输FIFO满标志位。 写1或者DMA控制器发现传输FIFO满了就会清0。 0表示Tx FIFO满了
    343                                            | SPI_SR_RFOF_MASK    //接收FIFO溢出标志位。
    344                                            | SPI_SR_RFDF_MASK    //接收FIFO损耗标志位，写1或者DMA控制器发现传输FIFO空了就会清0。0表示Rx FIFO空
    345                                           );
   \                     ??spi_mosi_cmd_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    LR,??DataTable2_7  ;; 0x1a0a0000
   \   00000014   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   0000001E   0xF8C8 0xE02C      STR      LR,[R8, #+44]
    346          
    347                  /************** 清FIFO计数器 **************/
    348                  SPI_MCR_REG(SPIN[spin])    |=  (0
    349                                                  | SPI_MCR_CLR_TXF_MASK      //写1清 Tx FIFO 计数器
    350                                                  | SPI_MCR_CLR_RXF_MASK      //写1清 Rx FIFO 计数器
    351                                                 );
   \   00000022   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   0000002C   0xF8DE 0xE000      LDR      LR,[LR, #+0]
   \   00000030   0xF45E 0x6E40      ORRS     LR,LR,#0xC00
   \   00000034   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   0000003E   0xF8C8 0xE000      STR      LR,[R8, #+0]
    352          
    353              }
    354              while( (SPI_SR_REG(SPIN[spin]) & SPI_SR_RFDF_MASK));            //如果 Rx FIFO 非空，则清FIFO.
   \   00000042   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   0000004C   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   00000050   0xEA5F 0x3E8E      LSLS     LR,LR,#+14
   \   00000054   0xD4DC             BMI.N    ??spi_mosi_cmd_0
    355          
    356              /***************** 发送cmdlen个数据 *******************/                                                ;
    357              for(i = 0; i < cmdlen; i++)
   \   00000056   0xF05F 0x0E00      MOVS     LR,#+0
   \   0000005A   0x46F4             MOV      R12,LR
   \                     ??spi_mosi_cmd_1: (+1)
   \   0000005C   0x45B4             CMP      R12,R6
   \   0000005E   0xD241             BCS.N    ??spi_mosi_cmd_2
    358              {
    359                  SPI_PUSHR_REG(SPIN[spin]) = (0
    360                                               | SPI_PUSHR_CTAS(0)             //选择CTAR0寄存器
    361                                               | SPI_PUSHR_CONT_MASK           //1为 传输期间保持PCSn信号 ，即继续传输数据
    362                                               | SPI_PUSHR_PCS(pcs)
    363                                               | SPI_PUSHR_TXDATA(mocmd[i])    //要传输的数据
    364                                              );
   \   00000060   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000062   0xEA5F 0x4E01      LSLS     LR,R1,#+16
   \   00000066   0xF41E 0x1E7C      ANDS     LR,LR,#0x3F0000
   \   0000006A   0xF81C 0x8002      LDRB     R8,[R12, R2]
   \   0000006E   0xEA58 0x0E0E      ORRS     LR,R8,LR
   \   00000072   0xF05E 0x4E00      ORRS     LR,LR,#0x80000000
   \   00000076   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   00000080   0xF8C8 0xE034      STR      LR,[R8, #+52]
    365          
    366                  while(!(SPI_SR_REG(SPIN[spin]) & SPI_SR_RFDF_MASK));        //RFDF为1，Rx FIFO is not empty.
   \                     ??spi_mosi_cmd_3: (+1)
   \   00000084   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   0000008E   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   00000092   0xEA5F 0x3E8E      LSLS     LR,LR,#+14
   \   00000096   0xD5F5             BPL.N    ??spi_mosi_cmd_3
    367                  if(micmd != NULL)
   \   00000098   0x2B00             CMP      R3,#+0
   \   0000009A   0xD009             BEQ.N    ??spi_mosi_cmd_4
    368                  {
    369                      micmd[i] = (uint8)SPI_POPR_REG(SPIN[spin]);             //保存接收到的数据
   \   0000009C   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000000A6   0xF8DE 0xE038      LDR      LR,[LR, #+56]
   \   000000AA   0xF80C 0xE003      STRB     LR,[R12, R3]
   \   000000AE   0xE006             B.N      ??spi_mosi_cmd_5
    370                  }
    371                  else
    372                  {
    373                      SPI_POPR_REG(SPIN[spin]);                               //读取FIFO数据(丢弃读取到的数据)
   \                     ??spi_mosi_cmd_4: (+1)
   \   000000B0   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000000BA   0xF8DE 0xE038      LDR      LR,[LR, #+56]
    374                  }
    375                  SPI_SR_REG(SPIN[spin]) |= SPI_SR_RFDF_MASK;
   \                     ??spi_mosi_cmd_5: (+1)
   \   000000BE   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000000C8   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   000000CC   0xF45E 0x3E00      ORRS     LR,LR,#0x20000
   \   000000D0   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   000000DA   0xF8C8 0xE02C      STR      LR,[R8, #+44]
    376              }
   \   000000DE   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   000000E2   0xE7BB             B.N      ??spi_mosi_cmd_1
    377          
    378              /***************** 发送len-1个数据 *******************/                                                ;
    379              for(i = 0; i < (len - 1); i++)
   \                     ??spi_mosi_cmd_2: (+1)
   \   000000E4   0xF05F 0x0E00      MOVS     LR,#+0
   \   000000E8   0x46F4             MOV      R12,LR
   \                     ??spi_mosi_cmd_6: (+1)
   \   000000EA   0xF1B7 0x0E01      SUBS     LR,R7,#+1
   \   000000EE   0x45F4             CMP      R12,LR
   \   000000F0   0xD241             BCS.N    ??spi_mosi_cmd_7
    380              {
    381                  SPI_PUSHR_REG(SPIN[spin]) = (0
    382                                               | SPI_PUSHR_CTAS(0)             //选择CTAR0寄存器
    383                                               | SPI_PUSHR_CONT_MASK           //1为 传输期间保持PCSn信号 ，即继续传输数据
    384                                               | SPI_PUSHR_PCS(pcs)
    385                                               | SPI_PUSHR_TXDATA(modata[i])     //要传输的数据
    386                                              );
   \   000000F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F4   0xEA5F 0x4E01      LSLS     LR,R1,#+16
   \   000000F8   0xF41E 0x1E7C      ANDS     LR,LR,#0x3F0000
   \   000000FC   0xF81C 0x8004      LDRB     R8,[R12, R4]
   \   00000100   0xEA58 0x0E0E      ORRS     LR,R8,LR
   \   00000104   0xF05E 0x4E00      ORRS     LR,LR,#0x80000000
   \   00000108   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   0000010C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010E   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   00000112   0xF8C8 0xE034      STR      LR,[R8, #+52]
    387          
    388                  while(!(SPI_SR_REG(SPIN[spin]) & SPI_SR_RFDF_MASK));        //RFDF为1，Rx FIFO is not empty.
   \                     ??spi_mosi_cmd_8: (+1)
   \   00000116   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   0000011A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011C   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   00000120   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   00000124   0xEA5F 0x3E8E      LSLS     LR,LR,#+14
   \   00000128   0xD5F5             BPL.N    ??spi_mosi_cmd_8
    389          
    390                  if(midata != NULL)
   \   0000012A   0x2D00             CMP      R5,#+0
   \   0000012C   0xD009             BEQ.N    ??spi_mosi_cmd_9
    391                  {
    392                      midata[i] = (uint8)SPI_POPR_REG(SPIN[spin]);             //保存接收到的数据
   \   0000012E   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   00000138   0xF8DE 0xE038      LDR      LR,[LR, #+56]
   \   0000013C   0xF80C 0xE005      STRB     LR,[R12, R5]
   \   00000140   0xE006             B.N      ??spi_mosi_cmd_10
    393                  }
    394                  else
    395                  {
    396                      SPI_POPR_REG(SPIN[spin]);                               //读取FIFO数据(丢弃读取到的数据)
   \                     ??spi_mosi_cmd_9: (+1)
   \   00000142   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   0000014C   0xF8DE 0xE038      LDR      LR,[LR, #+56]
    397                  }
    398                  SPI_SR_REG(SPIN[spin]) |= SPI_SR_RFDF_MASK;
   \                     ??spi_mosi_cmd_10: (+1)
   \   00000150   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   00000154   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000156   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   0000015A   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   0000015E   0xF45E 0x3E00      ORRS     LR,LR,#0x20000
   \   00000162   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   0000016C   0xF8C8 0xE02C      STR      LR,[R8, #+44]
    399              }
   \   00000170   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   00000174   0xE7B9             B.N      ??spi_mosi_cmd_6
    400              /***************** 发送最后一个数据 *******************/
    401              SPI_PUSHR_REG(SPIN[spin]) = (0
    402                                           | SPI_PUSHR_CTAS(0)          //选择CTAR0寄存器
    403                                           | SPI_PUSHR_PCS(pcs)
    404                                           | SPI_PUSHR_EOQ_MASK         //End Of Queue，1为 传输SPI最后的数据
    405                                           | SPI_PUSHR_TXDATA(modata[i])
    406                                          );
   \                     ??spi_mosi_cmd_7: (+1)
   \   00000176   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000178   0xEA5F 0x4E01      LSLS     LR,R1,#+16
   \   0000017C   0xF41E 0x1E7C      ANDS     LR,LR,#0x3F0000
   \   00000180   0xF81C 0x8004      LDRB     R8,[R12, R4]
   \   00000184   0xEA58 0x0E0E      ORRS     LR,R8,LR
   \   00000188   0xF05E 0x6E00      ORRS     LR,LR,#0x8000000
   \   0000018C   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   00000190   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000192   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   00000196   0xF8C8 0xE034      STR      LR,[R8, #+52]
    407          
    408              SPI_EOQF_WAIT(spin);    //要及时把RX FIFO的东西清掉，不然这里就无限等待
   \                     ??spi_mosi_cmd_11: (+1)
   \   0000019A   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   0000019E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A0   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000001A4   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   000001A8   0xEA5F 0x0ECE      LSLS     LR,LR,#+3
   \   000001AC   0xD5F5             BPL.N    ??spi_mosi_cmd_11
    409          
    410              while( !(SPI_SR_REG(SPIN[spin]) & SPI_SR_RFDF_MASK));    //RFDF为1，Rx FIFO is not empty.
   \                     ??spi_mosi_cmd_12: (+1)
   \   000001AE   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   000001B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B4   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000001B8   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   000001BC   0xEA5F 0x3E8E      LSLS     LR,LR,#+14
   \   000001C0   0xD5F5             BPL.N    ??spi_mosi_cmd_12
    411              if(midata != NULL)
   \   000001C2   0x2D00             CMP      R5,#+0
   \   000001C4   0xD009             BEQ.N    ??spi_mosi_cmd_13
    412              {
    413                  midata[i] = (uint8)SPI_POPR_REG(SPIN[spin]);             //保存接收到的数据
   \   000001C6   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   000001CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CC   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000001D0   0xF8DE 0xE038      LDR      LR,[LR, #+56]
   \   000001D4   0xF80C 0xE005      STRB     LR,[R12, R5]
   \   000001D8   0xE006             B.N      ??spi_mosi_cmd_14
    414              }
    415              else
    416              {
    417                  SPI_POPR_REG(SPIN[spin]);                               //读取FIFO数据(丢弃读取到的数据)
   \                     ??spi_mosi_cmd_13: (+1)
   \   000001DA   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   000001DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001E0   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000001E4   0xF8DE 0xE038      LDR      LR,[LR, #+56]
    418              }
    419              SPI_SR_REG(SPIN[spin]) |= SPI_SR_RFDF_MASK;
   \                     ??spi_mosi_cmd_14: (+1)
   \   000001E8   0x.... 0x....      LDR.W    LR,??DataTable2_6
   \   000001EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001EE   0xF85E 0xE020      LDR      LR,[LR, R0, LSL #+2]
   \   000001F2   0xF8DE 0xE02C      LDR      LR,[LR, #+44]
   \   000001F6   0xF45E 0x3E00      ORRS     LR,LR,#0x20000
   \   000001FA   0x.... 0x....      LDR.W    R8,??DataTable2_6
   \   000001FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000200   0xF858 0x8020      LDR      R8,[R8, R0, LSL #+2]
   \   00000204   0xF8C8 0xE02C      STR      LR,[R8, #+44]
    420          }
   \   00000208   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     SPIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x1A0A0000         DC32     0x1a0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x803F0000         DC32     0x803f0000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00000002         DC32 2, 4, 6, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192
   \              0x00000004   
   \              0x00000006   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \              0x00000800   
   \              0x00001000   
   \              0x00002000   
   \   00000038   0x00004000         DC32 16384, 32768
   \              0x00008000   

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x02 0x03          DC8 2, 3, 5, 7
   \              0x05 0x07    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 53H, 74H, 75H, 64H, 79H
   \              0x5C 0x53    
   \              0x74 0x75    
   \              0x64 0x79    
   \   00000008   0x5C 0x32          DC8 5CH, 32H, 30H, 31H, 36H, 0B5H, 0E7H, 0D7H
   \              0x30 0x31    
   \              0x36 0xB5    
   \              0xE7 0xD7    
   \   00000010   0xD3 0xC9          DC8 0D3H, 0C9H, 0E8H, 0BCH, 0C6H, 0B4H, 0F3H, 0C8H
   \              0xE8 0xBC    
   \              0xC6 0xB4    
   \              0xF3 0xC8    
   \   00000018   0xFC 0x5C          DC8 0FCH, 5CH, 54H, 69H, 5CH, 0B5H, 0E7H, 0C8H
   \              0x54 0x69    
   \              0x5C 0xB5    
   \              0xE7 0xC8    
   \   00000020   0xFC 0xB1          DC8 0FCH, 0B1H, 0B8H, 0D3H, 0C3H, 0B5H, 0D7H, 0B2H
   \              0xB8 0xD3    
   \              0xC3 0xB5    
   \              0xD7 0xB2    
   \   00000028   0xE3 0x5C          DC8 0E3H, 5CH, 43H, 68H, 69H, 70H, 5CH, 73H
   \              0x43 0x68    
   \              0x69 0x70    
   \              0x5C 0x73    
   \   00000030   0x72 0x63          DC8 72H, 63H, 5CH, 4DH, 4BH, 36H, 30H, 5FH
   \              0x5C 0x4D    
   \              0x4B 0x36    
   \              0x30 0x5F    
   \   00000038   0x73 0x70          DC8 73H, 70H, 69H, 2EH, 63H, 0
   \              0x69 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0
    421          
    422          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     136   spi_init
       136   -> __aeabi_memcpy4
       136   -> abs
       136   -> assert_failed
       136   -> port_init
      16   spi_mosi
      24   spi_mosi_cmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
      64  ?_0
       4  ?_1
      64  ?_2
      12  SPIN
     812  spi_init
     272  spi_mosi
     524  spi_mosi_cmd

 
    12 bytes in section .data
   132 bytes in section .rodata
 1 644 bytes in section .text
 
 1 644 bytes of CODE  memory
   132 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
