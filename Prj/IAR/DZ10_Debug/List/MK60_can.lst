###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_can.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_can.c -D DEBUG
#        -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\MK60_can.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\MK60_can.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_can.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       MK60_can.c
     11           * @brief      CAN函数
     12           * @author     山外科技
     13           * @version    v5.1
     14           * @date       2014-04-25
     15           */
     16          
     17          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable11  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable11_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     18          #include "MK60_port.h"
     19          #include "MK60_can.h"
     20          
     21          
     22          // CAN ID值越低，报文优先级越高
     23          // CAN 掩码用于屏蔽
     24          
     25          
     26          // 用于发送缓冲区的报文缓冲区码字
     27          #define CAN_CS_CODE_TX_INACTIVE     B8(1000)            //MB 处于非激活状态
     28          #define CAN_CS_CODE_TX_ABORT        B8(1001)            //MB 被丢弃
     29          #define CAN_CS_CODE_TX_DATA         B8(1100)            //MB 为一个发送数据帧（MB 的 RTR 位为 0）
     30          #define CAN_CS_CODE_TX_REMOTE       B8(1100)            //MB 为一个发送远程请求帧（MB 的 RTR 位为 1）
     31          #define CAN_CS_CODE_TX_TANSWER      B8(1110)            //MB 为是远程请求帧的一个发送回应帧
     32          
     33          // 用于接收缓冲区的报文缓冲区码字
     34          #define CAN_CS_CODE_RX_INACTIVE     B8(0000)            //MB 处于非激活状态
     35          #define CAN_CS_CODE_RX_EMPTY        B8(0100)            //MB 激活并且为空
     36          #define CAN_CS_CODE_RX_FULL         B8(0010)            //MB 为满
     37          #define CAN_CS_CODE_RX_OVERRUN      B8(0110)            //写入到一个满缓冲区 导致 MB 被覆盖
     38          #define CAN_CS_CODE_RX_RANSWER      B8(1010)            //一个新帧被配置为确认一个远程请求帧并且发送一个回复帧。
     39          #define CAN_CS_CODE_RX_BUSY         B8(0001)            //正在更新 MB 的内容。CPU 不允许访问MB
     40          
     41          

   \                                 In section .data, align 4
     42          CAN_MemMapPtr CANN[] = {CAN0_BASE_PTR, CAN1_BASE_PTR};
   \                     CANN:
   \   00000000   0x40024000         DC32 40024000H, 400A4000H
   \              0x400A4000   
     43          
     44          
     45          //仅适用于CAN时钟源为 50.00MHz

   \                                 In section .data, align 4
     46          CAN_band_cfg_t can_band_cfg_50000K[CAN_BAUD_MAX] =
   \                     can_band_cfg_50000K:
   \   00000000   0x0000000A         DC32 10
   \   00000004   0x0270             DC16 624
   \   00000006   0x04 0x00          DC8 4, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000000C   0x00000014         DC32 20
   \   00000010   0x007C             DC16 124
   \   00000012   0x0C 0x02          DC8 12, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000018   0x00000032         DC32 50
   \   0000001C   0x007C             DC16 124
   \   0000001E   0x04 0x00          DC8 4, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000024   0x00000064         DC32 100
   \   00000028   0x0018             DC16 24
   \   0000002A   0x0C 0x02          DC8 12, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000030   0x0000007D         DC32 125
   \   00000034   0x0018             DC16 24
   \   00000036   0x0A 0x01          DC8 10, 1, 1, 1, 0, 0
   \              0x01 0x01    
   \              0x00 0x00    
   \   0000003C   0x000000FA         DC32 250
   \   00000040   0x0018             DC16 24
   \   00000042   0x04 0x00          DC8 4, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000048   0x000001F4         DC32 500
   \   0000004C   0x0004             DC16 4
   \   0000004E   0x0C 0x02          DC8 12, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000054   0x000003E8         DC32 1000
   \   00000058   0x0001             DC16 1
   \   0000005A   0x09 0x06          DC8 9, 6, 6, 3, 0, 0
   \              0x06 0x03    
   \              0x00 0x00    
     47          {
     48              //BAND, PRESDIV, PROP_SEG, PSEG1,   PSEG2, RJW
     49              {10,    624,    4,          0,      0,      0},         //采样点:87.50%
     50              {20,    124,    12,         2,      2,      2},         //采样点:85.00%
     51              {50,    124,    4,          0,      0,      0},         //采样点:87.50%
     52              {100,   24,     12,         2,      2,      2},         //采样点:85.00%
     53              {125,   24,     10,         1,      1,      1},         //采样点:87.50%
     54              {250,   24,     4,          0,      0,      0},         //采样点:87.50%
     55              {500,   4,      12,         2,      2,      2},         //采样点:85.00%
     56              {1000,  1,      9,          6,      6,      3},         //采样点:72.00%
     57          };
     58          //仅适用于CAN时钟源为 60.00MHz

   \                                 In section .data, align 4
     59          CAN_band_cfg_t can_band_cfg_60000K[CAN_BAUD_MAX] =
   \                     can_band_cfg_60000K:
   \   00000000   0x0000000A         DC32 10
   \   00000004   0x00F9             DC16 249
   \   00000006   0x10 0x02          DC8 16, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   0000000C   0x00000014         DC32 20
   \   00000010   0x007C             DC16 124
   \   00000012   0x10 0x02          DC8 16, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000018   0x00000032         DC32 50
   \   0000001C   0x0031             DC16 49
   \   0000001E   0x10 0x02          DC8 16, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000024   0x00000064         DC32 100
   \   00000028   0x0018             DC16 24
   \   0000002A   0x10 0x02          DC8 16, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000030   0x0000007D         DC32 125
   \   00000034   0x0013             DC16 19
   \   00000036   0x10 0x02          DC8 16, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   0000003C   0x000000FA         DC32 250
   \   00000040   0x0009             DC16 9
   \   00000042   0x10 0x02          DC8 16, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000048   0x000001F4         DC32 500
   \   0000004C   0x0004             DC16 4
   \   0000004E   0x10 0x02          DC8 16, 2, 2, 2, 0, 0
   \              0x02 0x02    
   \              0x00 0x00    
   \   00000054   0x000003E8         DC32 1000
   \   00000058   0x0002             DC16 2
   \   0000005A   0x08 0x04          DC8 8, 4, 4, 3, 0, 0
   \              0x04 0x03    
   \              0x00 0x00    
     60          {
     61              //BAND, PRESDIV, PROP_SEG, PSEG1,   PSEG2, RJW
     62              {10,    249,    16,         2,      2,      2},		//采样点:87.50%
     63              {20,    124,    16,         2,      2,      2},		//采样点:87.50%
     64              {50,    49,     16,         2,      2,      2},		//采样点:87.50%
     65              {100,   24,     16,         2,      2,      2},		//采样点:87.50%
     66              {125,   19,     16,         2,      2,      2},		//采样点:87.50%
     67              {250,   9,      16,         2,      2,      2},		//采样点:87.50%
     68              {500,   4,      16,         2,      2,      2},		//采样点:87.50%
     69              {1000,  2,      8,          4,      4,      3},		//采样点:75.00%
     70          };
     71          
     72          /*!
     73           *  @brief      CAN 初始化
     74           *  @param      CANn_e          CAN 模块号
     75           *  @param      CAN_BAUD_e      波特率编号
     76           *  @param      CAN_mode_e      CAN 模式( 正常 、 回环 模式)
     77           *  @param      CAN_CLKSRC_e    CAN 时钟源( bus 、 外部晶振)
     78           *  @since      v5.0
     79           *  Sample usage:       can_init(CAN1,CAN_BAUD_20K,CAN_LOOPBACK);   //初始化 CAN1 ，波特率 20Kb/s ， 回环模式
     80           */

   \                                 In section .text, align 2, keep-with-next
     81          void can_init(CANn_e cann, CAN_BAUD_e band, CAN_mode_e mode,CAN_CLKSRC_e clksrc)
     82          {
   \                     can_init: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     83              uint8 i;
     84              CAN_MemMapPtr canptr = CANN[cann];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0xF850 0x9024      LDR      R9,[R0, R4, LSL #+2]
     85          
     86              switch(cann)
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD002             BEQ.N    ??can_init_0
   \   0000001C   0x2C01             CMP      R4,#+1
   \   0000001E   0xD013             BEQ.N    ??can_init_1
   \   00000020   0xE025             B.N      ??can_init_2
     87              {
     88              case CAN0:
     89                  SIM_SCGC6 |= SIM_SCGC6_FLEXCAN0_MASK ;                  //开启 CAN0 时钟
   \                     ??can_init_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x4004803c
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable11_3  ;; 0x4004803c
   \   00000030   0x6008             STR      R0,[R1, #+0]
     90                  port_init(CAN0_TX_PIN, ALT2);
   \   00000032   0xF44F 0x7100      MOV      R1,#+512
   \   00000036   0x200C             MOVS     R0,#+12
   \   00000038   0x.... 0x....      BL       port_init
     91                  port_init(CAN0_RX_PIN, ALT2);
   \   0000003C   0xF44F 0x7100      MOV      R1,#+512
   \   00000040   0x200D             MOVS     R0,#+13
   \   00000042   0x.... 0x....      BL       port_init
     92                  break;
   \   00000046   0xE017             B.N      ??can_init_3
     93              case CAN1:
     94                  SIM_SCGC3 |= SIM_SCGC3_FLEXCAN1_MASK;                   //开启 CAN1 时钟
   \                     ??can_init_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x40048030
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable11_4  ;; 0x40048030
   \   00000056   0x6008             STR      R0,[R1, #+0]
     95                  port_init(CAN1_TX_PIN, ALT2);
   \   00000058   0xF44F 0x7100      MOV      R1,#+512
   \   0000005C   0x2098             MOVS     R0,#+152
   \   0000005E   0x.... 0x....      BL       port_init
     96                  port_init(CAN1_RX_PIN, ALT2);
   \   00000062   0xF44F 0x7100      MOV      R1,#+512
   \   00000066   0x2099             MOVS     R0,#+153
   \   00000068   0x.... 0x....      BL       port_init
     97                  break;
   \   0000006C   0xE004             B.N      ??can_init_3
     98              default:
     99                  ASSERT(0);                                              //断言，cann值有误？
   \                     ??can_init_2: (+1)
   \   0000006E   0x2163             MOVS     R1,#+99
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000074   0x.... 0x....      BL       assert_failed
    100              }
    101          
    102              //选择时钟源
    103              if(clksrc == CAN_CLKSRC_BUS)
   \                     ??can_init_3: (+1)
   \   00000078   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007A   0x2F00             CMP      R7,#+0
   \   0000007C   0xD106             BNE.N    ??can_init_4
    104              {
    105                  CAN_CTRL1_REG(canptr)   |= CAN_CTRL1_CLKSRC_MASK;           //选择为bus 时钟
   \   0000007E   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000082   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000086   0xF8C9 0x0004      STR      R0,[R9, #+4]
   \   0000008A   0xE00D             B.N      ??can_init_5
    106              }
    107              else
    108              {
    109          #if defined(MK60DZ10)
    110                  OSC_CR |= OSC_CR_ERCLKEN_MASK;                              //使能 OSCERCLK
   \                     ??can_init_4: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x40065000
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable11_6  ;; 0x40065000
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
    111          #elif  defined(MK60F15)
    112                  OSC0_CR |= OSC_CR_ERCLKEN_MASK;                              //使能 OSCERCLK
    113          #endif
    114                  CAN_CTRL1_REG(canptr)   &= ~CAN_CTRL1_CLKSRC_MASK;
   \   0000009C   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   000000A0   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   000000A4   0xF8C9 0x0004      STR      R0,[R9, #+4]
    115              }
    116          
    117              CAN_MCR_REG(canptr) &= ~CAN_MCR_MDIS_MASK;                  //使能CAN模块
   \                     ??can_init_5: (+1)
   \   000000A8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000AC   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   000000AE   0x0840             LSRS     R0,R0,#+1
   \   000000B0   0xF8C9 0x0000      STR      R0,[R9, #+0]
    118          
    119              CAN_MCR_REG(canptr) |=  CAN_MCR_FRZ_MASK;                   //使能冻结模式
   \   000000B4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000B8   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   000000BC   0xF8C9 0x0000      STR      R0,[R9, #+0]
    120          
    121              while((CAN_MCR_REG(canptr) & CAN_MCR_LPMACK_MASK ));        //等待复位（低功耗模式无法复位成功）
   \                     ??can_init_6: (+1)
   \   000000C0   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000C4   0x02C0             LSLS     R0,R0,#+11
   \   000000C6   0xD4FB             BMI.N    ??can_init_6
    122          
    123              CAN_MCR_REG(canptr) |= CAN_MCR_SOFTRST_MASK;                //软件复位
   \   000000C8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000CC   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   000000D0   0xF8C9 0x0000      STR      R0,[R9, #+0]
    124          
    125              while(!(CAN_MCR_REG(canptr) & CAN_MCR_FRZACK_MASK));        //等待进入冻结模式
   \                     ??can_init_7: (+1)
   \   000000D4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000D8   0x01C0             LSLS     R0,R0,#+7
   \   000000DA   0xD5FB             BPL.N    ??can_init_7
    126          
    127              //清空邮箱缓冲区内容清0
    128              i = 16;
   \   000000DC   0x2010             MOVS     R0,#+16
   \   000000DE   0x4680             MOV      R8,R0
    129              while(i)
   \                     ??can_init_8: (+1)
   \   000000E0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E4   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000E8   0xD01E             BEQ.N    ??can_init_9
    130              {
    131                  i--;
   \   000000EA   0xF1B8 0x0801      SUBS     R8,R8,#+1
    132                  CAN_CS_REG(canptr, i) = 0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F4   0xEB19 0x1108      ADDS     R1,R9,R8, LSL #+4
   \   000000F8   0xF8C1 0x0080      STR      R0,[R1, #+128]
    133                  CAN_ID_REG(canptr, i) = 0;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000102   0xEB19 0x1108      ADDS     R1,R9,R8, LSL #+4
   \   00000106   0xF8C1 0x0084      STR      R0,[R1, #+132]
    134                  CAN_WORD0_REG(canptr, i) = 0;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000110   0xEB19 0x1108      ADDS     R1,R9,R8, LSL #+4
   \   00000114   0xF8C1 0x0088      STR      R0,[R1, #+136]
    135                  CAN_WORD1_REG(canptr, i) = 0;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000011E   0xEB19 0x1108      ADDS     R1,R9,R8, LSL #+4
   \   00000122   0xF8C1 0x008C      STR      R0,[R1, #+140]
   \   00000126   0xE7DB             B.N      ??can_init_8
    136              }
    137          
    138              CAN_CTRL2_REG(canptr) = (0
    139                                       //| CAN_CTRL2_EACEN_MASK            //接收邮箱过滤IDE匹配，RTR不匹配
    140                                       //| CAN_CTRL2_RRS_MASK              //不自动产生远程请求帧
    141                                       //| CAN_CTRL2_MRP_MASK              //邮箱首先从接收FIFO队列匹配然后再在邮箱中匹配
    142                                       | CAN_CTRL2_TASD(22)                //Tx Arbitration Start Delay
    143                                      );
   \                     ??can_init_9: (+1)
   \   00000128   0xF45F 0x0030      MOVS     R0,#+11534336
   \   0000012C   0xF8C9 0x0034      STR      R0,[R9, #+52]
    144          
    145              //使用一个32位过滤器
    146              CAN_MCR_REG(canptr) = (CAN_MCR_REG(canptr) & (~CAN_MCR_IDAM_MASK)) | CAN_MCR_IDAM(0);
   \   00000130   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000134   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000138   0xF8C9 0x0000      STR      R0,[R9, #+0]
    147          
    148              //设置波特率
    149              can_setband(cann, band);
   \   0000013C   0x0029             MOVS     R1,R5
   \   0000013E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000140   0x0020             MOVS     R0,R4
   \   00000142   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000144   0x.... 0x....      BL       can_setband
    150          
    151              //回环模式
    152              if(mode == CAN_LOOPBACK)
   \   00000148   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000014A   0x2E01             CMP      R6,#+1
   \   0000014C   0xD105             BNE.N    ??can_init_10
    153              {
    154                  CAN_CTRL1_REG(canptr) |= CAN_CTRL1_LPB_MASK;//使用回环模式
   \   0000014E   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   00000152   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000156   0xF8C9 0x0004      STR      R0,[R9, #+4]
    155              }
    156          
    157              //默认使用 独立 掩码
    158              CAN_MCR_REG(canptr) |= CAN_MCR_IRMQ_MASK;
   \                     ??can_init_10: (+1)
   \   0000015A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000015E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000162   0xF8C9 0x0000      STR      R0,[R9, #+0]
    159          
    160              //初始化掩码寄存器
    161              i = NUMBER_OF_MB;
   \   00000166   0x2010             MOVS     R0,#+16
   \   00000168   0x4680             MOV      R8,R0
    162              while(i)
   \                     ??can_init_11: (+1)
   \   0000016A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000016E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000172   0xD009             BEQ.N    ??can_init_12
    163              {
    164                  i--;
   \   00000174   0xF1B8 0x0801      SUBS     R8,R8,#+1
    165                  CAN_RXIMR_REG(canptr, i) = 0x0;
   \   00000178   0x2000             MOVS     R0,#+0
   \   0000017A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000017E   0xEB19 0x0188      ADDS     R1,R9,R8, LSL #+2
   \   00000182   0xF8C1 0x0880      STR      R0,[R1, #+2176]
   \   00000186   0xE7F0             B.N      ??can_init_11
    166              }
    167          
    168              CAN_RXMGMASK_REG(canptr) = 0x0;
   \                     ??can_init_12: (+1)
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0xF8C9 0x0010      STR      R0,[R9, #+16]
    169              CAN_RX14MASK_REG(canptr) = 0x0;
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0xF8C9 0x0014      STR      R0,[R9, #+20]
    170              CAN_RX15MASK_REG(canptr) = 0x0;
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0xF8C9 0x0018      STR      R0,[R9, #+24]
    171          
    172              //只有在冻结模式下才能配置 配置完退出冻结模式
    173              CAN_MCR_REG(canptr) &= ~(CAN_MCR_HALT_MASK);
   \   0000019A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000019E   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   000001A2   0xF8C9 0x0000      STR      R0,[R9, #+0]
    174          
    175              //等待模块推出冻结模式
    176              while( CAN_MCR_REG(canptr) & CAN_MCR_FRZACK_MASK);
   \                     ??can_init_13: (+1)
   \   000001A6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000001AA   0x01C0             LSLS     R0,R0,#+7
   \   000001AC   0xD4FB             BMI.N    ??can_init_13
    177          
    178              //等待同步
    179              //等到不在冻结模式，休眠模式或者停止模式
    180              while(CAN_MCR_REG(canptr) & CAN_MCR_NOTRDY_MASK);
   \                     ??can_init_14: (+1)
   \   000001AE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000001B2   0x0100             LSLS     R0,R0,#+4
   \   000001B4   0xD4FB             BMI.N    ??can_init_14
    181          }
   \   000001B6   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    182          
    183          
    184          /*!
    185           *  @brief      CAN 发送数据
    186           *  @param      CANn_e          CAN 模块号
    187           *  @param      mb_num_e        缓冲区编号
    188           *  @param      CAN_USR_ID_t    ID编号
    189           *  @param      len             数据长度
    190           *  @param      buff            缓冲区地址
    191           *  @since      v5.0
    192           *  Sample usage:       can_tx(CAN1,CAN_TX_MB,can_tx_id,DATA_LEN, txbuff);  //CAN发送数据。缓冲区CAN_TX_MB，报文ID:tx_ID，数据缓冲区txbuff，长度 DATA_LEN
    193           */

   \                                 In section .text, align 2, keep-with-next
    194          void can_tx(CANn_e cann, mb_num_e nMB, CAN_USR_ID_t id, uint8 len, void *buff)
    195          {
   \                     can_tx: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    196              uint32 word;
    197              CAN_MemMapPtr canptr = CANN[cann];
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF850 0xA024      LDR      R10,[R0, R4, LSL #+2]
    198          
    199          
    200              ASSERT(len <= 8 );       //断言，一次发送最大长度为 8字节
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2F09             CMP      R7,#+9
   \   0000001E   0xDB04             BLT.N    ??can_tx_0
   \   00000020   0x21C8             MOVS     R1,#+200
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000026   0x.... 0x....      BL       assert_failed
    201          
    202          
    203              //以下四步骤为发送过程
    204              CAN_CS_REG(canptr, nMB)   = ( 0
    205                                            | CAN_CS_CODE(CAN_CS_CODE_TX_INACTIVE)    //缓冲区写非激活代码
    206                                            | (id.IDE << CAN_CS_IDE_SHIFT)            //缓冲区写IDE位
    207                                            | (id.RTR << CAN_CS_RTR_SHIFT)            //缓冲区写RTR位
    208                                            | CAN_CS_DLC(len)                         //缓冲区写数据长度
    209                                          );
   \                     ??can_tx_0: (+1)
   \   0000002A   0xF3C6 0x7040      UBFX     R0,R6,#+29,#+1
   \   0000002E   0xF3C6 0x7180      UBFX     R1,R6,#+30,#+1
   \   00000032   0x0509             LSLS     R1,R1,#+20
   \   00000034   0xEA51 0x5040      ORRS     R0,R1,R0, LSL #+21
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x0439             LSLS     R1,R7,#+16
   \   0000003C   0xF411 0x2170      ANDS     R1,R1,#0xF0000
   \   00000040   0x4308             ORRS     R0,R1,R0
   \   00000042   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0xEB1A 0x1105      ADDS     R1,R10,R5, LSL #+4
   \   0000004C   0xF8C1 0x0080      STR      R0,[R1, #+128]
    210          
    211              //缓冲区写ID
    212              if(id.IDE)
   \   00000050   0xF3C6 0x7040      UBFX     R0,R6,#+29,#+1
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD009             BEQ.N    ??can_tx_1
    213              {
    214                  //拓展帧
    215                  CAN_ID_REG(canptr, nMB)   = ( 0
    216                                                | CAN_ID_PRIO(1)
    217                                                | CAN_ID_EXT(id.ID)
    218                                              );
   \   00000058   0x03B0             LSLS     R0,R6,#+14       ;; ZeroExtS R0,R6,#+14,#+14
   \   0000005A   0x0B80             LSRS     R0,R0,#+14
   \   0000005C   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0xEB1A 0x1105      ADDS     R1,R10,R5, LSL #+4
   \   00000066   0xF8C1 0x0084      STR      R0,[R1, #+132]
   \   0000006A   0xE00A             B.N      ??can_tx_2
    219              }
    220              else
    221              {
    222                  //标准帧
    223                  CAN_ID_REG(canptr, nMB)   = ( 0
    224                                                | CAN_ID_PRIO(1)
    225                                                | CAN_ID_STD(id.ID)
    226                                              );
   \                     ??can_tx_1: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x1ffc0000
   \   00000070   0xEA10 0x4086      ANDS     R0,R0,R6, LSL #+18
   \   00000074   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0xEB1A 0x1105      ADDS     R1,R10,R5, LSL #+4
   \   0000007E   0xF8C1 0x0084      STR      R0,[R1, #+132]
    227              }
    228          
    229              //缓冲区写内容
    230              word = *(uint32 *)buff;
   \                     ??can_tx_2: (+1)
   \   00000082   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000086   0x4681             MOV      R9,R0
    231              CAN_WORD0_REG(canptr, nMB) = SWAP32(word);
   \   00000088   0xFA99 0xF089      REV      R0,R9
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0xEB1A 0x1105      ADDS     R1,R10,R5, LSL #+4
   \   00000092   0xF8C1 0x0088      STR      R0,[R1, #+136]
    232          
    233              word = *((uint32 *)buff + 1);
   \   00000096   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000009A   0x4681             MOV      R9,R0
    234              CAN_WORD1_REG(canptr, nMB) = SWAP32(word);
   \   0000009C   0xFA99 0xF089      REV      R0,R9
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0xEB1A 0x1105      ADDS     R1,R10,R5, LSL #+4
   \   000000A6   0xF8C1 0x008C      STR      R0,[R1, #+140]
    235          
    236              //开始发送
    237              CAN_CS_REG(canptr, nMB)   =   ( 0
    238                                              | CAN_CS_CODE(CAN_CS_CODE_TX_DATA)              //写激活代码，MB 为一个发送数据帧（MB 的 RTR 位为 0）
    239                                              //| CAN_CS_RTR_MASK
    240                                              | CAN_CS_DLC(len)                               //缓冲区写数据长度
    241                                            );
   \   000000AA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AC   0x0438             LSLS     R0,R7,#+16
   \   000000AE   0xF410 0x2070      ANDS     R0,R0,#0xF0000
   \   000000B2   0xF050 0x6040      ORRS     R0,R0,#0xC000000
   \   000000B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B8   0xEB1A 0x1105      ADDS     R1,R10,R5, LSL #+4
   \   000000BC   0xF8C1 0x0080      STR      R0,[R1, #+128]
    242          
    243              //限时等待发送完成（如果使用中断则限时等待语句可删除）
    244              while(!(CAN_IFLAG1_REG(canptr) & (1 << nMB)));
   \                     ??can_tx_3: (+1)
   \   000000C0   0xF8DA 0x0030      LDR      R0,[R10, #+48]
   \   000000C4   0x0001             MOVS     R1,R0
   \   000000C6   0x40E9             LSRS     R1,R1,R5
   \   000000C8   0x07C8             LSLS     R0,R1,#+31
   \   000000CA   0xD5F9             BPL.N    ??can_tx_3
    245          
    246          
    247              //清报文缓冲区中断标志
    248              CAN_IFLAG1_REG(canptr)  = (1 << nMB);
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x40A8             LSLS     R0,R0,R5
   \   000000D0   0xF8CA 0x0030      STR      R0,[R10, #+48]
    249          
    250          }
   \   000000D4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    251          
    252          /*!
    253           *  @brief      使能 CAN 接收缓冲区
    254           *  @param      CANn_e          CAN 模块号
    255           *  @param      mb_num_e        缓冲区编号
    256           *  @param      CAN_USR_ID_t    ID编号
    257           *  @since      v5.0
    258           *  Sample usage:      can_rxbuff_enble(CAN1,CAN_RX_MB,can_my_id);
    259           *                                   //使能接收缓冲区
    260           */

   \                                 In section .text, align 2, keep-with-next
    261          void can_rxbuff_enble(CANn_e cann, mb_num_e nMB, CAN_USR_ID_t id)
    262          {
   \                     can_rxbuff_enble: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    263              CAN_MemMapPtr canptr = CANN[cann];
   \   00000002   0x....             LDR.N    R3,??DataTable11_2
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0xF853 0x3020      LDR      R3,[R3, R0, LSL #+2]
    264          
    265              //将MB配置为非激活状态
    266              CAN_CS_REG(canptr, nMB) = CAN_CS_CODE(CAN_CS_CODE_RX_INACTIVE);
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xEB13 0x1501      ADDS     R5,R3,R1, LSL #+4
   \   00000012   0xF8C5 0x4080      STR      R4,[R5, #+128]
    267          
    268          
    269              if(id.IDE )         //扩展帧
   \   00000016   0xF3C2 0x7440      UBFX     R4,R2,#+29,#+1
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD015             BEQ.N    ??can_rxbuff_enble_0
    270              {
    271                  CAN_ID_REG(canptr, nMB) =   ( 0
    272                                                | CAN_ID_EXT( id.ID)
    273                                              );
   \   0000001E   0x0394             LSLS     R4,R2,#+14       ;; ZeroExtS R4,R2,#+14,#+14
   \   00000020   0x0BA4             LSRS     R4,R4,#+14
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0xEB13 0x1501      ADDS     R5,R3,R1, LSL #+4
   \   00000028   0xF8C5 0x4084      STR      R4,[R5, #+132]
    274                  CAN_CS_REG(canptr, nMB) = CAN_CS_IDE_MASK;
   \   0000002C   0xF45F 0x1400      MOVS     R4,#+2097152
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0xEB13 0x1501      ADDS     R5,R3,R1, LSL #+4
   \   00000036   0xF8C5 0x4080      STR      R4,[R5, #+128]
    275          
    276                  CAN_CS_REG(canptr, nMB) = (0
    277                                             | CAN_CS_IDE_MASK
    278                                             | (id.RTR << CAN_CS_IDE_SHIFT)
    279                                             | CAN_CS_CODE(CAN_CS_CODE_RX_EMPTY)//激活接收缓冲区
    280                                            );
   \   0000003A   0xF05F 0x6484      MOVS     R4,#+69206016
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0xEB13 0x1501      ADDS     R5,R3,R1, LSL #+4
   \   00000044   0xF8C5 0x4080      STR      R4,[R5, #+128]
   \   00000048   0xE011             B.N      ??can_rxbuff_enble_1
    281              }
    282              else
    283              {
    284                  //标准帧
    285                  CAN_ID_REG(canptr, nMB) =   ( 0
    286                                                | CAN_ID_STD( id.ID)
    287                                              );
   \                     ??can_rxbuff_enble_0: (+1)
   \   0000004A   0x....             LDR.N    R4,??DataTable11_7  ;; 0x1ffc0000
   \   0000004C   0xEA14 0x4482      ANDS     R4,R4,R2, LSL #+18
   \   00000050   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000052   0xEB13 0x1501      ADDS     R5,R3,R1, LSL #+4
   \   00000056   0xF8C5 0x4084      STR      R4,[R5, #+132]
    288          
    289                  CAN_CS_REG(canptr, nMB) = (0
    290                                             | (id.RTR << CAN_CS_IDE_SHIFT)
    291                                             | CAN_CS_CODE(CAN_CS_CODE_RX_EMPTY)//激活接收缓冲区
    292                                            );
   \   0000005A   0xF3C2 0x7480      UBFX     R4,R2,#+30,#+1
   \   0000005E   0x0564             LSLS     R4,R4,#+21
   \   00000060   0xF054 0x6480      ORRS     R4,R4,#0x4000000
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0xEB13 0x1501      ADDS     R5,R3,R1, LSL #+4
   \   0000006A   0xF8C5 0x4080      STR      R4,[R5, #+128]
    293          
    294              }
    295          }
   \                     ??can_rxbuff_enble_1: (+1)
   \   0000006E   0xBC30             POP      {R4,R5}
   \   00000070   0x4770             BX       LR               ;; return
    296          
    297          /*!
    298           *  @brief      CAN 接收掩码配置
    299           *  @param      CANn_e          CAN 模块号
    300           *  @param      mb_num_e        缓冲区编号
    301           *  @param      mask            掩码
    302           *  @param      isIRMQ          是否选择独立掩码（0为全局掩码，其他为独立掩码）
    303           *  @since      v5.0
    304           *  Sample usage:      can_rxbuff_mask(CAN1,CAN_RX_MB,0x00FF,1);
    305           *                              //CAN1 的CAN_RX_MB 缓冲区 配置掩码为 0x00FF
    306           */
    307          

   \                                 In section .text, align 2, keep-with-next
    308          void can_rxbuff_mask(CANn_e cann, mb_num_e nMB, uint32 mask,uint8 isIRMQ)
    309          {
   \                     can_rxbuff_mask: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    310              uint8           bFreezeMode;
    311              CAN_MemMapPtr   canptr = CANN[cann];
   \   00000002   0x....             LDR.N    R5,??DataTable11_2
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0xF855 0x5020      LDR      R5,[R5, R0, LSL #+2]
    312          
    313              //进入冻结模式
    314              if(!(CAN_MCR_REG(canptr) & CAN_MCR_HALT_MASK))
   \   0000000A   0x682E             LDR      R6,[R5, #+0]
   \   0000000C   0x00F6             LSLS     R6,R6,#+3
   \   0000000E   0xD409             BMI.N    ??can_rxbuff_mask_0
    315              {
    316                  CAN_MCR_REG(canptr)  |= (CAN_MCR_HALT_MASK);
   \   00000010   0x682E             LDR      R6,[R5, #+0]
   \   00000012   0xF056 0x5680      ORRS     R6,R6,#0x10000000
   \   00000016   0x602E             STR      R6,[R5, #+0]
    317          
    318                  // 等待进入 进入冻结模式
    319                  while(!(CAN_MCR_REG(canptr) & CAN_MCR_FRZACK_MASK));
   \                     ??can_rxbuff_mask_1: (+1)
   \   00000018   0x682E             LDR      R6,[R5, #+0]
   \   0000001A   0x01F6             LSLS     R6,R6,#+7
   \   0000001C   0xD5FC             BPL.N    ??can_rxbuff_mask_1
    320          
    321                  bFreezeMode = 0;
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0x0034             MOVS     R4,R6
   \   00000022   0xE001             B.N      ??can_rxbuff_mask_2
    322              }
    323              else
    324              {
    325                  bFreezeMode = 1;
   \                     ??can_rxbuff_mask_0: (+1)
   \   00000024   0x2601             MOVS     R6,#+1
   \   00000026   0x0034             MOVS     R4,R6
    326              }
    327          
    328              if(isIRMQ != 0)       //使用独立掩码
   \                     ??can_rxbuff_mask_2: (+1)
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD009             BEQ.N    ??can_rxbuff_mask_3
    329              {
    330                  CAN_MCR_REG(canptr) |=  CAN_MCR_IRMQ_MASK;
   \   0000002E   0x682E             LDR      R6,[R5, #+0]
   \   00000030   0xF456 0x3680      ORRS     R6,R6,#0x10000
   \   00000034   0x602E             STR      R6,[R5, #+0]
    331          
    332                  // 独立掩码
    333                  CAN_RXIMR_REG(canptr, nMB) = mask;
   \   00000036   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   0xEB15 0x0681      ADDS     R6,R5,R1, LSL #+2
   \   0000003C   0xF8C6 0x2880      STR      R2,[R6, #+2176]
   \   00000040   0xE00E             B.N      ??can_rxbuff_mask_4
    334              }
    335              else
    336              {
    337                  CAN_MCR_REG(canptr) &=  ~CAN_MCR_IRMQ_MASK;
   \                     ??can_rxbuff_mask_3: (+1)
   \   00000042   0x682E             LDR      R6,[R5, #+0]
   \   00000044   0xF436 0x3680      BICS     R6,R6,#0x10000
   \   00000048   0x602E             STR      R6,[R5, #+0]
    338          
    339                  // 14/15 是使用独立的
    340                  if(nMB == MB_NUM_14)
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x290E             CMP      R1,#+14
   \   0000004E   0xD101             BNE.N    ??can_rxbuff_mask_5
    341                  {
    342                      CAN_RX14MASK_REG(canptr)  = mask;
   \   00000050   0x616A             STR      R2,[R5, #+20]
   \   00000052   0xE005             B.N      ??can_rxbuff_mask_4
    343                  }
    344                  else if (nMB == MB_NUM_15)
   \                     ??can_rxbuff_mask_5: (+1)
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0x290F             CMP      R1,#+15
   \   00000058   0xD101             BNE.N    ??can_rxbuff_mask_6
    345                  {
    346                      CAN_RX15MASK_REG(canptr)  = mask;
   \   0000005A   0x61AA             STR      R2,[R5, #+24]
   \   0000005C   0xE000             B.N      ??can_rxbuff_mask_4
    347                  }
    348                  else
    349                  {
    350                      // 剩余的支持全局掩码
    351                      CAN_RXMGMASK_REG(canptr)  = mask;
   \                     ??can_rxbuff_mask_6: (+1)
   \   0000005E   0x612A             STR      R2,[R5, #+16]
    352                  }
    353              }
    354              // 恢复CAN 操作模式
    355              if(!bFreezeMode)
   \                     ??can_rxbuff_mask_4: (+1)
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x2C00             CMP      R4,#+0
   \   00000064   0xD109             BNE.N    ??can_rxbuff_mask_7
    356              {
    357                  // De-assert Freeze Mode
    358                  CAN_MCR_REG(canptr)  &= ~ (CAN_MCR_HALT_MASK);
   \   00000066   0x682E             LDR      R6,[R5, #+0]
   \   00000068   0xF036 0x5680      BICS     R6,R6,#0x10000000
   \   0000006C   0x602E             STR      R6,[R5, #+0]
    359          
    360                  // Wait till exit of freeze mode
    361                  while( CAN_MCR_REG(canptr)  & CAN_MCR_FRZACK_MASK);
   \                     ??can_rxbuff_mask_8: (+1)
   \   0000006E   0x682E             LDR      R6,[R5, #+0]
   \   00000070   0x01F6             LSLS     R6,R6,#+7
   \   00000072   0xD4FC             BMI.N    ??can_rxbuff_mask_8
    362          
    363                  // Wait till ready
    364                  while( CAN_MCR_REG(canptr) & CAN_MCR_NOTRDY_MASK);
   \                     ??can_rxbuff_mask_9: (+1)
   \   00000074   0x682E             LDR      R6,[R5, #+0]
   \   00000076   0x0136             LSLS     R6,R6,#+4
   \   00000078   0xD4FC             BMI.N    ??can_rxbuff_mask_9
    365              }
    366          }
   \                     ??can_rxbuff_mask_7: (+1)
   \   0000007A   0xBC70             POP      {R4-R6}
   \   0000007C   0x4770             BX       LR               ;; return
    367          
    368          /*!
    369           *  @brief      CAN 接收数据
    370           *  @param      CANn_e          CAN 模块号
    371           *  @param      mb_num_e        缓冲区编号
    372           *  @param      CAN_USR_ID_t    ID编号
    373           *  @param      len             数据长度
    374           *  @param      buff            缓冲区地址
    375           *  @since      v5.0
    376           *  Sample usage:       can_rx(CAN1,CAN_RX_MB,&can_rx_id,&can_rx_len,can_rx_data);  //CAN 从 CAN_RX_MB 接收数据 ，接收到的 ID 保存在 can_rx_id 里，长度保存在 can_rx_len，数据保存在 can_rx_data
    377           */

   \                                 In section .text, align 2, keep-with-next
    378          void can_rx(CANn_e cann, mb_num_e nMB, CAN_USR_ID_t *id, uint8 *len, void   *buff)
    379          {
   \                     can_rx: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x9C05             LDR      R4,[SP, #+20]
    380              uint8  length;
    381              uint32 word;
    382          
    383              CAN_MemMapPtr canptr = CANN[cann];
   \   00000004   0x....             LDR.N    R7,??DataTable11_2
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0xF857 0x7020      LDR      R7,[R7, R0, LSL #+2]
    384          
    385              *(uint32 *)id = 0;
   \   0000000C   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000010   0xF8C2 0xC000      STR      R12,[R2, #+0]
    386          
    387              if((CAN_CS_REG(canptr, nMB)  & CAN_CS_CODE_MASK) != CAN_CS_CODE(CAN_CS_CODE_RX_FULL) ) //缓冲区没有接收到数据，返回错误
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   0000001A   0xF8DC 0xC080      LDR      R12,[R12, #+128]
   \   0000001E   0xF01C 0x6C70      ANDS     R12,R12,#0xF000000
   \   00000022   0xF1BC 0x7F00      CMP      R12,#+33554432
   \   00000026   0xD004             BEQ.N    ??can_rx_0
    388              {
    389                  *len = 0;
   \   00000028   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000002C   0xF883 0xC000      STRB     R12,[R3, #+0]
    390                  return;
   \   00000030   0xE061             B.N      ??can_rx_1
    391              }
    392          
    393              length = ( CAN_CS_REG(canptr, nMB) & CAN_CS_DLC_MASK ) >> CAN_CS_DLC_SHIFT;
   \                     ??can_rx_0: (+1)
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   00000038   0xF8DC 0xC080      LDR      R12,[R12, #+128]
   \   0000003C   0xEA5F 0x4C1C      LSRS     R12,R12,#+16
   \   00000040   0xF01C 0x0C0F      ANDS     R12,R12,#0xF
   \   00000044   0x4665             MOV      R5,R12
    394          
    395              if(length < 1) //接收到的数据长度小于1，返回错误
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD104             BNE.N    ??can_rx_2
    396              {
    397                  *len = 0;
   \   0000004C   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000050   0xF883 0xC000      STRB     R12,[R3, #+0]
    398                  return;
   \   00000054   0xE04F             B.N      ??can_rx_1
    399              }
    400          
    401              //判断是标准帧还是扩展帧
    402              if(! ( CAN_CS_REG(canptr, nMB) & CAN_CS_IDE_MASK ) )
   \                     ??can_rx_2: (+1)
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   0000005C   0xF8DC 0xC080      LDR      R12,[R12, #+128]
   \   00000060   0xEA5F 0x2C8C      LSLS     R12,R12,#+10
   \   00000064   0xD40D             BMI.N    ??can_rx_3
    403              {
    404                  id->ID = ( CAN_ID_REG(canptr, nMB) & CAN_ID_STD_MASK ) >> CAN_ID_STD_SHIFT; // 获得标准ID
   \   00000066   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   0000006C   0xF8DC 0xC084      LDR      R12,[R12, #+132]
   \   00000070   0xF3CC 0x4C8A      UBFX     R12,R12,#+18,#+11
   \   00000074   0xF8D2 0xE000      LDR      LR,[R2, #+0]
   \   00000078   0xF36C 0x0E1C      BFI      LR,R12,#+0,#+29
   \   0000007C   0xF8C2 0xE000      STR      LR,[R2, #+0]
   \   00000080   0xE014             B.N      ??can_rx_4
    405              }
    406              else
    407              {
    408                  id->ID = ( CAN_ID_REG(canptr, nMB) & CAN_ID_EXT_MASK ) >> CAN_ID_EXT_SHIFT; // 获取 扩展ID
   \                     ??can_rx_3: (+1)
   \   00000082   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000084   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   00000088   0xF8DC 0xC084      LDR      R12,[R12, #+132]
   \   0000008C   0xEA5F 0x3C8C      LSLS     R12,R12,#+14     ;; ZeroExtS R12,R12,#+14,#+14
   \   00000090   0xEA5F 0x3C9C      LSRS     R12,R12,#+14
   \   00000094   0xF8D2 0xE000      LDR      LR,[R2, #+0]
   \   00000098   0xF36C 0x0E1C      BFI      LR,R12,#+0,#+29
   \   0000009C   0xF8C2 0xE000      STR      LR,[R2, #+0]
    409                  id->IDE = 1 ; //标记扩展的ID
   \   000000A0   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \   000000A4   0xF05C 0x5C00      ORRS     R12,R12,#0x20000000
   \   000000A8   0xF8C2 0xC000      STR      R12,[R2, #+0]
    410              }
    411          
    412              if(CAN_CS_REG(canptr, nMB) & CAN_CS_RTR_MASK)
   \                     ??can_rx_4: (+1)
   \   000000AC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AE   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   000000B2   0xF8DC 0xC080      LDR      R12,[R12, #+128]
   \   000000B6   0xEA5F 0x2CCC      LSLS     R12,R12,#+11
   \   000000BA   0xD505             BPL.N    ??can_rx_5
    413              {
    414                  id->RTR = 1; //标记为远程帧类型
   \   000000BC   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \   000000C0   0xF05C 0x4C80      ORRS     R12,R12,#0x40000000
   \   000000C4   0xF8C2 0xC000      STR      R12,[R2, #+0]
    415              }
    416          
    417              word = CAN_WORD0_REG(canptr, nMB);
   \                     ??can_rx_5: (+1)
   \   000000C8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CA   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   000000CE   0xF8DC 0xC088      LDR      R12,[R12, #+136]
   \   000000D2   0x4666             MOV      R6,R12
    418              *((uint32 *)buff) = SWAP32(word);
   \   000000D4   0xFA96 0xFC86      REV      R12,R6
   \   000000D8   0xF8C4 0xC000      STR      R12,[R4, #+0]
    419          
    420              word = CAN_WORD1_REG(canptr, nMB);
   \   000000DC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DE   0xEB17 0x1C01      ADDS     R12,R7,R1, LSL #+4
   \   000000E2   0xF8DC 0xC08C      LDR      R12,[R12, #+140]
   \   000000E6   0x4666             MOV      R6,R12
    421              *((uint32 *)buff + 1) = SWAP32(word);
   \   000000E8   0xFA96 0xFC86      REV      R12,R6
   \   000000EC   0xF8C4 0xC004      STR      R12,[R4, #+4]
    422          
    423              *len = length;
   \   000000F0   0x701D             STRB     R5,[R3, #+0]
    424          
    425              CAN_TIMER_REG(canptr);      //解锁 MB
   \   000000F2   0xF8D7 0xC008      LDR      R12,[R7, #+8]
    426          }
   \                     ??can_rx_1: (+1)
   \   000000F6   0xBDF0             POP      {R4-R7,PC}       ;; return
    427          
    428          /*!
    429           *  @brief      使能 CAN 缓冲区接收和发送中断
    430           *  @param      CANn_e          CAN 模块号
    431           *  @param      mb_num_e        缓冲区编号
    432           *  @since      v5.0
    433           *  Sample usage:       can_irq_en(CAN1,MB_NUM_5);
    434           */

   \                                 In section .text, align 2, keep-with-next
    435          void can_irq_en(CANn_e cann, mb_num_e nMB)
    436          {
   \                     can_irq_en: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    437              CAN_MemMapPtr canptr = CANN[cann];
   \   00000006   0x....             LDR.N    R0,??DataTable11_2
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
    438          
    439          
    440              CAN_IMASK1_REG(canptr) = (1 << nMB);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x40A8             LSLS     R0,R0,R5
   \   00000012   0x62B0             STR      R0,[R6, #+40]
    441          
    442              if(cann == CAN0)
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD103             BNE.N    ??can_irq_en_0
    443              {
    444                  enable_irq(CAN0_ORed_MB_IRQn);
   \   0000001A   0x201D             MOVS     R0,#+29
   \   0000001C   0x.... 0x....      BL       NVIC_EnableIRQ
   \   00000020   0xE005             B.N      ??can_irq_en_1
    445              }
    446              else if(cann == CAN1)
   \                     ??can_irq_en_0: (+1)
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C01             CMP      R4,#+1
   \   00000026   0xD102             BNE.N    ??can_irq_en_1
    447              {
    448                  enable_irq(CAN1_ORed_MB_IRQn);
   \   00000028   0x2025             MOVS     R0,#+37
   \   0000002A   0x.... 0x....      BL       NVIC_EnableIRQ
    449              }
    450          }
   \                     ??can_irq_en_1: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    451          
    452          /*!
    453           *  @brief      禁止 CAN 缓冲区接收和发送中断
    454           *  @param      CANn_e          CAN 模块号
    455           *  @param      mb_num_e        缓冲区编号
    456           *  @since      v5.0
    457           *  Sample usage:       can_irq_dis(CAN1,MB_NUM_5);
    458           */

   \                                 In section .text, align 2, keep-with-next
    459          void can_irq_dis(CANn_e cann, mb_num_e nMB)
    460          {
   \                     can_irq_dis: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    461              CAN_MemMapPtr canptr = CANN[cann];
   \   00000006   0x....             LDR.N    R0,??DataTable11_2
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
    462          
    463              CAN_IMASK1_REG(canptr) &= ~ (1 << nMB);
   \   0000000E   0x6AB0             LDR      R0,[R6, #+40]
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x40A9             LSLS     R1,R1,R5
   \   00000014   0x4388             BICS     R0,R0,R1
   \   00000016   0x62B0             STR      R0,[R6, #+40]
    464          
    465              if(cann == CAN0)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD103             BNE.N    ??can_irq_dis_0
    466              {
    467                  disable_irq(CAN0_ORed_MB_IRQn);
   \   0000001E   0x201D             MOVS     R0,#+29
   \   00000020   0x.... 0x....      BL       NVIC_DisableIRQ
   \   00000024   0xE005             B.N      ??can_irq_dis_1
    468              }
    469              else if(cann == CAN1)
   \                     ??can_irq_dis_0: (+1)
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2C01             CMP      R4,#+1
   \   0000002A   0xD102             BNE.N    ??can_irq_dis_1
    470              {
    471                  disable_irq(CAN1_ORed_MB_IRQn);
   \   0000002C   0x2025             MOVS     R0,#+37
   \   0000002E   0x.... 0x....      BL       NVIC_DisableIRQ
    472              }
    473          }
   \                     ??can_irq_dis_1: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    474          
    475          /*!
    476           *  @brief      清 CAN 缓冲区中断标志
    477           *  @param      CANn_e          CAN 模块号
    478           *  @param      mb_num_e        缓冲区编号
    479           *  @since      v5.0
    480           *  Sample usage:       can_clear_flag(CAN1,MB_NUM_5);
    481           */

   \                                 In section .text, align 2, keep-with-next
    482          void can_clear_flag(CANn_e cann, mb_num_e nMB)
    483          {
    484              CAN_MemMapPtr canptr = CANN[cann];
   \                     can_clear_flag: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable11_2
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
    485          
    486              CAN_IFLAG1_REG(canptr) = (1 << nMB);
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x408B             LSLS     R3,R3,R1
   \   0000000C   0x6313             STR      R3,[R2, #+48]
    487          }
   \   0000000E   0x4770             BX       LR               ;; return
    488          
    489          
    490          /*!
    491           *  @brief      获得 CAN 缓冲区中断标志
    492           *  @param      CANn_e          CAN 模块号
    493           *  @param      mb_num_e        缓冲区编号
    494           *  @since      v5.0
    495           *  Sample usage:       can_get_flag(CAN1,MB_NUM_5);
    496           */

   \                                 In section .text, align 2, keep-with-next
    497          uint32 can_get_flag(CANn_e cann, mb_num_e nMB)
    498          {
   \                     can_get_flag: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    499              CAN_MemMapPtr canptr = CANN[cann];
   \   00000002   0x....             LDR.N    R0,??DataTable11_2
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
    500          
    501              return (CAN_IFLAG1_REG(canptr) & (1 << nMB));
   \   0000000A   0x6B00             LDR      R0,[R0, #+48]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0xFA13 0xF101      LSLS     R1,R3,R1
   \   00000012   0x4008             ANDS     R0,R1,R0
   \   00000014   0x4770             BX       LR               ;; return
    502          }
    503          
    504          
    505          /*!
    506           *  @brief      设置 CAN 的波特率
    507           *  @param      CANn_e          CAN 模块号
    508           *  @param      CAN_BAUD_e      波特率编号
    509           *  @since      v5.0
    510           *  Sample usage:       can_setband(CAN1, CAN_BAUD_20K)
    511           */

   \                                 In section .text, align 2, keep-with-next
    512          void can_setband(CANn_e cann, CAN_BAUD_e band)
    513          {
   \                     can_setband: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    514              CAN_MemMapPtr canptr = CANN[cann];
   \   00000008   0x....             LDR.N    R0,??DataTable11_2
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
    515              CAN_band_cfg_t *pcan_ban_cfg;
    516              uint32  can_clk_khz;
    517              uint8   bFreezeMode;
    518          
    519              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)     //bus时钟
   \   00000010   0x6870             LDR      R0,[R6, #+4]
   \   00000012   0x0480             LSLS     R0,R0,#+18
   \   00000014   0xD503             BPL.N    ??can_setband_0
    520              {
    521                  can_clk_khz =  bus_clk_khz;
   \   00000016   0x....             LDR.N    R0,??DataTable11_8
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x4680             MOV      R8,R0
   \   0000001C   0xE002             B.N      ??can_setband_1
    522              }
    523              else                                                //外部晶振时钟
    524              {
    525                  can_clk_khz = EXTAL_IN_MHz *1000;
   \                     ??can_setband_0: (+1)
   \   0000001E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000022   0x4680             MOV      R8,R0
    526              }
    527          
    528              if(can_clk_khz == 50000)
   \                     ??can_setband_1: (+1)
   \   00000024   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000028   0x4580             CMP      R8,R0
   \   0000002A   0xD106             BNE.N    ??can_setband_2
    529              {
    530                   pcan_ban_cfg = &can_band_cfg_50000K[band];
   \   0000002C   0x....             LDR.N    R0,??DataTable11_9
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x210C             MOVS     R1,#+12
   \   00000032   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000036   0x0007             MOVS     R7,R0
   \   00000038   0xE011             B.N      ??can_setband_3
    531              }
    532              else if(bus_clk_khz == 60000)
   \                     ??can_setband_2: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable11_8
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF64E 0x2160      MOVW     R1,#+60000
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD106             BNE.N    ??can_setband_4
    533              {
    534                   pcan_ban_cfg = &can_band_cfg_60000K[band];
   \   00000046   0x....             LDR.N    R0,??DataTable11_10
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x210C             MOVS     R1,#+12
   \   0000004C   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000050   0x0007             MOVS     R7,R0
   \   00000052   0xE004             B.N      ??can_setband_3
    535              }
    536              else
    537              {
    538                  ASSERT(0);          //仅支持 bus 时钟为 50M 或 60M
   \                     ??can_setband_4: (+1)
   \   00000054   0xF240 0x211A      MOVW     R1,#+538
   \   00000058   0x....             LDR.N    R0,??DataTable11_5
   \   0000005A   0x.... 0x....      BL       assert_failed
    539              }
    540          
    541              //进入冻结模式
    542              if(!(CAN_MCR_REG(canptr) & CAN_MCR_HALT_MASK))
   \                     ??can_setband_3: (+1)
   \   0000005E   0x6830             LDR      R0,[R6, #+0]
   \   00000060   0x00C0             LSLS     R0,R0,#+3
   \   00000062   0xD409             BMI.N    ??can_setband_5
    543              {
    544                  CAN_MCR_REG(canptr)  |= (CAN_MCR_HALT_MASK);
   \   00000064   0x6830             LDR      R0,[R6, #+0]
   \   00000066   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000006A   0x6030             STR      R0,[R6, #+0]
    545          
    546                  // 等待进入 进入冻结模式
    547                  while(!(CAN_MCR_REG(canptr) & CAN_MCR_FRZACK_MASK));
   \                     ??can_setband_6: (+1)
   \   0000006C   0x6830             LDR      R0,[R6, #+0]
   \   0000006E   0x01C0             LSLS     R0,R0,#+7
   \   00000070   0xD5FC             BPL.N    ??can_setband_6
    548          
    549                  bFreezeMode = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4681             MOV      R9,R0
   \   00000076   0xE001             B.N      ??can_setband_7
    550              }
    551              else
    552              {
    553                  bFreezeMode = 1;
   \                     ??can_setband_5: (+1)
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x4681             MOV      R9,R0
    554              }
    555          
    556              //清空需要配置的位
    557              CAN_CTRL1_REG(canptr) &= ~(0
    558                                         | CAN_CTRL1_PROPSEG_MASK
    559                                         | CAN_CTRL1_RJW_MASK
    560                                         | CAN_CTRL1_PSEG1_MASK
    561                                         | CAN_CTRL1_PSEG2_MASK
    562                                         | CAN_CTRL1_PRESDIV_MASK
    563                                         );
   \                     ??can_setband_7: (+1)
   \   0000007C   0x6870             LDR      R0,[R6, #+4]
   \   0000007E   0xF64F 0x71F8      MOVW     R1,#+65528
   \   00000082   0x4008             ANDS     R0,R1,R0
   \   00000084   0x6070             STR      R0,[R6, #+4]
    564              //设置波特率
    565              CAN_CTRL1_REG(canptr) |= (0
    566                                       | CAN_CTRL1_PROPSEG(pcan_ban_cfg->prop_seg)
    567                                       | CAN_CTRL1_RJW(pcan_ban_cfg->rjw)
    568                                       | CAN_CTRL1_PSEG1(pcan_ban_cfg->pseg1)
    569                                       | CAN_CTRL1_PSEG2(pcan_ban_cfg->pseg2)
    570                                       | CAN_CTRL1_PRESDIV(pcan_ban_cfg->presdiv)
    571                                      );
   \   00000086   0x6870             LDR      R0,[R6, #+4]
   \   00000088   0x79B9             LDRB     R1,[R7, #+6]
   \   0000008A   0xF011 0x0107      ANDS     R1,R1,#0x7
   \   0000008E   0x7A7A             LDRB     R2,[R7, #+9]
   \   00000090   0x0592             LSLS     R2,R2,#+22
   \   00000092   0xF412 0x0240      ANDS     R2,R2,#0xC00000
   \   00000096   0x4311             ORRS     R1,R2,R1
   \   00000098   0x79FA             LDRB     R2,[R7, #+7]
   \   0000009A   0x04D2             LSLS     R2,R2,#+19
   \   0000009C   0xF412 0x1260      ANDS     R2,R2,#0x380000
   \   000000A0   0x4311             ORRS     R1,R2,R1
   \   000000A2   0x7A3A             LDRB     R2,[R7, #+8]
   \   000000A4   0x0412             LSLS     R2,R2,#+16
   \   000000A6   0xF412 0x22E0      ANDS     R2,R2,#0x70000
   \   000000AA   0x4311             ORRS     R1,R2,R1
   \   000000AC   0x88BA             LDRH     R2,[R7, #+4]
   \   000000AE   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \   000000B2   0x4308             ORRS     R0,R1,R0
   \   000000B4   0x6070             STR      R0,[R6, #+4]
    572          
    573              // 恢复CAN 操作模式
    574              if(!bFreezeMode)
   \   000000B6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000BA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BE   0xD109             BNE.N    ??can_setband_8
    575              {
    576                  // De-assert Freeze Mode
    577                  CAN_MCR_REG(canptr)  &= ~ (CAN_MCR_HALT_MASK);
   \   000000C0   0x6830             LDR      R0,[R6, #+0]
   \   000000C2   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   000000C6   0x6030             STR      R0,[R6, #+0]
    578          
    579                  // Wait till exit of freeze mode
    580                  while( CAN_MCR_REG(canptr)  & CAN_MCR_FRZACK_MASK);
   \                     ??can_setband_9: (+1)
   \   000000C8   0x6830             LDR      R0,[R6, #+0]
   \   000000CA   0x01C0             LSLS     R0,R0,#+7
   \   000000CC   0xD4FC             BMI.N    ??can_setband_9
    581          
    582                  // Wait till ready
    583                  while( CAN_MCR_REG(canptr) & CAN_MCR_NOTRDY_MASK);
   \                     ??can_setband_10: (+1)
   \   000000CE   0x6830             LDR      R0,[R6, #+0]
   \   000000D0   0x0100             LSLS     R0,R0,#+4
   \   000000D2   0xD4FC             BMI.N    ??can_setband_10
    584              }
    585          }
   \                     ??can_setband_8: (+1)
   \   000000D4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     CANN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x1FFC0000         DC32     0x1ffc0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     can_band_cfg_50000K

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     can_band_cfg_60000K

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 53H, 74H, 75H, 64H, 79H
   \              0x5C 0x53    
   \              0x74 0x75    
   \              0x64 0x79    
   \   00000008   0x5C 0x32          DC8 5CH, 32H, 30H, 31H, 36H, 0B5H, 0E7H, 0D7H
   \              0x30 0x31    
   \              0x36 0xB5    
   \              0xE7 0xD7    
   \   00000010   0xD3 0xC9          DC8 0D3H, 0C9H, 0E8H, 0BCH, 0C6H, 0B4H, 0F3H, 0C8H
   \              0xE8 0xBC    
   \              0xC6 0xB4    
   \              0xF3 0xC8    
   \   00000018   0xFC 0x5C          DC8 0FCH, 5CH, 54H, 69H, 5CH, 0B5H, 0E7H, 0C8H
   \              0x54 0x69    
   \              0x5C 0xB5    
   \              0xE7 0xC8    
   \   00000020   0xFC 0xB1          DC8 0FCH, 0B1H, 0B8H, 0D3H, 0C3H, 0B5H, 0D7H, 0B2H
   \              0xB8 0xD3    
   \              0xC3 0xB5    
   \              0xD7 0xB2    
   \   00000028   0xE3 0x5C          DC8 0E3H, 5CH, 43H, 68H, 69H, 70H, 5CH, 73H
   \              0x43 0x68    
   \              0x69 0x70    
   \              0x5C 0x73    
   \   00000030   0x72 0x63          DC8 72H, 63H, 5CH, 4DH, 4BH, 36H, 30H, 5FH
   \              0x5C 0x4D    
   \              0x4B 0x36    
   \              0x30 0x5F    
   \   00000038   0x63 0x61          DC8 63H, 61H, 6EH, 2EH, 63H, 0
   \              0x6E 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0
    586          
    587          
    588          
    589          
    590          
    591          
    592          
    593          
    594          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       0   can_clear_flag
       0   can_get_flag
      32   can_init
        32   -> assert_failed
        32   -> can_setband
        32   -> port_init
      16   can_irq_dis
        16   -> NVIC_DisableIRQ
      16   can_irq_en
        16   -> NVIC_EnableIRQ
      20   can_rx
       8   can_rxbuff_enble
      12   can_rxbuff_mask
      32   can_setband
        32   -> assert_failed
      32   can_tx
        32   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      64  ?_0
       8  CANN
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      96  can_band_cfg_50000K
      96  can_band_cfg_60000K
      16  can_clear_flag
      22  can_get_flag
     442  can_init
      52  can_irq_dis
      48  can_irq_en
     248  can_rx
     114  can_rxbuff_enble
     126  can_rxbuff_mask
     216  can_setband
     216  can_tx

 
   200 bytes in section .data
    64 bytes in section .rodata
 1 588 bytes in section .text
 
 1 588 bytes of CODE  memory
    64 bytes of CONST memory
   200 bytes of DATA  memory

Errors: none
Warnings: none
