###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:28
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_i2c.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_i2c.c -D DEBUG
#        -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\MK60_i2c.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\MK60_i2c.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_i2c.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       MK60_i2c.c
     11           * @brief      i2c驱动函数
     12           * @author     山外科技
     13           * @version    v5.0
     14           * @date       2013-07-12
     15           */
     16          
     17          #include "common.h"
     18          #include "MK60_port.h"
     19          #include "MK60_i2c.h"
     20          

   \                                 In section .bss, align 1
     21          unsigned char MasterTransmission;
   \                     MasterTransmission:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     22          unsigned char SlaveID;
   \                     SlaveID:
   \   00000000                      DS8 1
     23          

   \                                 In section .data, align 4
     24          I2C_MemMapPtr I2CN[2] = {I2C0_BASE_PTR, I2C1_BASE_PTR}; //定义两个指针数组保存 I2CN 的地址
   \                     I2CN:
   \   00000000   0x40066000         DC32 40066000H, 40067000H
   \              0x40067000   
     25          
     26          
     27          /*
     28           *  把I2C通信的每个小步骤都用宏定义来实现，方便编写顶层函数
     29           *  此宏定义参考飞思卡尔公司例程修改所得
     30           */
     31          //启动信号
     32          #define i2c_Start(I2Cn)             I2C_C1_REG(I2CN[I2Cn]) |= (I2C_C1_TX_MASK | I2C_C1_MST_MASK)    //MST 由0变1，产生起始信号，TX = 1 进入发送模式
     33          
     34          //停止信号
     35          #define i2c_Stop(I2Cn)              I2C_C1_REG(I2CN[I2Cn]) &= ~(I2C_C1_MST_MASK | I2C_C1_TX_MASK)   //MST 由1变0，产生停止信号，TX = 0 进入接收模式
     36          
     37          //重复启动
     38          #define i2c_RepeatedStart(I2Cn)     I2C_C1_REG(I2CN[I2Cn]) |= I2C_C1_RSTA_MASK
     39          
     40          //进入接收模式(应答,需要接收多个数据，接收最后一个字节前需要禁用应答i2c_DisableAck)
     41          #define i2c_EnterRxMode(I2Cn)       I2C_C1_REG(I2CN[I2Cn]) &= ~(I2C_C1_TX_MASK | I2C_C1_TXAK_MASK)  //
     42          
     43          //进入接收模式(不应答,只接收一个字节)
     44          #define i2c_PutinRxMode(I2Cn)       I2C_C1_REG(I2CN[I2Cn]) &= ~I2C_C1_TX_MASK;I2C_C1_REG(I2CN[I2Cn]) |= I2C_C1_TXAK_MASK
     45          
     46          //禁用应答(接收最后一个字节)
     47          #define i2c_DisableAck(I2Cn)        I2C_C1_REG(I2CN[I2Cn]) |= I2C_C1_TXAK_MASK
     48          
     49          //等待 I2C_S
     50          #define i2c_Wait(I2Cn)              while(( I2C_S_REG(I2CN[I2Cn]) & I2C_S_IICIF_MASK)==0) {} \
     51                                              I2C_S_REG(I2CN[I2Cn]) |= I2C_S_IICIF_MASK;
     52          
     53          //写一个字节
     54          #define i2c_write_byte(I2Cn,data)   (I2C_D_REG(I2CN[I2Cn]) = (data));i2c_Wait(I2Cn)
     55          
     56          /*!
     57           *  @brief      I2C初始化，设置波特率
     58           *  @param      I2Cn_e      I2C模块(I2C0、I2C1)
     59           *  @param      baud        期待的波特率
     60           *  @return                 实际的波特率
     61           *  @since      v5.0
     62           *  Sample usage:       i2c_init(I2C0,400*1000);     // 初始化I2C0，期待的波特率为400k
     63           */

   \                                 In section .text, align 2, keep-with-next
     64          uint32 i2c_init(I2Cn_e i2cn, uint32 baud)
     65          {
   \                     i2c_init: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0A1             SUB      SP,SP,#+132
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
     66              if(i2cn == I2C0)
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD112             BNE.N    ??i2c_init_0
     67              {
     68                  /* 开启时钟 */
     69          #if defined(MK60DZ10)
     70                  SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;           //开启 I2C0时钟
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable3  ;; 0x40048034
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable3  ;; 0x40048034
   \   0000001E   0x6008             STR      R0,[R1, #+0]
     71          #elif defined( MK60F15)
     72                  SIM_SCGC4 |= SIM_SCGC4_IIC0_MASK;           //开启 I2C0时钟
     73          #endif
     74          
     75                  /* 配置 I2C0功能的 GPIO 接口 */
     76                  if((I2C0_SCL_PIN == PTB0) || (I2C0_SCL_PIN == PTB2) || (I2C0_SCL_PIN == PTD8) )
     77                  {
     78                      port_init (I2C0_SCL_PIN, ALT2 | ODO | PULLUP );
   \   00000020   0xF240 0x2123      MOVW     R1,#+547
   \   00000024   0x2068             MOVS     R0,#+104
   \   00000026   0x.... 0x....      BL       port_init
     79                  }
     80                  else
     81                      ASSERT(0);                              //上诉条件都不满足，直接断言失败了，设置管脚有误？
     82          
     83                  if((I2C0_SDA_PIN == PTB1) || (I2C0_SDA_PIN == PTB3) || (I2C0_SDA_PIN == PTD9) )
     84                      port_init (I2C0_SDA_PIN, ALT2 | ODO | PULLUP );
   \   0000002A   0xF240 0x2123      MOVW     R1,#+547
   \   0000002E   0x2069             MOVS     R0,#+105
   \   00000030   0x.... 0x....      BL       port_init
   \   00000034   0xE011             B.N      ??i2c_init_1
     85                  else
     86                      ASSERT(0);                              //上诉条件都不满足，直接断言失败了，设置管脚有误？
     87              }
     88              else
     89              {
     90                  /* 开启时钟 */
     91          #if defined(MK60DZ10)
     92                  SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK;           //开启 I2C1时钟
   \                     ??i2c_init_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable3  ;; 0x40048034
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable3  ;; 0x40048034
   \   00000044   0x6008             STR      R0,[R1, #+0]
     93          #elif defined(MK60F15)
     94                  SIM_SCGC4 |= SIM_SCGC4_IIC1_MASK;           //开启 I2C1时钟
     95          #endif
     96                  /* 配置 I2C1功能的 GPIO 接口 */
     97                  if(I2C1_SCL_PIN == PTE1)
     98                      port_init (I2C1_SCL_PIN, ALT6 | ODO | PULLUP );
     99                  else if(I2C1_SCL_PIN == PTC10)
    100                      port_init (I2C1_SCL_PIN, ALT2 | ODO | PULLUP );
   \   00000046   0xF240 0x2123      MOVW     R1,#+547
   \   0000004A   0x204A             MOVS     R0,#+74
   \   0000004C   0x.... 0x....      BL       port_init
    101                  else
    102                      ASSERT(0);                          //上诉条件都不满足，直接断言失败了，设置管脚有误？
    103          
    104                  if(I2C1_SDA_PIN == PTE0)
    105                      port_init (I2C1_SDA_PIN, ALT6 | ODO | PULLUP );
    106                  else if (I2C1_SDA_PIN == PTC11)
    107                      port_init (I2C1_SDA_PIN, ALT2 | ODO | PULLUP );
   \   00000050   0xF240 0x2123      MOVW     R1,#+547
   \   00000054   0x204B             MOVS     R0,#+75
   \   00000056   0x.... 0x....      BL       port_init
    108                  else
    109                      ASSERT(0);                          //上诉条件都不满足，直接断言失败了，设置管脚有误？
    110              }
    111          
    112              /* 设置频率 */
    113          
    114              // I2C baud rate = bus speed (Hz)/(mul × SCL divider)  即这里 50MHz/(1 ×128)=390.625kHz
    115              // SDA hold time = bus period (s) × mul × SDA hold value
    116              // SCL start hold time = bus period (s) × mul × SCL start hold value
    117              // SCL stop hold time = bus period (s) × mul × SCL stop hold value
    118          
    119              //查表 ICR 对应的  SCL_divider ，见 《K60P144M100SF2RM.pdf》第1468页的 I2C Divider and Hold Values
    120              uint16 ICR_2_SCL_divider[0x40]  =
    121              {
    122                  20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68,
    123                  48, 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240,
    124                  160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576, 640, 768, 960,
    125                  640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840
    126              };
   \                     ??i2c_init_1: (+1)
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable3_1
   \   00000060   0x2280             MOVS     R2,#+128
   \   00000062   0x.... 0x....      BL       __aeabi_memcpy4
    127          
    128              uint8 mult;
    129              if(bus_clk_khz <= 50000)mult = 0;         //bus 一分频
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF24C 0x3151      MOVW     R1,#+50001
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xDA02             BGE.N    ??i2c_init_2
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x0006             MOVS     R6,R0
   \   00000078   0xE00B             B.N      ??i2c_init_3
    130              else  if(bus_clk_khz <= 100000)mult = 1;  //bus 二分频
   \                     ??i2c_init_2: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable3_3  ;; 0x186a1
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xDA02             BGE.N    ??i2c_init_4
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x0006             MOVS     R6,R0
   \   0000008C   0xE001             B.N      ??i2c_init_3
    131              else      mult = 2;                       //bus 四分频
   \                     ??i2c_init_4: (+1)
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0x0006             MOVS     R6,R0
    132          
    133              uint16 scldiv =  bus_clk_khz * 1000 / ( (1<<mult) * baud );  //最佳的分频系数
   \                     ??i2c_init_3: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF44F 0x717A      MOV      R1,#+1000
   \   0000009C   0x4348             MULS     R0,R1,R0
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x40B1             LSLS     R1,R1,R6
   \   000000A2   0x4369             MULS     R1,R5,R1
   \   000000A4   0xFBB0 0xF7F1      UDIV     R7,R0,R1
    134          
    135              //需要从 ICR_2_SCL_divider 里找到 与最佳分频系数scldiv最相近的 分频系数
    136              uint8 icr, n = 0x40;
   \   000000A8   0xF05F 0x0B40      MOVS     R11,#+64
    137              uint16 min_Dvalue = ~0, Dvalue;
   \   000000AC   0xF64F 0x7AFF      MOVW     R10,#+65535
    138          
    139              while(n)                                            //循环里逐个扫描，找出最接近的 分频系数
   \                     ??i2c_init_5: (+1)
   \   000000B0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B4   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000B8   0xD01B             BEQ.N    ??i2c_init_6
    140              {
    141                  n--;
   \   000000BA   0xF1BB 0x0B01      SUBS     R11,R11,#+1
    142                  Dvalue = abs(scldiv - ICR_2_SCL_divider[n]);
   \   000000BE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C0   0xA800             ADD      R0,SP,#+0
   \   000000C2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C6   0xF830 0x001B      LDRH     R0,[R0, R11, LSL #+1]
   \   000000CA   0x1A38             SUBS     R0,R7,R0
   \   000000CC   0x.... 0x....      BL       abs
   \   000000D0   0x4681             MOV      R9,R0
    143                  if(Dvalue == 0)
   \   000000D2   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000D6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000DA   0xD101             BNE.N    ??i2c_init_7
    144                  {
    145                      icr = n;
   \   000000DC   0x46D8             MOV      R8,R11
    146                      break;                                      //退出while循环
   \   000000DE   0xE008             B.N      ??i2c_init_6
    147                  }
    148          
    149                  if(Dvalue < min_Dvalue)
   \                     ??i2c_init_7: (+1)
   \   000000E0   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000E4   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000E8   0x45D1             CMP      R9,R10
   \   000000EA   0xD2E1             BCS.N    ??i2c_init_5
    150                  {
    151                      icr = n;
   \   000000EC   0x46D8             MOV      R8,R11
    152                      min_Dvalue = Dvalue;
   \   000000EE   0x46CA             MOV      R10,R9
   \   000000F0   0xE7DE             B.N      ??i2c_init_5
    153                  }
    154              }
    155          
    156              I2C_F_REG(I2CN[i2cn])  = ( 0                        // I2C Frequency Divider register (I2Cx_F)  I2C分频寄存器   I2C最大波特率为 400k
    157                                         | I2C_F_MULT(mult)        // 乘数因子 mul =  1<<MULT
    158                                         | I2C_F_ICR(icr)          // 时钟速率 = ICR_2_SCL_divider[ICR] ，查表获得 ICR 与 SCL_divider 映射关系
    159                                       );
   \                     ??i2c_init_6: (+1)
   \   000000F2   0xF018 0x003F      ANDS     R0,R8,#0x3F
   \   000000F6   0xEA50 0x1086      ORRS     R0,R0,R6, LSL #+6
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable3_4
   \   000000FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000104   0x7048             STRB     R0,[R1, #+1]
    160          
    161              /* 使能 I2C */
    162              I2C_C1_REG(I2CN[i2cn]) = ( 0
    163                                         | I2C_C1_IICEN_MASK       //使能I2C
    164                                         //| I2C_C1_IICIE_MASK       //使能中断
    165                                       );
   \   00000106   0x2080             MOVS     R0,#+128
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable3_4
   \   0000010C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000112   0x7088             STRB     R0,[R1, #+2]
    166          
    167              return (  bus_clk_khz * 1000 / ( (1<<mult) * ICR_2_SCL_divider[icr])  );
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000011E   0x4348             MULS     R0,R1,R0
   \   00000120   0x2101             MOVS     R1,#+1
   \   00000122   0x40B1             LSLS     R1,R1,R6
   \   00000124   0xAA00             ADD      R2,SP,#+0
   \   00000126   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000012A   0xF832 0x2018      LDRH     R2,[R2, R8, LSL #+1]
   \   0000012E   0x4351             MULS     R1,R2,R1
   \   00000130   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000134   0xB021             ADD      SP,SP,#+132
   \   00000136   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    168          }
    169          
    170          
    171          /*!
    172           *  @brief      I2C通信结束后需要调用的函数函数
    173           *  @since      v5.0
    174           *  @note       如果通信失败，可尝试增大此延时值，确认是否延时导致的
    175           */

   \                                 In section .text, align 4, keep-with-next
    176          void i2c_delay(void)
    177          {
   \                     i2c_delay: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    178              volatile uint16 n = 80;     //注意，这个数据太小，会导致读取错误。
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    179          
    180              while(n--)
   \                     ??i2c_delay_0: (+1)
   \   00000008   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000000C   0x1E41             SUBS     R1,R0,#+1
   \   0000000E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??i2c_delay_1
    181              {
    182                  asm("nop");
   \   00000018   0xBF00             nop
   \   0000001A   0xE7F5             B.N      ??i2c_delay_0
    183              }
    184          }
   \                     ??i2c_delay_1: (+1)
   \   0000001C   0xB001             ADD      SP,SP,#+4
   \   0000001E   0x4770             BX       LR               ;; return
    185          
    186          /*!
    187           *  @brief      读取I2C设备指定地址寄存器的数据
    188           *  @param      I2Cn_e        I2C模块(I2C0、I2C1)
    189           *  @param      SlaveID     从机地址(7位地址)
    190           *  @param      reg         从机寄存器地址
    191           *  @return                 读取的寄存器值
    192           *  @since      v5.0
    193           *  Sample usage:       uint8 value = i2c_read_reg(I2C0, 0x1D, 1);
    194           */

   \                                 In section .text, align 2, keep-with-next
    195          uint8 i2c_read_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg)
    196          {
   \                     i2c_read_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    197          
    198              //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    199              uint8 result;
    200          
    201              ASSERT((SlaveID & 0x80) == 0);                      //断言，我们要求的7位地址的值仅仅是7bit,不是通信时要求的高7位
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD503             BPL.N    ??i2c_read_reg_0
   \   0000000C   0x21C9             MOVS     R1,#+201
   \   0000000E   0x....             LDR.N    R0,??DataTable3_5
   \   00000010   0x.... 0x....      BL       assert_failed
    202              //有些手册，给出的7位地址指的是8bit里的高7位
    203              //有些手册，给出的7位地址指的是7bit
    204              //请自行确认，可以尝试是否通信正常来确认
    205          
    206              i2c_Start(i2cn);                                    //发送启动信号
   \                     ??i2c_read_reg_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable3_4
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001C   0x7880             LDRB     R0,[R0, #+2]
   \   0000001E   0xF050 0x0030      ORRS     R0,R0,#0x30
   \   00000022   0x....             LDR.N    R1,??DataTable3_4
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000002A   0x7088             STRB     R0,[R1, #+2]
    207          
    208              i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
   \   0000002C   0x0068             LSLS     R0,R5,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable3_4
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000036   0x7108             STRB     R0,[R1, #+4]
   \                     ??i2c_read_reg_1: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable3_4
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000040   0x78C0             LDRB     R0,[R0, #+3]
   \   00000042   0x0780             LSLS     R0,R0,#+30
   \   00000044   0xD5F8             BPL.N    ??i2c_read_reg_1
   \   00000046   0x....             LDR.N    R0,??DataTable3_4
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000004E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000054   0x....             LDR.N    R1,??DataTable3_4
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000005C   0x70C8             STRB     R0,[R1, #+3]
    209          
    210              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   0000005E   0x....             LDR.N    R0,??DataTable3_4
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000066   0x7106             STRB     R6,[R0, #+4]
   \                     ??i2c_read_reg_2: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable3_4
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000070   0x78C0             LDRB     R0,[R0, #+3]
   \   00000072   0x0780             LSLS     R0,R0,#+30
   \   00000074   0xD5F8             BPL.N    ??i2c_read_reg_2
   \   00000076   0x....             LDR.N    R0,??DataTable3_4
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000007E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000080   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000084   0x....             LDR.N    R1,??DataTable3_4
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000008C   0x70C8             STRB     R0,[R1, #+3]
    211          
    212              i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
   \   0000008E   0x....             LDR.N    R0,??DataTable3_4
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000096   0x7880             LDRB     R0,[R0, #+2]
   \   00000098   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000009C   0x....             LDR.N    R1,??DataTable3_4
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000A4   0x7088             STRB     R0,[R1, #+2]
    213          
    214              i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
   \   000000A6   0x0068             LSLS     R0,R5,#+1
   \   000000A8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000AC   0x....             LDR.N    R1,??DataTable3_4
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000B4   0x7108             STRB     R0,[R1, #+4]
   \                     ??i2c_read_reg_3: (+1)
   \   000000B6   0x....             LDR.N    R0,??DataTable3_4
   \   000000B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BA   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000BE   0x78C0             LDRB     R0,[R0, #+3]
   \   000000C0   0x0780             LSLS     R0,R0,#+30
   \   000000C2   0xD5F8             BPL.N    ??i2c_read_reg_3
   \   000000C4   0x....             LDR.N    R0,??DataTable3_4
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000CC   0x78C0             LDRB     R0,[R0, #+3]
   \   000000CE   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000D2   0x....             LDR.N    R1,??DataTable3_4
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000DA   0x70C8             STRB     R0,[R1, #+3]
    215          
    216              i2c_PutinRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
   \   000000DC   0x....             LDR.N    R0,??DataTable3_4
   \   000000DE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E0   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000E4   0x7880             LDRB     R0,[R0, #+2]
   \   000000E6   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   000000EA   0x....             LDR.N    R1,??DataTable3_4
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000F2   0x7088             STRB     R0,[R1, #+2]
   \   000000F4   0x....             LDR.N    R0,??DataTable3_4
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000FC   0x7880             LDRB     R0,[R0, #+2]
   \   000000FE   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000102   0x....             LDR.N    R1,??DataTable3_4
   \   00000104   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000106   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000010A   0x7088             STRB     R0,[R1, #+2]
    217              result = I2C_D_REG(I2CN[i2cn]);                     //虚假读取一次，启动接收数据
   \   0000010C   0x....             LDR.N    R0,??DataTable3_4
   \   0000010E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000110   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000114   0x7900             LDRB     R0,[R0, #+4]
   \   00000116   0x0007             MOVS     R7,R0
    218              i2c_Wait(i2cn);                                     //等待接收完成
   \                     ??i2c_read_reg_4: (+1)
   \   00000118   0x....             LDR.N    R0,??DataTable3_4
   \   0000011A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000120   0x78C0             LDRB     R0,[R0, #+3]
   \   00000122   0x0780             LSLS     R0,R0,#+30
   \   00000124   0xD5F8             BPL.N    ??i2c_read_reg_4
   \   00000126   0x....             LDR.N    R0,??DataTable3_4
   \   00000128   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000012E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000130   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000134   0x....             LDR.N    R1,??DataTable3_4
   \   00000136   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000138   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000013C   0x70C8             STRB     R0,[R1, #+3]
    219          
    220              i2c_Stop(i2cn);                                     //发送停止信号
   \   0000013E   0x....             LDR.N    R0,??DataTable3_4
   \   00000140   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000142   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000146   0x7880             LDRB     R0,[R0, #+2]
   \   00000148   0xF010 0x00CF      ANDS     R0,R0,#0xCF
   \   0000014C   0x....             LDR.N    R1,??DataTable3_4
   \   0000014E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000150   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000154   0x7088             STRB     R0,[R1, #+2]
    221          
    222              result = I2C_D_REG(I2CN[i2cn]);                     //读取数据
   \   00000156   0x....             LDR.N    R0,??DataTable3_4
   \   00000158   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000015E   0x7900             LDRB     R0,[R0, #+4]
   \   00000160   0x0007             MOVS     R7,R0
    223          
    224              i2c_delay();                                        //必须延时一下，否则出错
   \   00000162   0x.... 0x....      BL       i2c_delay
    225          
    226              return result;
   \   00000166   0x0038             MOVS     R0,R7
   \   00000168   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    227          }
    228          
    229          
    230          /*!
    231           *  @brief      写入一个字节数据到I2C设备指定寄存器地址
    232           *  @param      I2Cn_e        I2C模块(I2C0、I2C1)
    233           *  @param      SlaveID     从机地址(7位地址)
    234           *  @param      reg         从机寄存器地址
    235           *  @param      Data        数据
    236           *  @since      v5.0
    237           *  Sample usage:       i2c_write_reg(I2C0, 0x1D, 1,2);     //向从机0x1D 的寄存器 1 写入数据 2
    238           */
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void i2c_write_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 Data)
    241          {
   \                     i2c_write_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    242          
    243              i2c_Start(i2cn);                                    //发送启动信号
   \   0000000A   0x....             LDR.N    R0,??DataTable3_4
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000012   0x7880             LDRB     R0,[R0, #+2]
   \   00000014   0xF050 0x0030      ORRS     R0,R0,#0x30
   \   00000018   0x....             LDR.N    R1,??DataTable3_4
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000020   0x7088             STRB     R0,[R1, #+2]
    244          
    245              i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
   \   00000022   0x0068             LSLS     R0,R5,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable3_4
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000002C   0x7108             STRB     R0,[R1, #+4]
   \                     ??i2c_write_reg_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable3_4
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000036   0x78C0             LDRB     R0,[R0, #+3]
   \   00000038   0x0780             LSLS     R0,R0,#+30
   \   0000003A   0xD5F8             BPL.N    ??i2c_write_reg_0
   \   0000003C   0x....             LDR.N    R0,??DataTable3_4
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000044   0x78C0             LDRB     R0,[R0, #+3]
   \   00000046   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004A   0x....             LDR.N    R1,??DataTable3_4
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000052   0x70C8             STRB     R0,[R1, #+3]
    246          
    247              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   00000054   0x....             LDR.N    R0,??DataTable3_4
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000005C   0x7106             STRB     R6,[R0, #+4]
   \                     ??i2c_write_reg_1: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable3_4
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000066   0x78C0             LDRB     R0,[R0, #+3]
   \   00000068   0x0780             LSLS     R0,R0,#+30
   \   0000006A   0xD5F8             BPL.N    ??i2c_write_reg_1
   \   0000006C   0x....             LDR.N    R0,??DataTable3_4
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000074   0x78C0             LDRB     R0,[R0, #+3]
   \   00000076   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000007A   0x....             LDR.N    R1,??DataTable3_4
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000082   0x70C8             STRB     R0,[R1, #+3]
    248          
    249              i2c_write_byte(i2cn, Data);                         //发送需要写入的数据
   \   00000084   0x....             LDR.N    R0,??DataTable3_4
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000008C   0x7107             STRB     R7,[R0, #+4]
   \                     ??i2c_write_reg_2: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable3_4
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000096   0x78C0             LDRB     R0,[R0, #+3]
   \   00000098   0x0780             LSLS     R0,R0,#+30
   \   0000009A   0xD5F8             BPL.N    ??i2c_write_reg_2
   \   0000009C   0x....             LDR.N    R0,??DataTable3_4
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000A4   0x78C0             LDRB     R0,[R0, #+3]
   \   000000A6   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000AA   0x....             LDR.N    R1,??DataTable3_4
   \   000000AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AE   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000B2   0x70C8             STRB     R0,[R1, #+3]
    250          
    251              i2c_Stop(i2cn);
   \   000000B4   0x....             LDR.N    R0,??DataTable3_4
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000BC   0x7880             LDRB     R0,[R0, #+2]
   \   000000BE   0xF010 0x00CF      ANDS     R0,R0,#0xCF
   \   000000C2   0x....             LDR.N    R1,??DataTable3_4
   \   000000C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C6   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000CA   0x7088             STRB     R0,[R1, #+2]
    252          
    253              i2c_delay();                                        //延时太短的话，可能写出错
   \   000000CC   0x.... 0x....      BL       i2c_delay
    254          }
   \   000000D0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    255          void i2c_write_lendata(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 *ptr, uint8 len)
    256          {
   \                     i2c_write_lendata: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
    257          
    258              i2c_Start(i2cn);                                    //发送启动信号
   \   0000000E   0x....             LDR.N    R0,??DataTable3_4
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000016   0x7880             LDRB     R0,[R0, #+2]
   \   00000018   0xF050 0x0030      ORRS     R0,R0,#0x30
   \   0000001C   0x....             LDR.N    R1,??DataTable3_4
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   00000024   0x7088             STRB     R0,[R1, #+2]
    259          
    260              i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
   \   00000026   0x0070             LSLS     R0,R6,#+1
   \   00000028   0x....             LDR.N    R1,??DataTable3_4
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   00000030   0x7108             STRB     R0,[R1, #+4]
   \                     ??i2c_write_lendata_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable3_4
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000003A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000003C   0x0780             LSLS     R0,R0,#+30
   \   0000003E   0xD5F8             BPL.N    ??i2c_write_lendata_0
   \   00000040   0x....             LDR.N    R0,??DataTable3_4
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000048   0x78C0             LDRB     R0,[R0, #+3]
   \   0000004A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004E   0x....             LDR.N    R1,??DataTable3_4
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   00000056   0x70C8             STRB     R0,[R1, #+3]
    261          
    262              i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址
   \   00000058   0x....             LDR.N    R0,??DataTable3_4
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000060   0x7107             STRB     R7,[R0, #+4]
   \                     ??i2c_write_lendata_1: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable3_4
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000006A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000006C   0x0780             LSLS     R0,R0,#+30
   \   0000006E   0xD5F8             BPL.N    ??i2c_write_lendata_1
   \   00000070   0x....             LDR.N    R0,??DataTable3_4
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000078   0x78C0             LDRB     R0,[R0, #+3]
   \   0000007A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000007E   0x....             LDR.N    R1,??DataTable3_4
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   00000086   0x70C8             STRB     R0,[R1, #+3]
    263          
    264              for(;len > 0;len--)
   \                     ??i2c_write_lendata_2: (+1)
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD01D             BEQ.N    ??i2c_write_lendata_3
    265              {
    266                i2c_write_byte(i2cn, *ptr++);                         //发送需要写入的数据
   \   0000008E   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000092   0x....             LDR.N    R1,??DataTable3_4
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   0000009A   0x7108             STRB     R0,[R1, #+4]
   \   0000009C   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??i2c_write_lendata_4: (+1)
   \   000000A0   0x....             LDR.N    R0,??DataTable3_4
   \   000000A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A4   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000000A8   0x78C0             LDRB     R0,[R0, #+3]
   \   000000AA   0x0780             LSLS     R0,R0,#+30
   \   000000AC   0xD5F8             BPL.N    ??i2c_write_lendata_4
   \   000000AE   0x....             LDR.N    R0,??DataTable3_4
   \   000000B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B2   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000000B6   0x78C0             LDRB     R0,[R0, #+3]
   \   000000B8   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000BC   0x....             LDR.N    R1,??DataTable3_4
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   000000C4   0x70C8             STRB     R0,[R1, #+3]
    267              }
   \   000000C6   0x1E64             SUBS     R4,R4,#+1
   \   000000C8   0xE7DE             B.N      ??i2c_write_lendata_2
    268              i2c_Stop(i2cn);
   \                     ??i2c_write_lendata_3: (+1)
   \   000000CA   0x....             LDR.N    R0,??DataTable3_4
   \   000000CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CE   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000000D2   0x7880             LDRB     R0,[R0, #+2]
   \   000000D4   0xF010 0x00CF      ANDS     R0,R0,#0xCF
   \   000000D8   0x....             LDR.N    R1,??DataTable3_4
   \   000000DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DC   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   000000E0   0x7088             STRB     R0,[R1, #+2]
    269          
    270              i2c_delay();                                        //延时太短的话，可能写出错
   \   000000E2   0x.... 0x....      BL       i2c_delay
    271          }
   \   000000E6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     I2CN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 53H, 74H, 75H, 64H, 79H
   \              0x5C 0x53    
   \              0x74 0x75    
   \              0x64 0x79    
   \   00000008   0x5C 0x32          DC8 5CH, 32H, 30H, 31H, 36H, 0B5H, 0E7H, 0D7H
   \              0x30 0x31    
   \              0x36 0xB5    
   \              0xE7 0xD7    
   \   00000010   0xD3 0xC9          DC8 0D3H, 0C9H, 0E8H, 0BCH, 0C6H, 0B4H, 0F3H, 0C8H
   \              0xE8 0xBC    
   \              0xC6 0xB4    
   \              0xF3 0xC8    
   \   00000018   0xFC 0x5C          DC8 0FCH, 5CH, 54H, 69H, 5CH, 0B5H, 0E7H, 0C8H
   \              0x54 0x69    
   \              0x5C 0xB5    
   \              0xE7 0xC8    
   \   00000020   0xFC 0xB1          DC8 0FCH, 0B1H, 0B8H, 0D3H, 0C3H, 0B5H, 0D7H, 0B2H
   \              0xB8 0xD3    
   \              0xC3 0xB5    
   \              0xD7 0xB2    
   \   00000028   0xE3 0x5C          DC8 0E3H, 5CH, 43H, 68H, 69H, 70H, 5CH, 73H
   \              0x43 0x68    
   \              0x69 0x70    
   \              0x5C 0x73    
   \   00000030   0x72 0x63          DC8 72H, 63H, 5CH, 4DH, 4BH, 36H, 30H, 5FH
   \              0x5C 0x4D    
   \              0x4B 0x36    
   \              0x30 0x5F    
   \   00000038   0x69 0x32          DC8 69H, 32H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x0014 0x0016      DC16 20, 22, 24, 26, 28, 30, 34, 40, 28, 32, 36, 40, 44, 48, 56, 68, 48
   \              0x0018 0x001A
   \              0x001C 0x001E
   \              0x0022 0x0028
   \              0x001C 0x0020
   \              0x0024 0x0028
   \              0x002C 0x0030
   \              0x0038 0x0044
   \              0x0030       
   \   00000022   0x0038 0x0040      DC16 56, 64, 72, 80, 88, 104, 128, 80, 96, 112, 128, 144, 160, 192, 240
   \              0x0048 0x0050
   \              0x0058 0x0068
   \              0x0080 0x0050
   \              0x0060 0x0070
   \              0x0080 0x0090
   \              0x00A0 0x00C0
   \              0x00F0       
   \   00000040   0x00A0 0x00C0      DC16 160, 192, 224, 256, 288, 320, 384, 480, 320, 384, 448, 512, 576
   \              0x00E0 0x0100
   \              0x0120 0x0140
   \              0x0180 0x01E0
   \              0x0140 0x0180
   \              0x01C0 0x0200
   \              0x0240       
   \   0000005A   0x0280 0x0300      DC16 640, 768, 960, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280
   \              0x03C0 0x0280
   \              0x0300 0x0380
   \              0x0400 0x0480
   \              0x0500 0x0600
   \              0x0780 0x0500
   \   00000072   0x0600 0x0700      DC16 1536, 1792, 2048, 2304, 2560, 3072, 3840
   \              0x0800 0x0900
   \              0x0A00 0x0C00
   \              0x0F00       
    272          
    273          //uint8 i2c_read_reg(I2Cn_e i2cn, uint8 SlaveID, uint8 reg, uint8 *ptr, uint8 len)
    274          //{
    275          //
    276          //    //先写入寄存器地址,再读取数据,因此此过程是 I2C 的复合格式,改变数据方向时需要重新启动
    277          //    uint8 result;
    278          //
    279          //    ASSERT((SlaveID & 0x80) == 0);                      //断言，我们要求的7位地址的值仅仅是7bit,不是通信时要求的高7位
    280          //    //有些手册，给出的7位地址指的是8bit里的高7位
    281          //    //有些手册，给出的7位地址指的是7bit
    282          //    //请自行确认，可以尝试是否通信正常来确认
    283          //
    284          //    i2c_Start(i2cn);                                    //发送启动信号
    285          //
    286          //    i2c_write_byte(i2cn, ( SlaveID << 1 ) | MWSR);      //发送从机地址和写位
    287          //
    288          //    i2c_write_byte(i2cn, reg);                          //发送从机里的寄存器地址    i2c_RepeatedStart(i2cn);
    289          //    
    290          //    i2c_RepeatedStart(i2cn);                            //复合格式，发送重新启动信号
    291          //
    292          //    i2c_write_byte(i2cn, ( SlaveID << 1) | MRSW );      //发送从机地址和读位
    293          //
    294          //    for{;len > 1;len--}
    295          //    {
    296          //    
    297          //    
    298          //    
    299          //    *ptr++= I2C_D_REG(I2CN[i2cn]);}
    300          //    i2c_Wait(i2cn);  
    301          //    }
    302              
    303              
    304          //
    305          //    i2c_PutinRxMode(i2cn);                              //进入接收模式(不应答,只接收一个字节)
    306          //    result = I2C_D_REG(I2CN[i2cn]);                     //虚假读取一次，启动接收数据
    307          //    i2c_Wait(i2cn);                                     //等待接收完成
    308          //
    309          //    i2c_Stop(i2cn);                                     //发送停止信号
    310          //
    311          //    result = I2C_D_REG(I2CN[i2cn]);                     //读取数据
    312          //
    313          //    i2c_delay();                                        //必须延时一下，否则出错
    314          //
    315          //    return result;
    316          //}

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   i2c_delay
     168   i2c_init
       168   -> __aeabi_memcpy4
       168   -> abs
       168   -> port_init
      24   i2c_read_reg
        24   -> assert_failed
        24   -> i2c_delay
      24   i2c_write_lendata
        24   -> i2c_delay
      24   i2c_write_reg
        24   -> i2c_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
      64  ?_0
     128  ?_1
       8  I2CN
       1  MasterTransmission
       1  SlaveID
      32  i2c_delay
     314  i2c_init
     364  i2c_read_reg
     234  i2c_write_lendata
     210  i2c_write_reg

 
     2 bytes in section .bss
     8 bytes in section .data
   192 bytes in section .rodata
 1 178 bytes in section .text
 
 1 178 bytes of CODE  memory
   192 bytes of CONST memory
    10 bytes of DATA  memory

Errors: none
Warnings: none
