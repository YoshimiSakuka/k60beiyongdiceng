###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        26/Jul/2016  23:31:18
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\VCAN_SCCB.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\VCAN_SCCB.c -D
#        DEBUG -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\VCAN_SCCB.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\VCAN_SCCB.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\VCAN_SCCB.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       VCAN_SCCB.c
     11           * @brief      OV摄像头配置总线SCCB函数库
     12           * @author     山外科技
     13           * @version    v5.0
     14           * @date       2013-09-01
     15           */
     16          
     17          
     18          #include "common.h"
     19          #include "MK60_gpio.h"
     20          #include "VCAN_SCCB.h"
     21          
     22          static void SCCB_delay(uint16 i);
     23          
     24          /*!
     25           *  @brief      SCCB延迟函数
     26           *  @param      time    延时时间
     27           *  @since      v5.0
     28           */

   \                                 In section .text, align 2, keep-with-next
     29          static void SCCB_delay(volatile uint16 time)
     30          {
   \                     SCCB_delay: (+1)
   \   00000000   0xB401             PUSH     {R0}
     31              while(time)
   \                     ??SCCB_delay_0: (+1)
   \   00000002   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??SCCB_delay_1
     32              {
     33                  time--;
   \   0000000A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000014   0xE7F5             B.N      ??SCCB_delay_0
     34              }
     35          }
   \                     ??SCCB_delay_1: (+1)
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
     36          
     37          /*!
     38           *  @brief      SCCB管脚配置
     39           *  @since      v5.0
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          void SCCB_GPIO_init(void)
     42          {
   \                     SCCB_GPIO_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     43              gpio_init  (SCCB_SCL, GPO, 1); //初始化SCL
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x201A             MOVS     R0,#+26
   \   00000008   0x.... 0x....      BL       gpio_init
     44              gpio_init  (SCCB_SDA, GPO, 1); //初始化SDA
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x2019             MOVS     R0,#+25
   \   00000012   0x.... 0x....      BL       gpio_init
     45          
     46              port_init_NoALT(SCCB_SCL,ODO | PULLUP);
   \   00000016   0x2123             MOVS     R1,#+35
   \   00000018   0x201A             MOVS     R0,#+26
   \   0000001A   0x.... 0x....      BL       port_init_NoALT
     47              port_init_NoALT(SCCB_SDA,ODO | PULLUP);
   \   0000001E   0x2123             MOVS     R1,#+35
   \   00000020   0x2019             MOVS     R0,#+25
   \   00000022   0x.... 0x....      BL       port_init_NoALT
     48          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
     49          
     50          /*!
     51           *  @brief      SCCB起始信号
     52           *  @since      v5.0
     53           */

   \                                 In section .text, align 2, keep-with-next
     54          static uint8 SCCB_Start(void)
     55          {
   \                     SCCB_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     56              SCCB_SDA_H();
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   00000006   0x6008             STR      R0,[R1, #+0]
     57              SCCB_SCL_H();
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     58              SCCB_DELAY();
   \   0000000E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000012   0x.... 0x....      BL       SCCB_delay
     59          
     60              SCCB_SDA_DDR_IN();
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   0000001A   0x6008             STR      R0,[R1, #+0]
     61              if(!SCCB_SDA_IN())
   \   0000001C   0x....             LDR.N    R0,??DataTable6_3  ;; 0x43fe0264
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD104             BNE.N    ??SCCB_Start_0
     62              {
     63                  SCCB_SDA_DDR_OUT();
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   00000028   0x6008             STR      R0,[R1, #+0]
     64                  return 0;   /* SDA线为低电平则总线忙,退出 */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE016             B.N      ??SCCB_Start_1
     65              }
     66              SCCB_SDA_DDR_OUT();
   \                     ??SCCB_Start_0: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   00000032   0x6008             STR      R0,[R1, #+0]
     67              SCCB_SDA_L();
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   00000038   0x6008             STR      R0,[R1, #+0]
     68          
     69              SCCB_DELAY();
   \   0000003A   0xF44F 0x70C8      MOV      R0,#+400
   \   0000003E   0x.... 0x....      BL       SCCB_delay
     70              SCCB_SCL_L();
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000046   0x6008             STR      R0,[R1, #+0]
     71          
     72              if(SCCB_SDA_IN())
   \   00000048   0x....             LDR.N    R0,??DataTable6_3  ;; 0x43fe0264
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD004             BEQ.N    ??SCCB_Start_2
     73              {
     74                  SCCB_SDA_DDR_OUT();
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   00000054   0x6008             STR      R0,[R1, #+0]
     75                  return 0;   /* SDA线为高电平则总线出错,退出 */
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE000             B.N      ??SCCB_Start_1
     76              }
     77              //SCCB_SDA_DDR_OUT();
     78              //SCCB_SDA_L();
     79              //SCCB_delay();
     80              return 1;
   \                     ??SCCB_Start_2: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \                     ??SCCB_Start_1: (+1)
   \   0000005C   0xBD02             POP      {R1,PC}          ;; return
     81          }
     82          
     83          /*!
     84           *  @brief      SCCB停止信号
     85           *  @since      v5.0
     86           */

   \                                 In section .text, align 2, keep-with-next
     87          static void SCCB_Stop(void)
     88          {
   \                     SCCB_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     89              SCCB_SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000006   0x6008             STR      R0,[R1, #+0]
     90              //SCCB_DELAY();
     91              
     92              SCCB_SDA_L();
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     93              SCCB_DELAY();
   \   0000000E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000012   0x.... 0x....      BL       SCCB_delay
     94              
     95              SCCB_SCL_H();
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   0000001A   0x6008             STR      R0,[R1, #+0]
     96              SCCB_DELAY();
   \   0000001C   0xF44F 0x70C8      MOV      R0,#+400
   \   00000020   0x.... 0x....      BL       SCCB_delay
     97              
     98              SCCB_SDA_H();
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   00000028   0x6008             STR      R0,[R1, #+0]
     99              SCCB_DELAY();
   \   0000002A   0xF44F 0x70C8      MOV      R0,#+400
   \   0000002E   0x.... 0x....      BL       SCCB_delay
    100          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    101          
    102          /*!
    103           *  @brief      SCCB应答信号
    104           *  @since      v5.0
    105           */

   \                                 In section .text, align 2, keep-with-next
    106          static void SCCB_Ack(void)
    107          {
   \                     SCCB_Ack: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    108              SCCB_SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000006   0x6008             STR      R0,[R1, #+0]
    109              SCCB_DELAY();
   \   00000008   0xF44F 0x70C8      MOV      R0,#+400
   \   0000000C   0x.... 0x....      BL       SCCB_delay
    110              
    111              SCCB_SDA_L();
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   00000014   0x6008             STR      R0,[R1, #+0]
    112              SCCB_DELAY();
   \   00000016   0xF44F 0x70C8      MOV      R0,#+400
   \   0000001A   0x.... 0x....      BL       SCCB_delay
    113              
    114              SCCB_SCL_H();
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000022   0x6008             STR      R0,[R1, #+0]
    115              SCCB_DELAY();
   \   00000024   0xF44F 0x70C8      MOV      R0,#+400
   \   00000028   0x.... 0x....      BL       SCCB_delay
    116              
    117              SCCB_SCL_L();
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000030   0x6008             STR      R0,[R1, #+0]
    118              SCCB_DELAY();
   \   00000032   0xF44F 0x70C8      MOV      R0,#+400
   \   00000036   0x.... 0x....      BL       SCCB_delay
    119          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    120          
    121          /*!
    122           *  @brief      SCCB无应答信号
    123           *  @since      v5.0
    124           */

   \                                 In section .text, align 2, keep-with-next
    125          static void SCCB_NoAck(void)
    126          {
   \                     SCCB_NoAck: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    127              SCCB_SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000006   0x6008             STR      R0,[R1, #+0]
    128              SCCB_DELAY();
   \   00000008   0xF44F 0x70C8      MOV      R0,#+400
   \   0000000C   0x.... 0x....      BL       SCCB_delay
    129              
    130              SCCB_SDA_H();
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   00000014   0x6008             STR      R0,[R1, #+0]
    131              SCCB_DELAY();
   \   00000016   0xF44F 0x70C8      MOV      R0,#+400
   \   0000001A   0x.... 0x....      BL       SCCB_delay
    132              
    133              SCCB_SCL_H();
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000022   0x6008             STR      R0,[R1, #+0]
    134              SCCB_DELAY();
   \   00000024   0xF44F 0x70C8      MOV      R0,#+400
   \   00000028   0x.... 0x....      BL       SCCB_delay
    135              
    136              SCCB_SCL_L();
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000030   0x6008             STR      R0,[R1, #+0]
    137              SCCB_DELAY();
   \   00000032   0xF44F 0x70C8      MOV      R0,#+400
   \   00000036   0x.... 0x....      BL       SCCB_delay
    138          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    139          
    140          /*!
    141           *  @brief      SCCB 等待应答
    142           *  @return     应答结果（0表示无应答，1表示有应答）
    143           *  @since      v5.0
    144           */

   \                                 In section .text, align 2, keep-with-next
    145          static int SCCB_WaitAck(void)
    146          {
   \                     SCCB_WaitAck: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    147              SCCB_SCL_L();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000006   0x6008             STR      R0,[R1, #+0]
    148              //SCCB_SDA_H();
    149              SCCB_SDA_DDR_IN();
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    150          
    151              SCCB_DELAY();
   \   0000000E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000012   0x.... 0x....      BL       SCCB_delay
    152              SCCB_SCL_H();
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    153          
    154              SCCB_DELAY();
   \   0000001C   0xF44F 0x70C8      MOV      R0,#+400
   \   00000020   0x.... 0x....      BL       SCCB_delay
    155          
    156              if(SCCB_SDA_IN())           //应答为高电平，异常，通信失败
   \   00000024   0x....             LDR.N    R0,??DataTable6_3  ;; 0x43fe0264
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD007             BEQ.N    ??SCCB_WaitAck_0
    157              {
    158                  SCCB_SDA_DDR_OUT();
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   00000030   0x6008             STR      R0,[R1, #+0]
    159                  SCCB_SCL_L();
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000036   0x6008             STR      R0,[R1, #+0]
    160                  return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE006             B.N      ??SCCB_WaitAck_1
    161              }
    162              SCCB_SDA_DDR_OUT();
   \                     ??SCCB_WaitAck_0: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   00000040   0x6008             STR      R0,[R1, #+0]
    163              SCCB_SCL_L();
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000046   0x6008             STR      R0,[R1, #+0]
    164              return 1;
   \   00000048   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WaitAck_1: (+1)
   \   0000004A   0xBD02             POP      {R1,PC}          ;; return
    165          }
    166          
    167          /*!
    168           *  @brief      SCCB 发送的数据
    169           *  @param      SendByte    需要发送的数据
    170           *  @since      v5.0
    171           */

   \                                 In section .text, align 2, keep-with-next
    172          static void SCCB_SendByte(uint8 SendByte)
    173          {
   \                     SCCB_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    174              uint8 i = 8;
   \   00000004   0x2408             MOVS     R4,#+8
    175              while(i--)
   \                     ??SCCB_SendByte_0: (+1)
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x1E44             SUBS     R4,R0,#+1
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD018             BEQ.N    ??SCCB_SendByte_1
    176              {
    177          
    178                  if(SendByte & 0x80)     //SDA 输出数据
   \   00000010   0x0628             LSLS     R0,R5,#+24
   \   00000012   0xD503             BPL.N    ??SCCB_SendByte_2
    179                  {
    180                      SCCB_SDA_H();
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0xE002             B.N      ??SCCB_SendByte_3
    181                  }
    182                  else
    183                  {
    184                      SCCB_SDA_L();
   \                     ??SCCB_SendByte_2: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x....             LDR.N    R1,??DataTable6  ;; 0x43fe0064
   \   00000020   0x6008             STR      R0,[R1, #+0]
    185                  }
    186                  SendByte <<= 1;
   \                     ??SCCB_SendByte_3: (+1)
   \   00000022   0x006D             LSLS     R5,R5,#+1
    187                  SCCB_DELAY();
   \   00000024   0xF44F 0x70C8      MOV      R0,#+400
   \   00000028   0x.... 0x....      BL       SCCB_delay
    188                  
    189                  SCCB_SCL_H();                //SCL 拉高，采集信号
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   00000030   0x6008             STR      R0,[R1, #+0]
    190                  SCCB_DELAY();
   \   00000032   0xF44F 0x70C8      MOV      R0,#+400
   \   00000036   0x.... 0x....      BL       SCCB_delay
    191                  
    192                  SCCB_SCL_L();                //SCL 时钟线拉低
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE7E1             B.N      ??SCCB_SendByte_0
    193                  //SCCB_DELAY();
    194              }
    195              //SCCB_SCL_L();
    196          }
   \                     ??SCCB_SendByte_1: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    197          
    198          /*!
    199           *  @brief      接收SCCB总线的数据
    200           *  @return     接收到的数据
    201           *  @since      v5.0
    202           */

   \                                 In section .text, align 2, keep-with-next
    203          static int SCCB_ReceiveByte(void)
    204          {
   \                     SCCB_ReceiveByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    205              uint8 i = 8;
   \   00000002   0x2408             MOVS     R4,#+8
    206              uint8 ReceiveByte = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    207          
    208              //SCCB_SDA_H();
    209              //SCCB_DELAY();
    210              SCCB_SDA_DDR_IN();
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    211          
    212              while(i--)
   \                     ??SCCB_ReceiveByte_0: (+1)
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x1E44             SUBS     R4,R0,#+1
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD015             BEQ.N    ??SCCB_ReceiveByte_1
    213              {
    214                  ReceiveByte <<= 1;
   \   00000016   0x006D             LSLS     R5,R5,#+1
    215                  SCCB_SCL_L();
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    216                  SCCB_DELAY();
   \   0000001E   0xF44F 0x70C8      MOV      R0,#+400
   \   00000022   0x.... 0x....      BL       SCCB_delay
    217                  
    218                  SCCB_SCL_H();
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    219                  SCCB_DELAY();
   \   0000002C   0xF44F 0x70C8      MOV      R0,#+400
   \   00000030   0x.... 0x....      BL       SCCB_delay
    220          
    221                  if(SCCB_SDA_IN())
   \   00000034   0x....             LDR.N    R0,??DataTable6_3  ;; 0x43fe0264
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD0E7             BEQ.N    ??SCCB_ReceiveByte_0
    222                  {
    223                      ReceiveByte |= 0x01;
   \   0000003C   0xF055 0x0501      ORRS     R5,R5,#0x1
   \   00000040   0xE7E4             B.N      ??SCCB_ReceiveByte_0
    224                  }
    225          
    226          
    227              }
    228              SCCB_SDA_DDR_OUT();
   \                     ??SCCB_ReceiveByte_1: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable6_2  ;; 0x43fe02e4
   \   00000046   0x6008             STR      R0,[R1, #+0]
    229              SCCB_SCL_L();
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x....             LDR.N    R1,??DataTable6_1  ;; 0x43fe0068
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    230              return ReceiveByte;
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    231          }
    232          
    233          /*****************************************************************************************
    234          * 函数名：SCCB_WriteByte
    235          * 描述  ：写一字节数据
    236          * 输入  ：- WriteAddress: 待写入地址    - SendByte: 待写入数据  - DeviceAddress: 器件类型
    237          * 输出  ：返回为:=1成功写入,=0失败
    238          * 注意  ：无
    239          *****************************************************************************************/
    240          static int SCCB_WriteByte_one( uint16 WriteAddress , uint8 SendByte );
    241          
    242          

   \                                 In section .text, align 2, keep-with-next
    243          int SCCB_WriteByte( uint16 WriteAddress , uint8 SendByte )            //考虑到用sccb的管脚模拟，比较容易失败，因此多试几次
    244          {
   \                     SCCB_WriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    245              uint8 i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    246              while( 0 == SCCB_WriteByte_one ( WriteAddress, SendByte ) )
   \                     ??SCCB_WriteByte_0: (+1)
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x.... 0x....      BL       SCCB_WriteByte_one
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??SCCB_WriteByte_1
    247              {
    248                  i++;
   \   00000018   0x1C76             ADDS     R6,R6,#+1
    249                  if(i == 20)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E14             CMP      R6,#+20
   \   0000001E   0xD1F3             BNE.N    ??SCCB_WriteByte_0
    250                  {
    251                      return 0 ;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE000             B.N      ??SCCB_WriteByte_2
    252                  }
    253              }
    254              return 1;
   \                     ??SCCB_WriteByte_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WriteByte_2: (+1)
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    255          }
    256          

   \                                 In section .text, align 2, keep-with-next
    257          int SCCB_WriteByte_one( uint16 WriteAddress , uint8 SendByte )
    258          {
   \                     SCCB_WriteByte_one: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    259              if(!SCCB_Start())
   \   00000006   0x.... 0x....      BL       SCCB_Start
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??SCCB_WriteByte_one_0
    260              {
    261                  return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE019             B.N      ??SCCB_WriteByte_one_1
    262              }
    263              SCCB_SendByte( DEV_ADR );                    /* 器件地址 */
   \                     ??SCCB_WriteByte_one_0: (+1)
   \   00000012   0x2042             MOVS     R0,#+66
   \   00000014   0x.... 0x....      BL       SCCB_SendByte
    264              if( !SCCB_WaitAck() )
   \   00000018   0x.... 0x....      BL       SCCB_WaitAck
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD103             BNE.N    ??SCCB_WriteByte_one_2
    265              {
    266                  SCCB_Stop();
   \   00000020   0x.... 0x....      BL       SCCB_Stop
    267                  return 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE00E             B.N      ??SCCB_WriteByte_one_1
    268              }
    269              SCCB_SendByte((uint8)(WriteAddress & 0x00FF));   /* 设置低起始地址 */
   \                     ??SCCB_WriteByte_one_2: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       SCCB_SendByte
    270              SCCB_WaitAck();
   \   00000030   0x.... 0x....      BL       SCCB_WaitAck
    271              SCCB_SendByte(SendByte);
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       SCCB_SendByte
    272              SCCB_WaitAck();
   \   0000003C   0x.... 0x....      BL       SCCB_WaitAck
    273              SCCB_Stop();
   \   00000040   0x.... 0x....      BL       SCCB_Stop
    274              return 1;
   \   00000044   0x2001             MOVS     R0,#+1
   \                     ??SCCB_WriteByte_one_1: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    275          }
    276          
    277          
    278          
    279          
    280          /******************************************************************************************************************
    281           * 函数名：SCCB_ReadByte
    282           * 描述  ：读取一串数据
    283           * 输入  ：- pBuffer: 存放读出数据  - length: 待读出长度    - ReadAddress: 待读出地址        - DeviceAddress: 器件类型
    284           * 输出  ：返回为:=1成功读入,=0失败
    285           * 注意  ：无
    286           **********************************************************************************************************************/
    287          static int SCCB_ReadByte_one(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress);
    288          

   \                                 In section .text, align 2, keep-with-next
    289          int SCCB_ReadByte(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress)
    290          {
   \                     SCCB_ReadByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    291              uint8 i = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    292              while( 0 == SCCB_ReadByte_one(pBuffer, length, ReadAddress) )
   \                     ??SCCB_ReadByte_0: (+1)
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       SCCB_ReadByte_one
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD105             BNE.N    ??SCCB_ReadByte_1
    293              {
    294                  i++;
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
    295                  if(i == 30)
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F1E             CMP      R7,#+30
   \   00000022   0xD1F2             BNE.N    ??SCCB_ReadByte_0
    296                  {
    297                      return 0 ;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE000             B.N      ??SCCB_ReadByte_2
    298                  }
    299              }
    300              return 1;
   \                     ??SCCB_ReadByte_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \                     ??SCCB_ReadByte_2: (+1)
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    301          }
    302          

   \                                 In section .text, align 2, keep-with-next
    303          int SCCB_ReadByte_one(uint8 *pBuffer,   uint16 length,   uint8 ReadAddress)
    304          {
   \                     SCCB_ReadByte_one: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    305              if(!SCCB_Start())
   \   00000008   0x.... 0x....      BL       SCCB_Start
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??SCCB_ReadByte_one_0
    306              {
    307                  return 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE037             B.N      ??SCCB_ReadByte_one_1
    308              }
    309              SCCB_SendByte( DEV_ADR );         /* 器件地址 */
   \                     ??SCCB_ReadByte_one_0: (+1)
   \   00000014   0x2042             MOVS     R0,#+66
   \   00000016   0x.... 0x....      BL       SCCB_SendByte
    310              if( !SCCB_WaitAck() )
   \   0000001A   0x.... 0x....      BL       SCCB_WaitAck
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD103             BNE.N    ??SCCB_ReadByte_one_2
    311              {
    312                  SCCB_Stop();
   \   00000022   0x.... 0x....      BL       SCCB_Stop
    313                  return 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE02C             B.N      ??SCCB_ReadByte_one_1
    314              }
    315              SCCB_SendByte( ReadAddress );           /* 设置低起始地址 */
   \                     ??SCCB_ReadByte_one_2: (+1)
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       SCCB_SendByte
    316              SCCB_WaitAck();
   \   00000032   0x.... 0x....      BL       SCCB_WaitAck
    317              SCCB_Stop();
   \   00000036   0x.... 0x....      BL       SCCB_Stop
    318          
    319              if(!SCCB_Start())
   \   0000003A   0x.... 0x....      BL       SCCB_Start
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD101             BNE.N    ??SCCB_ReadByte_one_3
    320              {
    321                  return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE01E             B.N      ??SCCB_ReadByte_one_1
    322              }
    323              SCCB_SendByte( DEV_ADR + 1 );               /* 器件地址 */
   \                     ??SCCB_ReadByte_one_3: (+1)
   \   00000046   0x2043             MOVS     R0,#+67
   \   00000048   0x.... 0x....      BL       SCCB_SendByte
    324          
    325              if(!SCCB_WaitAck())
   \   0000004C   0x.... 0x....      BL       SCCB_WaitAck
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD103             BNE.N    ??SCCB_ReadByte_one_4
    326              {
    327                  SCCB_Stop();
   \   00000054   0x.... 0x....      BL       SCCB_Stop
    328                  return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE013             B.N      ??SCCB_ReadByte_one_1
    329              }
    330              while(length)
   \                     ??SCCB_ReadByte_one_4: (+1)
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD00D             BEQ.N    ??SCCB_ReadByte_one_5
    331              {
    332                  *pBuffer = SCCB_ReceiveByte();
   \   00000062   0x.... 0x....      BL       SCCB_ReceiveByte
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    333                  if(length == 1)
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0x2D01             CMP      R5,#+1
   \   0000006C   0xD102             BNE.N    ??SCCB_ReadByte_one_6
    334                  {
    335                      SCCB_NoAck();
   \   0000006E   0x.... 0x....      BL       SCCB_NoAck
   \   00000072   0xE001             B.N      ??SCCB_ReadByte_one_7
    336                  }
    337                  else
    338                  {
    339                      SCCB_Ack();
   \                     ??SCCB_ReadByte_one_6: (+1)
   \   00000074   0x.... 0x....      BL       SCCB_Ack
    340                  }
    341                  pBuffer++;
   \                     ??SCCB_ReadByte_one_7: (+1)
   \   00000078   0x1C64             ADDS     R4,R4,#+1
    342                  length--;
   \   0000007A   0x1E6D             SUBS     R5,R5,#+1
   \   0000007C   0xE7EE             B.N      ??SCCB_ReadByte_one_4
    343              }
    344              SCCB_Stop();
   \                     ??SCCB_ReadByte_one_5: (+1)
   \   0000007E   0x.... 0x....      BL       SCCB_Stop
    345              return 1;
   \   00000082   0x2001             MOVS     R0,#+1
   \                     ??SCCB_ReadByte_one_1: (+1)
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    346          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x43FE0064         DC32     0x43fe0064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x43FE0068         DC32     0x43fe0068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x43FE02E4         DC32     0x43fe02e4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x43FE0264         DC32     0x43fe0264
    347          
    348          
    349          
    350          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SCCB_Ack
         8   -> SCCB_delay
       8   SCCB_GPIO_init
         8   -> gpio_init
         8   -> port_init_NoALT
       8   SCCB_NoAck
         8   -> SCCB_delay
      24   SCCB_ReadByte
        24   -> SCCB_ReadByte_one
      16   SCCB_ReadByte_one
        16   -> SCCB_Ack
        16   -> SCCB_NoAck
        16   -> SCCB_ReceiveByte
        16   -> SCCB_SendByte
        16   -> SCCB_Start
        16   -> SCCB_Stop
        16   -> SCCB_WaitAck
      16   SCCB_ReceiveByte
        16   -> SCCB_delay
      16   SCCB_SendByte
        16   -> SCCB_delay
       8   SCCB_Start
         8   -> SCCB_delay
       8   SCCB_Stop
         8   -> SCCB_delay
       8   SCCB_WaitAck
         8   -> SCCB_delay
      16   SCCB_WriteByte
        16   -> SCCB_WriteByte_one
      16   SCCB_WriteByte_one
        16   -> SCCB_SendByte
        16   -> SCCB_Start
        16   -> SCCB_Stop
        16   -> SCCB_WaitAck
       4   SCCB_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      60  SCCB_Ack
      40  SCCB_GPIO_init
      60  SCCB_NoAck
      44  SCCB_ReadByte
     134  SCCB_ReadByte_one
      84  SCCB_ReceiveByte
      68  SCCB_SendByte
      94  SCCB_Start
      52  SCCB_Stop
      76  SCCB_WaitAck
      40  SCCB_WriteByte
      72  SCCB_WriteByte_one
      26  SCCB_delay

 
 866 bytes in section .text
 
 866 bytes of CODE memory

Errors: none
Warnings: 40
