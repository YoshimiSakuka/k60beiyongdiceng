###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:36
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\VCAN_NRF24L0.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\VCAN_NRF24L0.c -D
#        DEBUG -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\VCAN_NRF24L0.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\VCAN_NRF24L0.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\src\VCAN_NRF24L0.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       VCAN_NRF24L0.c
     11           * @brief      NRF24L0驱动函数实现
     12           * @author     山外科技
     13           * @version    v5.0
     14           * @date       2013-07-9
     15           */
     16          
     17          
     18          #include "common.h"
     19          #include "MK60_port.h"
     20          #include "MK60_gpio.h"
     21          #include "MK60_spi.h"
     22          
     23          #include "VCAN_NRF24L0.h"
     24          
     25          //NRF24L01+状态
     26          typedef enum
     27          {
     28              NOT_INIT = 0,
     29              TX_MODE,
     30              RX_MODE,
     31          } nrf_mode_e;
     32          
     33          typedef enum
     34          {
     35              QUEUE_EMPTY = 0,        //队列空模式，只可入队列
     36              QUEUE_NORMAL,           //正常模式，可正常出入队列，即队列不空不满
     37              QUEUE_FULL,             //队列满模式，满了则不再添加，丢弃掉数据
     38          } nrf_rx_queueflag_e; //中断接收时，队列状态标记位
     39          
     40          
     41          //gpio控制CE和IRQ
     42          #define NRF_CE_HIGH()       GPIO_SET(NRF_CE_PTXn,1)
     43          #define NRF_CE_LOW()        GPIO_SET(NRF_CE_PTXn,0)           //CE置低
     44          #define NRF_Read_IRQ()      GPIO_SET(NRF_IRQ_PTXn)
     45          
     46          
     47          // 用户配置 发送和 接收地址，频道
     48          

   \                                 In section .data, align 4
     49          uint8 TX_ADDRESS[5] = {0x62, 0xA7, 0x31, 0xDB, 0x11};   // 定义一个静态发送地址
   \                     TX_ADDRESS:
   \   00000000   0x62 0xA7          DC8 98, 167, 49, 219, 17, 0, 0, 0
   \              0x31 0xDB    
   \              0x11 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     50          uint8 RX_ADDRESS[5] = {0x62, 0xA7, 0x31, 0xDB, 0x11};
   \                     RX_ADDRESS:
   \   00000000   0x62 0xA7          DC8 98, 167, 49, 219, 17, 0, 0, 0
   \              0x31 0xDB    
   \              0x11 0x00    
   \              0x00 0x00    
     51          
     52          #define CHANAL          25                              // 频道选择 位于 0~255
     53          
     54          
     55          // 内部配置参量
     56          #define TX_ADR_WIDTH    ADR_WIDTH                       // 发射地址宽度
     57          #define TX_PLOAD_WIDTH  DATA_PACKET                     // 发射数据通道有效数据宽度0~32Byte
     58          
     59          #define RX_ADR_WIDTH    ADR_WIDTH                       // 接收地址宽度
     60          #define RX_PLOAD_WIDTH  DATA_PACKET                     // 接收数据通道有效数据宽度0~32Byte
     61          
     62          /******************************** NRF24L01+ 寄存器命令 宏定义***************************************/
     63          
     64          // SPI(nRF24L01) commands , NRF的SPI命令宏定义，详见NRF功能使用文档
     65          #define NRF_READ_REG    0x00    // Define read command to register
     66          #define NRF_WRITE_REG   0x20    // Define write command to register
     67          #define RD_RX_PLOAD     0x61    // Define RX payload register address
     68          #define WR_TX_PLOAD     0xA0    // Define TX payload register address
     69          #define FLUSH_TX        0xE1    // Define flush TX register command
     70          #define FLUSH_RX        0xE2    // Define flush RX register command
     71          #define REUSE_TX_PL     0xE3    // Define reuse TX payload register command
     72          #define NOP             0xFF    // Define No Operation, might be used to read status register
     73          
     74          // SPI(nRF24L01) registers(addresses) ，NRF24L01 相关寄存器地址的宏定义
     75          #define CONFIG      0x00        // 'Config' register address
     76          #define EN_AA       0x01        // 'Enable Auto Acknowledgment' register address
     77          #define EN_RXADDR   0x02        // 'Enabled RX addresses' register address
     78          #define SETUP_AW    0x03        // 'Setup address width' register address
     79          #define SETUP_RETR  0x04        // 'Setup Auto. Retrans' register address
     80          #define RF_CH       0x05        // 'RF channel' register address
     81          #define RF_SETUP    0x06        // 'RF setup' register address
     82          #define STATUS      0x07        // 'Status' register address
     83          #define OBSERVE_TX  0x08        // 'Observe TX' register address
     84          #define CD          0x09        // 'Carrier Detect' register address
     85          #define RX_ADDR_P0  0x0A        // 'RX address pipe0' register address
     86          #define RX_ADDR_P1  0x0B        // 'RX address pipe1' register address
     87          #define RX_ADDR_P2  0x0C        // 'RX address pipe2' register address
     88          #define RX_ADDR_P3  0x0D        // 'RX address pipe3' register address
     89          #define RX_ADDR_P4  0x0E        // 'RX address pipe4' register address
     90          #define RX_ADDR_P5  0x0F        // 'RX address pipe5' register address
     91          #define TX_ADDR     0x10        // 'TX address' register address
     92          #define RX_PW_P0    0x11        // 'RX payload width, pipe0' register address
     93          #define RX_PW_P1    0x12        // 'RX payload width, pipe1' register address
     94          #define RX_PW_P2    0x13        // 'RX payload width, pipe2' register address
     95          #define RX_PW_P3    0x14        // 'RX payload width, pipe3' register address
     96          #define RX_PW_P4    0x15        // 'RX payload width, pipe4' register address
     97          #define RX_PW_P5    0x16        // 'RX payload width, pipe5' register address
     98          #define FIFO_STATUS 0x17        // 'FIFO Status Register' register address
     99          
    100          
    101          //几个重要的状态标记
    102          #define TX_FULL     0x01        //TX FIFO 寄存器满标志。 1 为 满，0为 不满
    103          #define MAX_RT      0x10        //达到最大重发次数中断标志位
    104          #define TX_DS       0x20        //发送完成中断标志位
    105          #define RX_DR       0x40        //接收到数据中断标志位
    106          
    107          
    108          
    109          //内部寄存器操作函数声明
    110          static  uint8   nrf_writereg(uint8 reg, uint8 dat);
    111          static  uint8   nrf_readreg (uint8 reg, uint8 *dat);
    112          
    113          static  uint8   nrf_writebuf(uint8 reg , uint8 *pBuf, uint32 len);
    114          static  uint8   nrf_readbuf (uint8 reg, uint8 *pBuf, uint32  len);
    115          
    116          
    117          static  void    nrf_rx_mode(void);           //进入接收模式
    118          static  void    nrf_tx_mode(void);           //进入发送模式
    119          
    120          /*!
    121           *  @brief      NRF24L01+ 模式标记
    122           */

   \                                 In section .bss, align 1
    123          volatile uint8  nrf_mode = NOT_INIT;
   \                     nrf_mode:
   \   00000000                      DS8 1
    124          
    125          

   \                                 In section .bss, align 1
    126          volatile uint8  nrf_rx_front = 0, nrf_rx_rear = 0;              //接收FIFO的指针
   \                     nrf_rx_front:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     nrf_rx_rear:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    127          volatile uint8  nrf_rx_flag = QUEUE_EMPTY;
   \                     nrf_rx_flag:
   \   00000000                      DS8 1
    128          

   \                                 In section .bss, align 4
    129          uint8 NRF_ISR_RX_FIFO[RX_FIFO_PACKET_NUM][DATA_PACKET];         //中断接收的FIFO
   \                     NRF_ISR_RX_FIFO:
   \   00000000                      DS8 2560
    130          
    131          

   \                                 In section .bss, align 4
    132          volatile uint8    *nrf_irq_tx_addr      = NULL;
   \                     nrf_irq_tx_addr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    133          volatile uint32    nrf_irq_tx_pnum      = 0;                    //pnum = (len+MAX_ONCE_TX_NUM -1)  / MAX_ONCE_TX_NUM
   \                     nrf_irq_tx_pnum:
   \   00000000                      DS8 4
    134          

   \                                 In section .bss, align 1
    135          volatile uint8      nrf_irq_tx_flag  = 0;                     //0 表示成功 ，1 表示 发送失败
   \                     nrf_irq_tx_flag:
   \   00000000                      DS8 1
    136          

   \                                 In section .bss, align 4
    137          uint8 NRF24L01_RXDATA[DATA_PACKET];//nrf24l01接收到的数据
   \                     NRF24L01_RXDATA:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    138          uint8 NRF24L01_TXDATA[DATA_PACKET];//nrf24l01需要发送的数据
   \                     NRF24L01_TXDATA:
   \   00000000                      DS8 32
    139          
    140          /*!
    141           *  @brief      NRF24L01+初始化，默认进入接收模式
    142           *  @return     初始化成功标记，0为初始化失败，1为初始化成功
    143           *  @since      v5.0
    144           *  Sample usage:
    145                                  while(!nrf_init())                                     //初始化NRF24L01+ ,等待初始化成功为止
    146                                  {
    147                                      printf("\n  NRF与MCU连接失败，请重新检查接线。\n");
    148                                  }
    149          
    150                                  printf("\n      NRF与MCU连接成功！\n");
    151           */

   \                                 In section .text, align 2, keep-with-next
    152          uint8 nrf_init(void)
    153          {
   \                     nrf_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    154              //配置NRF管脚复用
    155              spi_init(NRF_SPI, NRF_CS, MASTER,10*1000*1000);                     //初始化SPI,主机模式
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable9  ;; 0x989680
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       spi_init
    156          
    157              gpio_init(NRF_CE_PTXn, GPO, LOW);                               //初始化CE，默认进入待机模式
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2009             MOVS     R0,#+9
   \   00000016   0x.... 0x....      BL       gpio_init
    158          
    159              gpio_init(NRF_IRQ_PTXn, GPI, LOW);                              //初始化IRQ管脚为输入
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x209B             MOVS     R0,#+155
   \   00000020   0x.... 0x....      BL       gpio_init
    160              port_init_NoALT(NRF_IRQ_PTXn, IRQ_FALLING | PULLUP);            //初始化IRQ管脚为下降沿 触发中断
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0xa0003
   \   00000028   0x209B             MOVS     R0,#+155
   \   0000002A   0x.... 0x....      BL       port_init_NoALT
    161          
    162              //配置NRF寄存器
    163              NRF_CE_LOW();
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000034   0x6008             STR      R0,[R1, #+0]
    164          
    165              nrf_writereg(NRF_WRITE_REG + SETUP_AW, ADR_WIDTH - 2);          //设置地址长度为 TX_ADR_WIDTH
   \   00000036   0x2103             MOVS     R1,#+3
   \   00000038   0x2023             MOVS     R0,#+35
   \   0000003A   0x.... 0x....      BL       nrf_writereg
    166          
    167              nrf_writereg(NRF_WRITE_REG + RF_CH, CHANAL);                    //设置RF通道为CHANAL
   \   0000003E   0x2119             MOVS     R1,#+25
   \   00000040   0x2025             MOVS     R0,#+37
   \   00000042   0x.... 0x....      BL       nrf_writereg
    168              nrf_writereg(NRF_WRITE_REG + RF_SETUP, 0x0f);                   //设置TX发射参数,0db增益,2Mbps,低噪声增益开启
   \   00000046   0x210F             MOVS     R1,#+15
   \   00000048   0x2026             MOVS     R0,#+38
   \   0000004A   0x.... 0x....      BL       nrf_writereg
    169          
    170              nrf_writereg(NRF_WRITE_REG + EN_AA, 0x01);                      //使能通道0的自动应答
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2021             MOVS     R0,#+33
   \   00000052   0x.... 0x....      BL       nrf_writereg
    171          
    172              nrf_writereg(NRF_WRITE_REG + EN_RXADDR, 0x01);                  //使能通道0的接收地址
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x2022             MOVS     R0,#+34
   \   0000005A   0x.... 0x....      BL       nrf_writereg
    173          
    174              //RX模式配置
    175              nrf_writebuf(NRF_WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); //写RX节点地址
   \   0000005E   0x2205             MOVS     R2,#+5
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000064   0x202A             MOVS     R0,#+42
   \   00000066   0x.... 0x....      BL       nrf_writebuf
    176          
    177              nrf_writereg(NRF_WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH);         //选择通道0的有效数据宽度
   \   0000006A   0x2120             MOVS     R1,#+32
   \   0000006C   0x2031             MOVS     R0,#+49
   \   0000006E   0x.... 0x....      BL       nrf_writereg
    178          
    179              nrf_writereg(FLUSH_RX, NOP);                                    //清除RX FIFO寄存器
   \   00000072   0x21FF             MOVS     R1,#+255
   \   00000074   0x20E2             MOVS     R0,#+226
   \   00000076   0x.... 0x....      BL       nrf_writereg
    180          
    181              //TX模式配置
    182              nrf_writebuf(NRF_WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH); //写TX节点地址
   \   0000007A   0x2205             MOVS     R2,#+5
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \   00000080   0x2030             MOVS     R0,#+48
   \   00000082   0x.... 0x....      BL       nrf_writebuf
    183          
    184              nrf_writereg(NRF_WRITE_REG + SETUP_RETR, 0x0F);                 //设置自动重发间隔时间:250us + 86us;最大自动重发次数:15次
   \   00000086   0x210F             MOVS     R1,#+15
   \   00000088   0x2024             MOVS     R0,#+36
   \   0000008A   0x.... 0x....      BL       nrf_writereg
    185          
    186              nrf_writereg(FLUSH_TX, NOP);                                    //清除TX FIFO寄存器
   \   0000008E   0x21FF             MOVS     R1,#+255
   \   00000090   0x20E1             MOVS     R0,#+225
   \   00000092   0x.... 0x....      BL       nrf_writereg
    187          
    188              nrf_rx_mode();                                                  //默认进入接收模式
   \   00000096   0x.... 0x....      BL       nrf_rx_mode
    189          
    190              NRF_CE_HIGH();
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    191          
    192              return nrf_link_check();
   \   000000A2   0x.... 0x....      BL       nrf_link_check
   \   000000A6   0xBD02             POP      {R1,PC}          ;; return
    193          
    194          }
    195          
    196          /*!
    197           *  @brief      NRF24L01+写寄存器
    198           *  @param      reg         寄存器
    199           *  @param      dat         需要写入的数据
    200           *  @return     NRF24L01+ 状态
    201           *  @since      v5.0
    202           *  Sample usage:    nrf_writereg(NRF_WRITE_REG + RF_CH, CHANAL);   //设置RF通道为CHANAL
    203           */

   \                                 In section .text, align 2, keep-with-next
    204          uint8 nrf_writereg(uint8 reg, uint8 dat)
    205          {
   \                     nrf_writereg: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    206              uint8 buff[2];
    207          
    208              buff[0] = reg;          //先发送寄存器
   \   00000008   0xF88D 0x4004      STRB     R4,[SP, #+4]
    209              buff[1] = dat;          //再发送数据
   \   0000000C   0xF88D 0x5005      STRB     R5,[SP, #+5]
    210          
    211              spi_mosi(NRF_SPI, NRF_CS, buff, buff, 2); //发送buff里数据，并采集到 buff里
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0xAB01             ADD      R3,SP,#+4
   \   00000016   0xAA01             ADD      R2,SP,#+4
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       spi_mosi
    212          
    213              /*返回状态寄存器的值*/
    214              return buff[0];
   \   00000020   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000024   0xBD3E             POP      {R1-R5,PC}       ;; return
    215          }
    216          
    217          /*!
    218           *  @brief      NRF24L01+读寄存器
    219           *  @param      reg         寄存器
    220           *  @param      dat         需要读取的数据的存放地址
    221           *  @return     NRF24L01+ 状态
    222           *  @since      v5.0
    223           *  Sample usage:
    224                              uint8 data;
    225                              nrf_readreg(STATUS,&data);
    226           */

   \                                 In section .text, align 2, keep-with-next
    227          uint8 nrf_readreg(uint8 reg, uint8 *dat)
    228          {
   \                     nrf_readreg: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    229          
    230              uint8 buff[2];
    231          
    232              buff[0] = reg;          //先发送寄存器
   \   00000008   0xF88D 0x4004      STRB     R4,[SP, #+4]
    233          
    234              spi_mosi(NRF_SPI, NRF_CS, buff, buff, 2); //发送buff数据，并保存到buff里
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0xAB01             ADD      R3,SP,#+4
   \   00000012   0xAA01             ADD      R2,SP,#+4
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       spi_mosi
    235          
    236              *dat = buff[1];                         //提取第二个数据
   \   0000001C   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    237          
    238              /*返回状态寄存器的值*/
    239              return buff[0];
   \   00000022   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000026   0xBD3E             POP      {R1-R5,PC}       ;; return
    240          }
    241          
    242          /*!
    243           *  @brief      NRF24L01+写寄存器一串数据
    244           *  @param      reg         寄存器
    245           *  @param      pBuf        需要写入的数据缓冲区
    246           *  @param      len         需要写入数据长度
    247           *  @return     NRF24L01+ 状态
    248           *  @since      v5.0
    249           *  Sample usage:    nrf_writebuf(NRF_WRITE_REG+TX_ADDR,TX_ADDRESS,TX_ADR_WIDTH);    //写TX节点地址
    250           */

   \                                 In section .text, align 2, keep-with-next
    251          uint8 nrf_writebuf(uint8 reg , uint8 *pBuf, uint32 len)
    252          {
   \                     nrf_writebuf: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    253              spi_mosi_cmd(NRF_SPI, NRF_CS, &reg , &reg, pBuf, NULL, 1 , len); //发送 reg ，pBuf 内容，不接收
   \   00000008   0x9503             STR      R5,[SP, #+12]
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x9400             STR      R4,[SP, #+0]
   \   00000014   0xAB04             ADD      R3,SP,#+16
   \   00000016   0xAA04             ADD      R2,SP,#+16
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       spi_mosi_cmd
    254              return reg;    //返回NRF24L01的状态
   \   00000020   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBD30             POP      {R4,R5,PC}       ;; return
    255          }
    256          
    257          
    258          /*!
    259           *  @brief      NRF24L01+读寄存器一串数据
    260           *  @param      reg         寄存器
    261           *  @param      dat         需要读取的数据的存放地址
    262           *  @param      len         需要读取的数据长度
    263           *  @return     NRF24L01+ 状态
    264           *  @since      v5.0
    265           *  Sample usage:
    266                              uint8 data;
    267                              nrf_readreg(STATUS,&data);
    268           */

   \                                 In section .text, align 2, keep-with-next
    269          uint8 nrf_readbuf(uint8 reg, uint8 *pBuf, uint32 len)
    270          {
   \                     nrf_readbuf: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    271              spi_mosi_cmd(NRF_SPI, NRF_CS, &reg , &reg, NULL, pBuf, 1 , len); //发送reg，接收到buff
   \   00000008   0x9503             STR      R5,[SP, #+12]
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x9401             STR      R4,[SP, #+4]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0xAB04             ADD      R3,SP,#+16
   \   00000016   0xAA04             ADD      R2,SP,#+16
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       spi_mosi_cmd
    272          
    273              return reg;    //返回NRF24L01的状态
   \   00000020   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBD30             POP      {R4,R5,PC}       ;; return
    274          }
    275          
    276          /*!
    277           *  @brief      检测NRF24L01+与MCU是否正常连接
    278           *  @return     NRF24L01+ 的通信状态，0表示通信不正常，1表示正常
    279           *  @since      v5.0
    280           *  Sample usage:
    281                              while(nrf_link_check() == 0)
    282                              {
    283                                  printf("\n通信失败");
    284                              }
    285           */

   \                                 In section .text, align 2, keep-with-next
    286          uint8 nrf_link_check(void)
    287          {
   \                     nrf_link_check: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    288          #define NRF_CHECH_DATA  0xC2        //此值为校验数据时使用，可修改为其他值
    289          
    290              uint8 reg;
    291          
    292              uint8 buff[5] = {NRF_CHECH_DATA, NRF_CHECH_DATA, NRF_CHECH_DATA, NRF_CHECH_DATA, NRF_CHECH_DATA};
   \   00000004   0xA805             ADD      R0,SP,#+20
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   0000000A   0xC90C             LDM      R1!,{R2,R3}
   \   0000000C   0xC00C             STM      R0!,{R2,R3}
   \   0000000E   0x3908             SUBS     R1,R1,#+8
   \   00000010   0x3808             SUBS     R0,R0,#+8
    293              uint8 i;
    294          
    295          
    296              reg = NRF_WRITE_REG + TX_ADDR;
   \   00000012   0x2030             MOVS     R0,#+48
   \   00000014   0xF88D 0x0010      STRB     R0,[SP, #+16]
    297              spi_mosi_cmd(NRF_SPI, NRF_CS, &reg, NULL , buff, NULL, 1 , 5); //写入校验数据
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x9003             STR      R0,[SP, #+12]
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0xA805             ADD      R0,SP,#+20
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0xAA04             ADD      R2,SP,#+16
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       spi_mosi_cmd
    298          
    299              reg = TX_ADDR;
   \   00000034   0x2010             MOVS     R0,#+16
   \   00000036   0xF88D 0x0010      STRB     R0,[SP, #+16]
    300              spi_mosi_cmd(NRF_SPI, NRF_CS, &reg, NULL , NULL, buff, 1 , 5); //读取校验数据
   \   0000003A   0x2005             MOVS     R0,#+5
   \   0000003C   0x9003             STR      R0,[SP, #+12]
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9002             STR      R0,[SP, #+8]
   \   00000042   0xA805             ADD      R0,SP,#+20
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x2300             MOVS     R3,#+0
   \   0000004C   0xAA04             ADD      R2,SP,#+16
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      BL       spi_mosi_cmd
    301          
    302          
    303              /*比较*/
    304              for(i = 0; i < 5; i++)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x0004             MOVS     R4,R0
   \                     ??nrf_link_check_0: (+1)
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x2C05             CMP      R4,#+5
   \   0000005E   0xDA08             BGE.N    ??nrf_link_check_1
    305              {
    306                  if(buff[i] != NRF_CHECH_DATA)
   \   00000060   0xA805             ADD      R0,SP,#+20
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x5C20             LDRB     R0,[R4, R0]
   \   00000066   0x28C2             CMP      R0,#+194
   \   00000068   0xD001             BEQ.N    ??nrf_link_check_2
    307                  {
    308                      return 0 ;        //MCU与NRF不正常连接
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE002             B.N      ??nrf_link_check_3
    309                  }
    310              }
   \                     ??nrf_link_check_2: (+1)
   \   0000006E   0x1C64             ADDS     R4,R4,#+1
   \   00000070   0xE7F3             B.N      ??nrf_link_check_0
    311              return 1 ;             //MCU与NRF成功连接
   \                     ??nrf_link_check_1: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \                     ??nrf_link_check_3: (+1)
   \   00000074   0xB008             ADD      SP,SP,#+32
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    312          }
    313          
    314          /*!
    315          *  @brief      NRF24L01+进入接收模式
    316          *  @since      v5.0
    317          */

   \                                 In section .text, align 2, keep-with-next
    318          void nrf_rx_mode(void)
    319          {
   \                     nrf_rx_mode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    320              NRF_CE_LOW();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000008   0x6008             STR      R0,[R1, #+0]
    321          
    322              nrf_writereg(NRF_WRITE_REG + EN_AA, 0x01);          //使能通道0的自动应答
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2021             MOVS     R0,#+33
   \   0000000E   0x.... 0x....      BL       nrf_writereg
    323          
    324              nrf_writereg(NRF_WRITE_REG + EN_RXADDR, 0x01);      //使能通道0的接收地址
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2022             MOVS     R0,#+34
   \   00000016   0x.... 0x....      BL       nrf_writereg
    325          
    326              nrf_writebuf(NRF_WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); //写RX节点地址
   \   0000001A   0x2205             MOVS     R2,#+5
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000020   0x202A             MOVS     R0,#+42
   \   00000022   0x.... 0x....      BL       nrf_writebuf
    327          
    328          
    329              nrf_writereg(NRF_WRITE_REG + CONFIG, 0x0B | (IS_CRC16 << 2));       //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式
   \   00000026   0x210F             MOVS     R1,#+15
   \   00000028   0x2020             MOVS     R0,#+32
   \   0000002A   0x.... 0x....      BL       nrf_writereg
    330          
    331              /* 清除中断标志*/
    332              nrf_writereg(NRF_WRITE_REG + STATUS, 0xff);
   \   0000002E   0x21FF             MOVS     R1,#+255
   \   00000030   0x2027             MOVS     R0,#+39
   \   00000032   0x.... 0x....      BL       nrf_writereg
    333          
    334              nrf_writereg(FLUSH_RX, NOP);                    //清除RX FIFO寄存器
   \   00000036   0x21FF             MOVS     R1,#+255
   \   00000038   0x20E2             MOVS     R0,#+226
   \   0000003A   0x.... 0x....      BL       nrf_writereg
    335          
    336              /*CE拉高，进入接收模式*/
    337              NRF_CE_HIGH();
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000044   0x6008             STR      R0,[R1, #+0]
    338          
    339              nrf_mode = RX_MODE;
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable9_6
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
    340          }
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
    341          
    342          /*!
    343          *  @brief      NRF24L01+进入发送模式
    344          *  @since      v5.0
    345          */

   \                                 In section .text, align 2, keep-with-next
    346          void nrf_tx_mode(void)
    347          {
   \                     nrf_tx_mode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    348              volatile uint32 i;
    349          
    350              NRF_CE_LOW();
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000008   0x6008             STR      R0,[R1, #+0]
    351              //DELAY_MS(1);
    352          
    353              nrf_writebuf(NRF_WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH); //写TX节点地址
   \   0000000A   0x2205             MOVS     R2,#+5
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable9_4
   \   00000010   0x2030             MOVS     R0,#+48
   \   00000012   0x.... 0x....      BL       nrf_writebuf
    354          
    355              nrf_writebuf(NRF_WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); //设置RX节点地址 ,主要为了使能ACK
   \   00000016   0x2205             MOVS     R2,#+5
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   0000001C   0x202A             MOVS     R0,#+42
   \   0000001E   0x.... 0x....      BL       nrf_writebuf
    356          
    357              nrf_writereg(NRF_WRITE_REG + CONFIG, 0x0A | (IS_CRC16 << 2)); //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,发射模式,开启所有中断
   \   00000022   0x210E             MOVS     R1,#+14
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0x.... 0x....      BL       nrf_writereg
    358          
    359          
    360              /*CE拉高，进入发送模式*/
    361              NRF_CE_HIGH();
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000030   0x6008             STR      R0,[R1, #+0]
    362          
    363              nrf_mode = TX_MODE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable9_6
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    364          
    365              i = 0x0fff;
   \   0000003A   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000003E   0x9000             STR      R0,[SP, #+0]
    366              while(i--);         //CE要拉高一段时间才进入发送模式
   \                     ??nrf_tx_mode_0: (+1)
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0x1E41             SUBS     R1,R0,#+1
   \   00000044   0x9100             STR      R1,[SP, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD1FA             BNE.N    ??nrf_tx_mode_0
    367          
    368              //DELAY_MS(1);
    369          
    370          
    371          }
   \   0000004A   0xBD01             POP      {R0,PC}          ;; return
    372          
    373          /*!
    374           *  @brief      NRF24L01+数据接收
    375           *  @param      rxbuf       接收缓冲区地址
    376           *  @param      len         最大接收长度
    377           *  @return     实际接收的数据长度
    378           *  Sample usage:
    379                      relen = nrf_rx(buff,DATA_PACKET);               //等待接收一个数据包，数据存储在buff里
    380                      if(relen != 0)
    381                      {
    382                          printf("\n接收到数据:%s",buff);             //打印接收到的数据 （这里接收到的是字符串才可以用printf哦！）
    383                      }
    384          
    385           *  @since      v5.0
    386           */

   \                                 In section .text, align 2, keep-with-next
    387          uint32  nrf_rx(uint8 *rxbuf, uint32 len)
    388          {
   \                     nrf_rx: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    389              uint32 tmplen = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    390              uint8 tmp;
    391          
    392              while( (nrf_rx_flag != QUEUE_EMPTY) && (len != 0) )
   \                     ??nrf_rx_0: (+1)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable9_7
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD071             BEQ.N    ??nrf_rx_1
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD06F             BEQ.N    ??nrf_rx_1
    393              {
    394                  if(len < DATA_PACKET)
   \   00000016   0x2D20             CMP      R5,#+32
   \   00000018   0xD233             BCS.N    ??nrf_rx_2
    395                  {
    396                      vcan_cpy(rxbuf, (uint8 *)&(NRF_ISR_RX_FIFO[nrf_rx_front]), len);
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9_8
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0xEB10 0x1141      ADDS     R1,R0,R1, LSL #+5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       vcan_cpy
    397          
    398                      NRF_CE_LOW();           //进入待机状态
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000036   0x6008             STR      R0,[R1, #+0]
    399          
    400                      nrf_rx_front++;                //由于非空，所以可以直接出队列
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    401          
    402                      if(nrf_rx_front >= RX_FIFO_PACKET_NUM)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2850             CMP      R0,#+80
   \   0000004E   0xDB03             BLT.N    ??nrf_rx_3
    403                      {
    404                          nrf_rx_front = 0;          //重头开始
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    405                      }
    406                      tmp =  nrf_rx_rear;
   \                     ??nrf_rx_3: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable9_10
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x0007             MOVS     R7,R0
    407                      if(nrf_rx_front == tmp)       //追到屁股了，接收队列空
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000068   0x42B8             CMP      R0,R7
   \   0000006A   0xD103             BNE.N    ??nrf_rx_4
    408                      {
    409                          nrf_rx_flag = QUEUE_EMPTY;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable9_7
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    410                      }
    411                      NRF_CE_HIGH();          //进入接收模式
   \                     ??nrf_rx_4: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    412          
    413                      tmplen += len;
   \   0000007C   0x19AE             ADDS     R6,R5,R6
    414                      return tmplen;
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0xE03A             B.N      ??nrf_rx_5
    415                  }
    416          
    417                  vcan_cpy(rxbuf, (uint8 *)&(NRF_ISR_RX_FIFO[nrf_rx_front]), DATA_PACKET);
   \                     ??nrf_rx_2: (+1)
   \   00000082   0x2220             MOVS     R2,#+32
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable9_8
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   0000008C   0x7809             LDRB     R1,[R1, #+0]
   \   0000008E   0xEB10 0x1141      ADDS     R1,R0,R1, LSL #+5
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       vcan_cpy
    418                  rxbuf   += DATA_PACKET;
   \   00000098   0x3420             ADDS     R4,R4,#+32
    419                  len     -= DATA_PACKET;
   \   0000009A   0x3D20             SUBS     R5,R5,#+32
    420                  tmplen  += DATA_PACKET;
   \   0000009C   0x3620             ADDS     R6,R6,#+32
    421          
    422                  NRF_CE_LOW();           //进入待机状态
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    423          
    424                  nrf_rx_front++;                //由于非空，所以可以直接出队列
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
    425          
    426                  if(nrf_rx_front >= RX_FIFO_PACKET_NUM)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x2850             CMP      R0,#+80
   \   000000BC   0xDB03             BLT.N    ??nrf_rx_6
    427                  {
    428                      nrf_rx_front = 0;          //重头开始
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable9_9
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
    429                  }
    430                  tmp  = nrf_rx_rear;
   \                     ??nrf_rx_6: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable9_10
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x0007             MOVS     R7,R0
    431                  if(nrf_rx_front == tmp)       //追到屁股了，接收队列空
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D6   0x42B8             CMP      R0,R7
   \   000000D8   0xD104             BNE.N    ??nrf_rx_7
    432                  {
    433                      nrf_rx_flag = QUEUE_EMPTY;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable9_7
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   \   000000E2   0xE003             B.N      ??nrf_rx_8
    434                  }
    435                  else
    436                  {
    437                      nrf_rx_flag = QUEUE_NORMAL;
   \                     ??nrf_rx_7: (+1)
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable9_7
   \   000000EA   0x7008             STRB     R0,[R1, #+0]
    438                  }
    439                  NRF_CE_HIGH();          //进入接收模式
   \                     ??nrf_rx_8: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x43fe0024
   \   000000F2   0x6008             STR      R0,[R1, #+0]
   \   000000F4   0xE788             B.N      ??nrf_rx_0
    440              }
    441          
    442              return tmplen;
   \                     ??nrf_rx_1: (+1)
   \   000000F6   0x0030             MOVS     R0,R6
   \                     ??nrf_rx_5: (+1)
   \   000000F8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    443          }
    444          
    445          /*!
    446           *  @brief      NRF24L01+数据发送
    447           *  @param      rxbuf       发送缓冲区地址
    448           *  @param      len         发送长度
    449           *  @return     发送结果，0表示发送失败，1为发送中。最终发送结果需要调用nrf_tx_state()判断。
    450           *  Sample usage:
    451                              if(nrf_tx(buff,DATA_PACKET) == 1 );         //发送一个数据包：buff（包为32字节）
    452                              {
    453                                  //等待发送过程中，此处可以加入处理任务
    454          
    455                                  while(nrf_tx_state() == NRF_TXING);         //等待发送完成
    456          
    457                                  if( NRF_TX_OK == nrf_tx_state () )
    458                                  {
    459                                      printf("\n发送成功:%d",i);
    460                                      i++;                                    //发送成功则加1，可验证是否漏包
    461                                  }
    462                                  else
    463                                  {
    464                                      printf("\n发送失败:%d",i);
    465                                  }
    466                              }
    467                              else
    468                              {
    469                                  printf("\n发送失败:%d",i);
    470                              }
    471          
    472           *  @since      v5.0
    473           */

   \                                 In section .text, align 2, keep-with-next
    474          uint8    nrf_tx(uint8 *txbuf, uint32 len)
    475          {
   \                     nrf_tx: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    476              nrf_irq_tx_flag = 0;        //复位标志位
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable9_11
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    477          
    478              if((txbuf == 0 ) || (len == 0))
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD001             BEQ.N    ??nrf_tx_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??nrf_tx_1
    479              {
    480                  return 0;
   \                     ??nrf_tx_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE021             B.N      ??nrf_tx_2
    481              }
    482          
    483              if(nrf_irq_tx_addr == 0 )
   \                     ??nrf_tx_1: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable9_12
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD11B             BNE.N    ??nrf_tx_3
    484              {
    485                  //
    486                  nrf_irq_tx_pnum = (len - 1) / DATA_PACKET;        // 进 1 求得 包 的数目
   \   00000024   0x1E68             SUBS     R0,R5,#+1
   \   00000026   0x0940             LSRS     R0,R0,#+5
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable9_13
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    487                  nrf_irq_tx_addr = txbuf;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable9_12
   \   00000032   0x6004             STR      R4,[R0, #+0]
    488          
    489                  if( nrf_mode != TX_MODE)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD001             BEQ.N    ??nrf_tx_4
    490                  {
    491                      nrf_tx_mode();
   \   0000003E   0x.... 0x....      BL       nrf_tx_mode
    492                  }
    493          
    494                  //需要 先发送一次数据包后才能 中断发送
    495          
    496                  /*ce为低，进入待机模式1*/
    497                  NRF_CE_LOW();
   \                     ??nrf_tx_4: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000046   0x6008             STR      R0,[R1, #+0]
    498          
    499                  /*写数据到TX BUF 最大 32个字节*/
    500                  nrf_writebuf(WR_TX_PLOAD, txbuf, DATA_PACKET);
   \   00000048   0x2220             MOVS     R2,#+32
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0x20A0             MOVS     R0,#+160
   \   0000004E   0x.... 0x....      BL       nrf_writebuf
    501          
    502                  /*CE为高，txbuf非空，发送数据包 */
    503                  NRF_CE_HIGH();
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000056   0x6008             STR      R0,[R1, #+0]
    504          
    505                  return 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xE000             B.N      ??nrf_tx_2
    506              }
    507              else
    508              {
    509                  return 0;
   \                     ??nrf_tx_3: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??nrf_tx_2: (+1)
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    510              }
    511          }
    512          
    513          
    514          /*!
    515           *  @brief      检查NRF24L01+发送状态
    516           *  @return     发送结果，参考 nrf_tx_state_e 枚举的定义。
    517           *  Sample usage:
    518                              if(nrf_tx(buff,DATA_PACKET) == 1 );         //发送一个数据包：buff（包为32字节）
    519                              {
    520                                  //等待发送过程中，此处可以加入处理任务
    521          
    522                                  while(nrf_tx_state() == NRF_TXING);         //等待发送完成
    523          
    524                                  if( NRF_TX_OK == nrf_tx_state () )
    525                                  {
    526                                      printf("\n发送成功:%d",i);
    527                                      i++;                                    //发送成功则加1，可验证是否漏包
    528                                  }
    529                                  else
    530                                  {
    531                                      printf("\n发送失败:%d",i);
    532                                  }
    533                              }
    534                              else
    535                              {
    536                                  printf("\n发送失败:%d",i);
    537                              }
    538          
    539           *  @since      v5.0
    540           */

   \                                 In section .text, align 2, keep-with-next
    541          nrf_tx_state_e nrf_tx_state ()
    542          {
    543              /*
    544              if(nrf_mode != TX_MODE)
    545              {
    546                  return NRF_NOT_TX;
    547              }
    548              */
    549          
    550              if((nrf_irq_tx_addr == 0) && (nrf_irq_tx_pnum == 0))
   \                     nrf_tx_state: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_12
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD10B             BNE.N    ??nrf_tx_state_0
   \   00000008   0x....             LDR.N    R0,??DataTable9_13
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD107             BNE.N    ??nrf_tx_state_0
    551              {
    552                  //发送完成
    553                  if(nrf_irq_tx_flag)
   \   00000010   0x....             LDR.N    R0,??DataTable9_11
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??nrf_tx_state_1
    554                  {
    555                      return NRF_TX_ERROR;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE002             B.N      ??nrf_tx_state_2
    556                  }
    557                  else
    558                  {
    559                      return NRF_TX_OK;
   \                     ??nrf_tx_state_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xE000             B.N      ??nrf_tx_state_2
    560                  }
    561              }
    562              else
    563              {
    564                  return NRF_TXING;
   \                     ??nrf_tx_state_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??nrf_tx_state_2: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    565              }
    566          }
    567          

   \                                 In section .text, align 2, keep-with-next
    568          void nrf_handler(void)
    569          {
   \                     nrf_handler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    570              uint8 state;
    571              uint8 tmp;
    572              /*读取status寄存器的值  */
    573              nrf_readreg(STATUS, &state);
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x2007             MOVS     R0,#+7
   \   00000008   0x.... 0x....      BL       nrf_readreg
    574          
    575              /* 清除中断标志*/
    576              nrf_writereg(NRF_WRITE_REG + STATUS, state);
   \   0000000C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000010   0x2027             MOVS     R0,#+39
   \   00000012   0x.... 0x....      BL       nrf_writereg
    577          
    578              if(state & RX_DR) //接收到数据
   \   00000016   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001A   0x0640             LSLS     R0,R0,#+25
   \   0000001C   0xD532             BPL.N    ??nrf_handler_0
    579              {
    580                  NRF_CE_LOW();
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000022   0x6008             STR      R0,[R1, #+0]
    581          
    582                  if(nrf_rx_flag != QUEUE_FULL)
   \   00000024   0x....             LDR.N    R0,??DataTable9_7
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD024             BEQ.N    ??nrf_handler_1
    583                  {
    584                      //还没满，则继续接收
    585                      //printf("+");
    586                      nrf_readbuf(RD_RX_PLOAD, (uint8 *)&(NRF_ISR_RX_FIFO[nrf_rx_rear]), RX_PLOAD_WIDTH); //读取数据
   \   0000002C   0x2220             MOVS     R2,#+32
   \   0000002E   0x....             LDR.N    R0,??DataTable9_8
   \   00000030   0x....             LDR.N    R1,??DataTable9_10
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0xEB10 0x1141      ADDS     R1,R0,R1, LSL #+5
   \   00000038   0x2061             MOVS     R0,#+97
   \   0000003A   0x.... 0x....      BL       nrf_readbuf
    587          
    588                      nrf_rx_rear++;
   \   0000003E   0x....             LDR.N    R0,??DataTable9_10
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable9_10
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    589          
    590                      if(nrf_rx_rear >= RX_FIFO_PACKET_NUM)
   \   00000048   0x....             LDR.N    R0,??DataTable9_10
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2850             CMP      R0,#+80
   \   0000004E   0xDB02             BLT.N    ??nrf_handler_2
    591                      {
    592                          nrf_rx_rear = 0;                            //重头开始
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x....             LDR.N    R1,??DataTable9_10
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    593                      }
    594                      tmp = nrf_rx_front;
   \                     ??nrf_handler_2: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable9_9
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x0004             MOVS     R4,R0
    595                      if(nrf_rx_rear == tmp)                 //追到屁股了，满了
   \   0000005C   0x....             LDR.N    R0,??DataTable9_10
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x42A0             CMP      R0,R4
   \   00000064   0xD103             BNE.N    ??nrf_handler_3
    596                      {
    597                          nrf_rx_flag = QUEUE_FULL;
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x....             LDR.N    R1,??DataTable9_7
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
   \   0000006C   0xE007             B.N      ??nrf_handler_4
    598                      }
    599                      else
    600                      {
    601                          nrf_rx_flag = QUEUE_NORMAL;
   \                     ??nrf_handler_3: (+1)
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x....             LDR.N    R1,??DataTable9_7
   \   00000072   0x7008             STRB     R0,[R1, #+0]
   \   00000074   0xE003             B.N      ??nrf_handler_4
    602                      }
    603                  }
    604                  else
    605                  {
    606                      nrf_writereg(FLUSH_RX, NOP);                    //清除RX FIFO寄存器
   \                     ??nrf_handler_1: (+1)
   \   00000076   0x21FF             MOVS     R1,#+255
   \   00000078   0x20E2             MOVS     R0,#+226
   \   0000007A   0x.... 0x....      BL       nrf_writereg
    607                  }
    608                  NRF_CE_HIGH();                                      //进入接收模式
   \                     ??nrf_handler_4: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe0024
   \   00000082   0x6008             STR      R0,[R1, #+0]
    609              }
    610          
    611              if(state & TX_DS) //发送完数据
   \                     ??nrf_handler_0: (+1)
   \   00000084   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000088   0x0680             LSLS     R0,R0,#+26
   \   0000008A   0xD529             BPL.N    ??nrf_handler_5
    612              {
    613                  if(nrf_irq_tx_pnum == 0)
   \   0000008C   0x....             LDR.N    R0,??DataTable9_13
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD109             BNE.N    ??nrf_handler_6
    614                  {
    615                      nrf_irq_tx_addr = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x....             LDR.N    R1,??DataTable9_12
   \   00000098   0x6008             STR      R0,[R1, #+0]
    616          
    617                      // 注意: nrf_irq_tx_pnum == 0 表示 数据 已经全部发送到FIFO 。 nrf_irq_tx_addr == 0 才是 全部发送完了
    618          
    619                      //发送完成后 默认 进入 接收模式
    620          #if 1
    621                      if( nrf_mode != RX_MODE)
   \   0000009A   0x....             LDR.N    R0,??DataTable9_6
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x2802             CMP      R0,#+2
   \   000000A0   0xD01E             BEQ.N    ??nrf_handler_5
    622                      {
    623                          nrf_rx_mode();
   \   000000A2   0x.... 0x....      BL       nrf_rx_mode
   \   000000A6   0xE01B             B.N      ??nrf_handler_5
    624                      }
    625          #endif
    626          
    627                      //发送长度 为 0个包，即发送完成
    628                      //nrf_writereg(FLUSH_TX, NOP);                        //清除TX FIFO寄存器
    629                  }
    630                  else
    631                  {
    632                      if( nrf_mode != TX_MODE)
   \                     ??nrf_handler_6: (+1)
   \   000000A8   0x....             LDR.N    R0,??DataTable9_6
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD001             BEQ.N    ??nrf_handler_7
    633                      {
    634                          nrf_tx_mode();
   \   000000B0   0x.... 0x....      BL       nrf_tx_mode
    635                      }
    636          
    637                      //还没发送完成，就继续发送
    638                      nrf_irq_tx_addr += DATA_PACKET;    //指向下一个地址
   \                     ??nrf_handler_7: (+1)
   \   000000B4   0x....             LDR.N    R0,??DataTable9_12
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x3020             ADDS     R0,R0,#+32
   \   000000BA   0x....             LDR.N    R1,??DataTable9_12
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    639                      nrf_irq_tx_pnum --;                 //包数目减少
   \   000000BE   0x....             LDR.N    R0,??DataTable9_13
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0x1E40             SUBS     R0,R0,#+1
   \   000000C4   0x....             LDR.N    R1,??DataTable9_13
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    640          
    641                      /*ce为低，进入待机模式1*/
    642                      NRF_CE_LOW();
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe0024
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    643          
    644                      /*写数据到TX BUF 最大 32个字节*/
    645                      nrf_writebuf(WR_TX_PLOAD, (uint8 *)nrf_irq_tx_addr, DATA_PACKET);
   \   000000CE   0x2220             MOVS     R2,#+32
   \   000000D0   0x....             LDR.N    R0,??DataTable9_12
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0x20A0             MOVS     R0,#+160
   \   000000D6   0x.... 0x....      BL       nrf_writebuf
    646          
    647                      /*CE为高，txbuf非空，发送数据包 */
    648                      NRF_CE_HIGH();
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x....             LDR.N    R1,??DataTable9_2  ;; 0x43fe0024
   \   000000DE   0x6008             STR      R0,[R1, #+0]
    649                  }
    650              }
    651          
    652              if(state & MAX_RT)      //发送超时
   \                     ??nrf_handler_5: (+1)
   \   000000E0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E4   0x06C0             LSLS     R0,R0,#+27
   \   000000E6   0xD50E             BPL.N    ??nrf_handler_8
    653              {
    654                  nrf_irq_tx_flag = 1;                            //标记发送失败
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0x....             LDR.N    R1,??DataTable9_11
   \   000000EC   0x7008             STRB     R0,[R1, #+0]
    655                  nrf_writereg(FLUSH_TX, NOP);                    //清除TX FIFO寄存器
   \   000000EE   0x21FF             MOVS     R1,#+255
   \   000000F0   0x20E1             MOVS     R0,#+225
   \   000000F2   0x.... 0x....      BL       nrf_writereg
    656          
    657          
    658                  //有可能是 对方也处于 发送状态
    659          
    660                  //放弃本次发送
    661                  nrf_irq_tx_addr = 0;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x....             LDR.N    R1,??DataTable9_12
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    662                  nrf_irq_tx_pnum = 0;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x....             LDR.N    R1,??DataTable9_13
   \   00000100   0x6008             STR      R0,[R1, #+0]
    663          
    664                  nrf_rx_mode();                                  //进入 接收状态
   \   00000102   0x.... 0x....      BL       nrf_rx_mode
    665          
    666          
    667                  //printf("\nMAX_RT");
    668              }
    669          
    670              if(state & TX_FULL) //TX FIFO 满
    671              {
    672                  //printf("\nTX_FULL");
    673          
    674              }
    675          }
   \                     ??nrf_handler_8: (+1)
   \   00000106   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    676          
    677          
    678          //检测 接收FIFO 的数据  (0 没接收够 、1 为接收正确)

   \                                 In section .text, align 2, keep-with-next
    679          uint8  nrf_rx_fifo_check(uint32 offset,uint16 * val)
    680          {
   \                     nrf_rx_fifo_check: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
    681              uint8 rx_num = (offset + 1 + DATA_PACKET - 1 ) / DATA_PACKET;   //加1 是因为返回2个字节，最后一个自己所在的包数。
   \   00000004   0xF112 0x0020      ADDS     R0,R2,#+32
   \   00000008   0x0944             LSRS     R4,R0,#+5
    682                                                                              //+ DATA_PACKET - 1 是四舍五入
    683              uint8 tmp;
    684              if(nrf_rx_flag == QUEUE_EMPTY)
   \   0000000A   0x....             LDR.N    R0,??DataTable9_7
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??nrf_rx_fifo_check_0
    685              {
    686                  return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE030             B.N      ??nrf_rx_fifo_check_1
    687              }
    688          
    689              if(rx_num > RX_FIFO_PACKET_NUM)                                 //偏移太大，超过 FIFO 限制
   \                     ??nrf_rx_fifo_check_0: (+1)
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C51             CMP      R4,#+81
   \   0000001A   0xDB01             BLT.N    ??nrf_rx_fifo_check_2
    690              {
    691                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE02B             B.N      ??nrf_rx_fifo_check_1
    692              }
    693          
    694              rx_num = nrf_rx_front + rx_num - 1;                             //目标查询的 包的位置
   \                     ??nrf_rx_fifo_check_2: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable9_9
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x1904             ADDS     R4,R0,R4
    695              tmp =  nrf_rx_rear;
   \   00000028   0x....             LDR.N    R0,??DataTable9_10
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x0003             MOVS     R3,R0
    696              if(nrf_rx_front <  tmp)                                 //接收数据在 一圈之内
   \   0000002E   0x....             LDR.N    R0,??DataTable9_9
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0x4298             CMP      R0,R3
   \   00000036   0xD206             BCS.N    ??nrf_rx_fifo_check_3
    697              {
    698                  if(rx_num >= nrf_rx_rear )                                  //没接收足够的数据
   \   00000038   0x....             LDR.N    R0,??DataTable9_10
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD30C             BCC.N    ??nrf_rx_fifo_check_4
    699                  {
    700                      return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE018             B.N      ??nrf_rx_fifo_check_1
    701                  }
    702          
    703                  //获取数据
    704          
    705              }
    706              else                                                            //越过一圈
    707              {
    708                  if(rx_num >= RX_FIFO_PACKET_NUM)                            //超过一圈
   \                     ??nrf_rx_fifo_check_3: (+1)
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C50             CMP      R4,#+80
   \   0000004A   0xDB07             BLT.N    ??nrf_rx_fifo_check_4
    709                  {
    710                      rx_num -= RX_FIFO_PACKET_NUM;
   \   0000004C   0x3C50             SUBS     R4,R4,#+80
    711          
    712                      if( rx_num >= nrf_rx_rear )                             //还没接收够
   \   0000004E   0x....             LDR.N    R0,??DataTable9_10
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD301             BCC.N    ??nrf_rx_fifo_check_4
    713                      {
    714                          return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE00D             B.N      ??nrf_rx_fifo_check_1
    715                      }
    716                  }
    717                  //获取数据
    718              }
    719          
    720              //获取数据
    721              *val = *(uint16 *)((char *)&NRF_ISR_RX_FIFO + ( rx_num*DATA_PACKET + (offset % DATA_PACKET - 2) )) ;
   \                     ??nrf_rx_fifo_check_4: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable9_8
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0x2520             MOVS     R5,#+32
   \   00000062   0xFBB2 0xF6F5      UDIV     R6,R2,R5
   \   00000066   0xFB06 0x2615      MLS      R6,R6,R5,R2
   \   0000006A   0xEB16 0x1544      ADDS     R5,R6,R4, LSL #+5
   \   0000006E   0x1828             ADDS     R0,R5,R0
   \   00000070   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000074   0x8008             STRH     R0,[R1, #+0]
    722              return 1;
   \   00000076   0x2001             MOVS     R0,#+1
   \                     ??nrf_rx_fifo_check_1: (+1)
   \   00000078   0xBC70             POP      {R4-R6}
   \   0000007A   0x4770             BX       LR               ;; return
    723          
    724          }
    725          
    726          

   \                                 In section .text, align 2, keep-with-next
    727          int NRF_Send_Data(void)
    728          {
   \                     NRF_Send_Data: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    729                  int i = 1225;               //实际使用时候删去
   \   00000004   0xF240 0x40C9      MOVW     R0,#+1225
   \   00000008   0x9000             STR      R0,[SP, #+0]
    730          	NRF24L01_TXDATA[0]  = 0x8A;
   \   0000000A   0x208A             MOVS     R0,#+138
   \   0000000C   0x....             LDR.N    R1,??DataTable9_14
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    731          	NRF24L01_TXDATA[1]  = BYTE1(i);
   \   00000010   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000014   0x....             LDR.N    R1,??DataTable9_14
   \   00000016   0x7048             STRB     R0,[R1, #+1]
    732          	NRF24L01_TXDATA[2]  = BYTE0(i);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x....             LDR.N    R1,??DataTable9_14
   \   0000001E   0x7088             STRB     R0,[R1, #+2]
    733          	NRF24L01_TXDATA[3]  = BYTE1(i);//实际速度
   \   00000020   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000024   0x....             LDR.N    R1,??DataTable9_14
   \   00000026   0x70C8             STRB     R0,[R1, #+3]
    734          	NRF24L01_TXDATA[4]  = BYTE0(i);
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable9_14
   \   0000002E   0x7108             STRB     R0,[R1, #+4]
    735          	NRF24L01_TXDATA[5]  = BYTE1(i);  //速度误差
   \   00000030   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000034   0x....             LDR.N    R1,??DataTable9_14
   \   00000036   0x7148             STRB     R0,[R1, #+5]
    736          	NRF24L01_TXDATA[6]  = BYTE0(i);
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x....             LDR.N    R1,??DataTable9_14
   \   0000003E   0x7188             STRB     R0,[R1, #+6]
    737          	NRF24L01_TXDATA[7]  = BYTE1(i);   //输出积分
   \   00000040   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000044   0x....             LDR.N    R1,??DataTable9_14
   \   00000046   0x71C8             STRB     R0,[R1, #+7]
    738          	NRF24L01_TXDATA[8]  = BYTE0(i);
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0x....             LDR.N    R1,??DataTable9_14
   \   0000004E   0x7208             STRB     R0,[R1, #+8]
    739          	NRF24L01_TXDATA[9]  = BYTE1(i); //误差积分
   \   00000050   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000054   0x....             LDR.N    R1,??DataTable9_14
   \   00000056   0x7248             STRB     R0,[R1, #+9]
    740          	NRF24L01_TXDATA[10] = BYTE0(i);
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x....             LDR.N    R1,??DataTable9_14
   \   0000005E   0x7288             STRB     R0,[R1, #+10]
    741          	NRF24L01_TXDATA[11] = BYTE1(i);//速度环输出
   \   00000060   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000064   0x....             LDR.N    R1,??DataTable9_14
   \   00000066   0x72C8             STRB     R0,[R1, #+11]
    742          	NRF24L01_TXDATA[12] = BYTE0(i);
   \   00000068   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000006C   0x....             LDR.N    R1,??DataTable9_14
   \   0000006E   0x7308             STRB     R0,[R1, #+12]
    743          	NRF24L01_TXDATA[13] = BYTE1(i);
   \   00000070   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000074   0x....             LDR.N    R1,??DataTable9_14
   \   00000076   0x7348             STRB     R0,[R1, #+13]
    744          	NRF24L01_TXDATA[14] = BYTE0(i);
   \   00000078   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007C   0x....             LDR.N    R1,??DataTable9_14
   \   0000007E   0x7388             STRB     R0,[R1, #+14]
    745          	NRF24L01_TXDATA[15] = BYTE1(i);
   \   00000080   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000084   0x....             LDR.N    R1,??DataTable9_14
   \   00000086   0x73C8             STRB     R0,[R1, #+15]
    746          	NRF24L01_TXDATA[16] = BYTE0(i);
   \   00000088   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008C   0x....             LDR.N    R1,??DataTable9_14
   \   0000008E   0x7408             STRB     R0,[R1, #+16]
    747          	NRF24L01_TXDATA[17] = BYTE1(i);
   \   00000090   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000094   0x....             LDR.N    R1,??DataTable9_14
   \   00000096   0x7448             STRB     R0,[R1, #+17]
    748          	NRF24L01_TXDATA[18] = BYTE0(i);
   \   00000098   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009C   0x....             LDR.N    R1,??DataTable9_14
   \   0000009E   0x7488             STRB     R0,[R1, #+18]
    749          	NRF24L01_TXDATA[19] = BYTE1(i);
   \   000000A0   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000A4   0x....             LDR.N    R1,??DataTable9_14
   \   000000A6   0x74C8             STRB     R0,[R1, #+19]
    750          	NRF24L01_TXDATA[20] = BYTE0(i);
   \   000000A8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000AC   0x....             LDR.N    R1,??DataTable9_14
   \   000000AE   0x7508             STRB     R0,[R1, #+20]
    751                  NRF24L01_TXDATA[21] = BYTE1(i);
   \   000000B0   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000B4   0x....             LDR.N    R1,??DataTable9_14
   \   000000B6   0x7548             STRB     R0,[R1, #+21]
    752          	NRF24L01_TXDATA[22] = BYTE0(i);
   \   000000B8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000BC   0x....             LDR.N    R1,??DataTable9_14
   \   000000BE   0x7588             STRB     R0,[R1, #+22]
    753                  NRF24L01_TXDATA[23] = BYTE1(i);
   \   000000C0   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000C4   0x....             LDR.N    R1,??DataTable9_14
   \   000000C6   0x75C8             STRB     R0,[R1, #+23]
    754                  NRF24L01_TXDATA[24] = BYTE0(i);
   \   000000C8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000CC   0x....             LDR.N    R1,??DataTable9_14
   \   000000CE   0x7608             STRB     R0,[R1, #+24]
    755                  NRF24L01_TXDATA[25] = BYTE0(i);
   \   000000D0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000D4   0x....             LDR.N    R1,??DataTable9_14
   \   000000D6   0x7648             STRB     R0,[R1, #+25]
    756                  NRF24L01_TXDATA[26] = BYTE0(i);
   \   000000D8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000DC   0x....             LDR.N    R1,??DataTable9_14
   \   000000DE   0x7688             STRB     R0,[R1, #+26]
    757                  NRF24L01_TXDATA[27] = BYTE0(i);
   \   000000E0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E4   0x....             LDR.N    R1,??DataTable9_14
   \   000000E6   0x76C8             STRB     R0,[R1, #+27]
    758                  NRF24L01_TXDATA[28] = BYTE0(i);
   \   000000E8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000EC   0x....             LDR.N    R1,??DataTable9_14
   \   000000EE   0x7708             STRB     R0,[R1, #+28]
    759                  NRF24L01_TXDATA[29] = BYTE0(i);
   \   000000F0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000F4   0x....             LDR.N    R1,??DataTable9_14
   \   000000F6   0x7748             STRB     R0,[R1, #+29]
    760                  NRF24L01_TXDATA[30] = BYTE0(i);
   \   000000F8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000FC   0x....             LDR.N    R1,??DataTable9_14
   \   000000FE   0x7788             STRB     R0,[R1, #+30]
    761          
    762          	uint8 sum = 0;
   \   00000100   0x2400             MOVS     R4,#+0
    763          	for(i=0;i<31;i++)
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x9000             STR      R0,[SP, #+0]
   \                     ??NRF_Send_Data_0: (+1)
   \   00000106   0x9800             LDR      R0,[SP, #+0]
   \   00000108   0x281F             CMP      R0,#+31
   \   0000010A   0xDA07             BGE.N    ??NRF_Send_Data_1
    764          		sum += NRF24L01_TXDATA[i];
   \   0000010C   0x....             LDR.N    R0,??DataTable9_14
   \   0000010E   0x9900             LDR      R1,[SP, #+0]
   \   00000110   0x5C08             LDRB     R0,[R1, R0]
   \   00000112   0x1904             ADDS     R4,R0,R4
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0x1C40             ADDS     R0,R0,#+1
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0xE7F4             B.N      ??NRF_Send_Data_0
    765          	NRF24L01_TXDATA[31] = sum;
   \                     ??NRF_Send_Data_1: (+1)
   \   0000011C   0x....             LDR.N    R0,??DataTable9_14
   \   0000011E   0x77C4             STRB     R4,[R0, #+31]
    766          	if(nrf_tx(NRF24L01_TXDATA,DATA_PACKET) == 1)
   \   00000120   0x2120             MOVS     R1,#+32
   \   00000122   0x....             LDR.N    R0,??DataTable9_14
   \   00000124   0x.... 0x....      BL       nrf_tx
   \   00000128   0x2801             CMP      R0,#+1
   \   0000012A   0xD101             BNE.N    ??NRF_Send_Data_2
    767          		return 1;
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xE000             B.N      ??NRF_Send_Data_3
    768          	else 
    769                          return 0;
   \                     ??NRF_Send_Data_2: (+1)
   \   00000130   0x2000             MOVS     R0,#+0
   \                     ??NRF_Send_Data_3: (+1)
   \   00000132   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    770          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x00989680         DC32     0x989680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x000A0003         DC32     0xa0003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x43FE0024         DC32     0x43fe0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     RX_ADDRESS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     TX_ADDRESS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     nrf_mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     nrf_rx_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     NRF_ISR_RX_FIFO

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     nrf_rx_front

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     nrf_rx_rear

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     nrf_irq_tx_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     nrf_irq_tx_addr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     nrf_irq_tx_pnum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     NRF24L01_TXDATA

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0xC2 0xC2          DC8 194, 194, 194, 194, 194, 0, 0, 0
   \              0xC2 0xC2    
   \              0xC2 0x00    
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   NRF_Send_Data
        16   -> nrf_tx
      16   nrf_handler
        16   -> nrf_readbuf
        16   -> nrf_readreg
        16   -> nrf_rx_mode
        16   -> nrf_tx_mode
        16   -> nrf_writebuf
        16   -> nrf_writereg
       8   nrf_init
         8   -> gpio_init
         8   -> nrf_link_check
         8   -> nrf_rx_mode
         8   -> nrf_writebuf
         8   -> nrf_writereg
         8   -> port_init_NoALT
         8   -> spi_init
      40   nrf_link_check
        40   -> spi_mosi_cmd
      32   nrf_readbuf
        32   -> spi_mosi_cmd
      24   nrf_readreg
        24   -> spi_mosi
      24   nrf_rx
        24   -> vcan_cpy
      12   nrf_rx_fifo_check
       8   nrf_rx_mode
         8   -> nrf_writebuf
         8   -> nrf_writereg
      16   nrf_tx
        16   -> nrf_tx_mode
        16   -> nrf_writebuf
       8   nrf_tx_mode
         8   -> nrf_writebuf
         8   -> nrf_writereg
       0   nrf_tx_state
      32   nrf_writebuf
        32   -> spi_mosi_cmd
      24   nrf_writereg
        24   -> spi_mosi


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       8  ?_0
      32  NRF24L01_RXDATA
      32  NRF24L01_TXDATA
    2560  NRF_ISR_RX_FIFO
     308  NRF_Send_Data
       8  RX_ADDRESS
       8  TX_ADDRESS
     264  nrf_handler
     168  nrf_init
       4  nrf_irq_tx_addr
       1  nrf_irq_tx_flag
       4  nrf_irq_tx_pnum
     120  nrf_link_check
       1  nrf_mode
      40  nrf_readbuf
      40  nrf_readreg
     250  nrf_rx
     124  nrf_rx_fifo_check
       1  nrf_rx_flag
       1  nrf_rx_front
      80  nrf_rx_mode
       1  nrf_rx_rear
      96  nrf_tx
      76  nrf_tx_mode
      36  nrf_tx_state
      40  nrf_writebuf
      38  nrf_writereg

 
 2 637 bytes in section .bss
    16 bytes in section .data
     8 bytes in section .rodata
 1 740 bytes in section .text
 
 1 740 bytes of CODE  memory
     8 bytes of CONST memory
 2 653 bytes of DATA  memory

Errors: none
Warnings: 16
