###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\Accessories\MPU6050\VCAN_MPU6050.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\Accessories\MPU6050\VCAN_MPU6050.c
#        -D DEBUG -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\VCAN_MPU6050.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\VCAN_MPU6050.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Board\Accessories\MPU6050\VCAN_MPU6050.c
      1          #include "VCAN_MPU6050.h"
      2          #include "VCAN_IO_I2C.h"
      3          #include "datamap.h"
      4          #include "include.h"
      5          

   \                                 In section .bss, align 4
      6          uint8_t buffer[14];
   \                     buffer:
   \   00000000                      DS8 16
      7          

   \                                 In section .bss, align 4
      8          int16_t  MPU6050_FIFO[6][11];
   \                     MPU6050_FIFO:
   \   00000000                      DS8 132

   \                                 In section .bss, align 2
      9          int16_t Gx_offset=0,Gy_offset=0,Gz_offset=0;
   \                     Gx_offset:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     Gy_offset:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     Gz_offset:
   \   00000000                      DS8 2
     10          
     11          
     12          /**************************实现函数********************************************
     13          *函数原型:		void  MPU6050_newValues(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz)
     14          *功　　能:	    将新的ADC数据更新到 FIFO数组，进行滤波处理
     15          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     16          void  MPU6050_newValues(int16_t ax,int16_t ay,int16_t az,int16_t gx,int16_t gy,int16_t gz)
     17          {
   \                     MPU6050_newValues: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xF9BD 0x4014      LDRSH    R4,[SP, #+20]
   \   00000006   0xF9BD 0x5018      LDRSH    R5,[SP, #+24]
     18              unsigned char i ;
     19              int32_t sum=0;
   \   0000000A   0x2700             MOVS     R7,#+0
     20              for(i=1;i<10;i++){	//FIFO 操作  六轴更新数据
   \   0000000C   0xF05F 0x0C01      MOVS     R12,#+1
   \   00000010   0x4666             MOV      R6,R12
   \                     ??MPU6050_newValues_0: (+1)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E0A             CMP      R6,#+10
   \   00000016   0xDA53             BGE.N    ??MPU6050_newValues_1
     21              MPU6050_FIFO[0][i-1]=MPU6050_FIFO[0][i];
   \   00000018   0x.... 0x....      LDR.W    R12,??DataTable5
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0xF83C 0xC016      LDRH     R12,[R12, R6, LSL #+1]
   \   00000022   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0xEB1E 0x0E46      ADDS     LR,LR,R6, LSL #+1
   \   0000002C   0xF82E 0xCC02      STRH     R12,[LR, #-2]
     22              MPU6050_FIFO[1][i-1]=MPU6050_FIFO[1][i];
   \   00000030   0x.... 0x....      LDR.W    R12,??DataTable5
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   0000003A   0xF8BC 0xC016      LDRH     R12,[R12, #+22]
   \   0000003E   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0xEB1E 0x0E46      ADDS     LR,LR,R6, LSL #+1
   \   00000048   0xF8AE 0xC014      STRH     R12,[LR, #+20]
     23              MPU6050_FIFO[2][i-1]=MPU6050_FIFO[2][i];
   \   0000004C   0x.... 0x....      LDR.W    R12,??DataTable5
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   00000056   0xF8BC 0xC02C      LDRH     R12,[R12, #+44]
   \   0000005A   0x.... 0x....      LDR.W    LR,??DataTable5
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0xEB1E 0x0E46      ADDS     LR,LR,R6, LSL #+1
   \   00000064   0xF8AE 0xC02A      STRH     R12,[LR, #+42]
     24              MPU6050_FIFO[3][i-1]=MPU6050_FIFO[3][i];
   \   00000068   0x.... 0x....      LDR.W    R12,??DataTable5
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   00000072   0xF8BC 0xC042      LDRH     R12,[R12, #+66]
   \   00000076   0x.... 0x....      LDR.W    LR,??DataTable5
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0xEB1E 0x0E46      ADDS     LR,LR,R6, LSL #+1
   \   00000080   0xF8AE 0xC040      STRH     R12,[LR, #+64]
     25              MPU6050_FIFO[4][i-1]=MPU6050_FIFO[4][i];
   \   00000084   0x.... 0x....      LDR.W    R12,??DataTable5
   \   00000088   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008A   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   0000008E   0xF8BC 0xC058      LDRH     R12,[R12, #+88]
   \   00000092   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000096   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000098   0xEB1E 0x0E46      ADDS     LR,LR,R6, LSL #+1
   \   0000009C   0xF8AE 0xC056      STRH     R12,[LR, #+86]
     26              MPU6050_FIFO[5][i-1]=MPU6050_FIFO[5][i];
   \   000000A0   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000000A4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A6   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   000000AA   0xF8BC 0xC06E      LDRH     R12,[R12, #+110]
   \   000000AE   0x.... 0x....      LDR.W    LR,??DataTable5
   \   000000B2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B4   0xEB1E 0x0E46      ADDS     LR,LR,R6, LSL #+1
   \   000000B8   0xF8AE 0xC06C      STRH     R12,[LR, #+108]
     27              }
   \   000000BC   0x1C76             ADDS     R6,R6,#+1
   \   000000BE   0xE7A8             B.N      ??MPU6050_newValues_0
     28              MPU6050_FIFO[0][9]=ax;//将新的数据放置到 数据的最后面
   \                     ??MPU6050_newValues_1: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000000C4   0xF8AC 0x0012      STRH     R0,[R12, #+18]
     29              MPU6050_FIFO[1][9]=ay;
   \   000000C8   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000000CC   0xF8AC 0x1028      STRH     R1,[R12, #+40]
     30              MPU6050_FIFO[2][9]=az;
   \   000000D0   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000000D4   0xF8AC 0x203E      STRH     R2,[R12, #+62]
     31              MPU6050_FIFO[3][9]=gx;
   \   000000D8   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000000DC   0xF8AC 0x3054      STRH     R3,[R12, #+84]
     32              MPU6050_FIFO[4][9]=gy;
   \   000000E0   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000000E4   0xF8AC 0x406A      STRH     R4,[R12, #+106]
     33              MPU6050_FIFO[5][9]=gz;
   \   000000E8   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000000EC   0xF8AC 0x5080      STRH     R5,[R12, #+128]
     34          
     35              sum=0;
   \   000000F0   0xF05F 0x0C00      MOVS     R12,#+0
   \   000000F4   0x4667             MOV      R7,R12
     36              for(i=0;i<10;i++)
   \   000000F6   0xF05F 0x0C00      MOVS     R12,#+0
   \   000000FA   0x4666             MOV      R6,R12
   \                     ??MPU6050_newValues_2: (+1)
   \   000000FC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FE   0x2E0A             CMP      R6,#+10
   \   00000100   0xDA08             BGE.N    ??MPU6050_newValues_3
     37              {	//求当前数组的和，再取平均值
     38                  sum+=MPU6050_FIFO[0][i];
   \   00000102   0x.... 0x....      LDR.W    R12,??DataTable5
   \   00000106   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000108   0xF93C 0xC016      LDRSH    R12,[R12, R6, LSL #+1]
   \   0000010C   0xEB17 0x070C      ADDS     R7,R7,R12
     39              }
   \   00000110   0x1C76             ADDS     R6,R6,#+1
   \   00000112   0xE7F3             B.N      ??MPU6050_newValues_2
     40              MPU6050_FIFO[0][10]=sum/10;
   \                     ??MPU6050_newValues_3: (+1)
   \   00000114   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000118   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   0000011C   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000120   0xF8AE 0xC014      STRH     R12,[LR, #+20]
     41          
     42              sum=0;
   \   00000124   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000128   0x4667             MOV      R7,R12
     43              for(i=0;i<10;i++)
   \   0000012A   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000012E   0x4666             MOV      R6,R12
   \                     ??MPU6050_newValues_4: (+1)
   \   00000130   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000132   0x2E0A             CMP      R6,#+10
   \   00000134   0xDA0A             BGE.N    ??MPU6050_newValues_5
     44              {
     45                  sum+=MPU6050_FIFO[1][i];
   \   00000136   0x.... 0x....      LDR.W    R12,??DataTable5
   \   0000013A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000013C   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   00000140   0xF9BC 0xC016      LDRSH    R12,[R12, #+22]
   \   00000144   0xFA07 0xF78C      SXTAH    R7,R7,R12
     46              }
   \   00000148   0x1C76             ADDS     R6,R6,#+1
   \   0000014A   0xE7F1             B.N      ??MPU6050_newValues_4
     47              MPU6050_FIFO[1][10]=sum/10;
   \                     ??MPU6050_newValues_5: (+1)
   \   0000014C   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000150   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   00000154   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000158   0xF8AE 0xC02A      STRH     R12,[LR, #+42]
     48          
     49              sum=0;
   \   0000015C   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000160   0x4667             MOV      R7,R12
     50              for(i=0;i<10;i++)
   \   00000162   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000166   0x4666             MOV      R6,R12
   \                     ??MPU6050_newValues_6: (+1)
   \   00000168   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000016A   0x2E0A             CMP      R6,#+10
   \   0000016C   0xDA0A             BGE.N    ??MPU6050_newValues_7
     51              {
     52                sum+=MPU6050_FIFO[2][i];
   \   0000016E   0x.... 0x....      LDR.W    R12,??DataTable5
   \   00000172   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000174   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   00000178   0xF9BC 0xC02C      LDRSH    R12,[R12, #+44]
   \   0000017C   0xFA07 0xF78C      SXTAH    R7,R7,R12
     53              }
   \   00000180   0x1C76             ADDS     R6,R6,#+1
   \   00000182   0xE7F1             B.N      ??MPU6050_newValues_6
     54              MPU6050_FIFO[2][10]=sum/10;
   \                     ??MPU6050_newValues_7: (+1)
   \   00000184   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000188   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   0000018C   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000190   0xF8AE 0xC040      STRH     R12,[LR, #+64]
     55          
     56              sum=0;
   \   00000194   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000198   0x4667             MOV      R7,R12
     57              for(i=0;i<10;i++)
   \   0000019A   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000019E   0x4666             MOV      R6,R12
   \                     ??MPU6050_newValues_8: (+1)
   \   000001A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001A2   0x2E0A             CMP      R6,#+10
   \   000001A4   0xDA0A             BGE.N    ??MPU6050_newValues_9
     58              {
     59                sum+=MPU6050_FIFO[3][i];
   \   000001A6   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000001AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001AC   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   000001B0   0xF9BC 0xC042      LDRSH    R12,[R12, #+66]
   \   000001B4   0xFA07 0xF78C      SXTAH    R7,R7,R12
     60              }
   \   000001B8   0x1C76             ADDS     R6,R6,#+1
   \   000001BA   0xE7F1             B.N      ??MPU6050_newValues_8
     61              MPU6050_FIFO[3][10]=sum/10;
   \                     ??MPU6050_newValues_9: (+1)
   \   000001BC   0xF05F 0x0C0A      MOVS     R12,#+10
   \   000001C0   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   000001C4   0x.... 0x....      LDR.W    LR,??DataTable5
   \   000001C8   0xF8AE 0xC056      STRH     R12,[LR, #+86]
     62          
     63              sum=0;
   \   000001CC   0xF05F 0x0C00      MOVS     R12,#+0
   \   000001D0   0x4667             MOV      R7,R12
     64              for(i=0;i<10;i++)
   \   000001D2   0xF05F 0x0C00      MOVS     R12,#+0
   \   000001D6   0x4666             MOV      R6,R12
   \                     ??MPU6050_newValues_10: (+1)
   \   000001D8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001DA   0x2E0A             CMP      R6,#+10
   \   000001DC   0xDA0A             BGE.N    ??MPU6050_newValues_11
     65              {
     66                sum+=MPU6050_FIFO[4][i];
   \   000001DE   0x.... 0x....      LDR.W    R12,??DataTable5
   \   000001E2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001E4   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   000001E8   0xF9BC 0xC058      LDRSH    R12,[R12, #+88]
   \   000001EC   0xFA07 0xF78C      SXTAH    R7,R7,R12
     67              }
   \   000001F0   0x1C76             ADDS     R6,R6,#+1
   \   000001F2   0xE7F1             B.N      ??MPU6050_newValues_10
     68              MPU6050_FIFO[4][10]=sum/10;
   \                     ??MPU6050_newValues_11: (+1)
   \   000001F4   0xF05F 0x0C0A      MOVS     R12,#+10
   \   000001F8   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   000001FC   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000200   0xF8AE 0xC06C      STRH     R12,[LR, #+108]
     69          
     70              sum=0;
   \   00000204   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000208   0x4667             MOV      R7,R12
     71              for(i=0;i<10;i++)
   \   0000020A   0xF05F 0x0C00      MOVS     R12,#+0
   \   0000020E   0x4666             MOV      R6,R12
   \                     ??MPU6050_newValues_12: (+1)
   \   00000210   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000212   0x2E0A             CMP      R6,#+10
   \   00000214   0xDA0A             BGE.N    ??MPU6050_newValues_13
     72              {
     73                sum+=MPU6050_FIFO[5][i];
   \   00000216   0x.... 0x....      LDR.W    R12,??DataTable5
   \   0000021A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000021C   0xEB1C 0x0C46      ADDS     R12,R12,R6, LSL #+1
   \   00000220   0xF9BC 0xC06E      LDRSH    R12,[R12, #+110]
   \   00000224   0xFA07 0xF78C      SXTAH    R7,R7,R12
     74              }
   \   00000228   0x1C76             ADDS     R6,R6,#+1
   \   0000022A   0xE7F1             B.N      ??MPU6050_newValues_12
     75              MPU6050_FIFO[5][10]=sum/10;
   \                     ??MPU6050_newValues_13: (+1)
   \   0000022C   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000230   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   00000234   0x.... 0x....      LDR.W    LR,??DataTable5
   \   00000238   0xF8AE 0xC082      STRH     R12,[LR, #+130]
     76          }
   \   0000023C   0xBDF0             POP      {R4-R7,PC}       ;; return
     77          
     78          /**************************实现函数********************************************
     79          *函数原型:		void MPU6050_setClockSource(uint8_t source)
     80          *功　　能:	    设置  MPU6050 的时钟源
     81           * CLK_SEL | Clock Source
     82           * --------+--------------------------------------
     83           * 0       | Internal oscillator
     84           * 1       | PLL with X Gyro reference
     85           * 2       | PLL with Y Gyro reference
     86           * 3       | PLL with Z Gyro reference
     87           * 4       | PLL with external 32.768kHz reference
     88           * 5       | PLL with external 19.2MHz reference
     89           * 6       | Reserved
     90           * 7       | Stops the clock and keeps the timing generator in reset
     91          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     92          void MPU6050_setClockSource(uint8_t source){
   \                     MPU6050_setClockSource: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     93              IICwriteBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2303             MOVS     R3,#+3
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0x216B             MOVS     R1,#+107
   \   00000012   0x20D0             MOVS     R0,#+208
   \   00000014   0x.... 0x....      BL       IICwriteBits
     94          //                0xd0            0x6b                      2                         3                 形参
     95          }
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     96          /**************************实现函数********************************************
     97          *函数原型:		void MPU6050_setFullScaleGyroscopeRange(uint8_t range)
     98          *功　　能:	    设置  MPU6050 陀螺仪的最大量程
     99          *******************************************************************************/
    100          /** Set full-scale gyroscope range.
    101           * @param range New full-scale gyroscope range value
    102           * @see getFullScaleRange()
    103           * @see MPU6050_GYRO_FS_250
    104           * @see MPU6050_RA_GYRO_CONFIG
    105           * @see MPU6050_GCONFIG_FS_SEL_BIT
    106           * @see MPU6050_GCONFIG_FS_SEL_LENGTH
    107           */

   \                                 In section .text, align 2, keep-with-next
    108          void MPU6050_setFullScaleGyroRange(uint8_t range) {
   \                     MPU6050_setFullScaleGyroRange: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    109              IICwriteBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2302             MOVS     R3,#+2
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x211B             MOVS     R1,#+27
   \   00000012   0x20D0             MOVS     R0,#+208
   \   00000014   0x.... 0x....      BL       IICwriteBits
    110          }
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    111          
    112          /**************************实现函数********************************************
    113          *函数原型:		void MPU6050_setFullScaleAccelRange(uint8_t range)
    114          *功　　能:	    设置  MPU6050 加速度计的最大量程
    115          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    116          void MPU6050_setFullScaleAccelRange(uint8_t range) {
   \                     MPU6050_setFullScaleAccelRange: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    117              IICwriteBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, range);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2302             MOVS     R3,#+2
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x211C             MOVS     R1,#+28
   \   00000012   0x20D0             MOVS     R0,#+208
   \   00000014   0x.... 0x....      BL       IICwriteBits
    118          }
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    119          
    120          /**************************实现函数********************************************
    121          *函数原型:		void MPU6050_setSleepEnabled(uint8_t enabled)
    122          *功　　能:	    设置  MPU6050 是否进入睡眠模式
    123          				enabled =1   睡觉
    124          			    enabled =0   工作
    125          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          void MPU6050_setSleepEnabled(uint8_t enabled) {
   \                     MPU6050_setSleepEnabled: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    127              IICwriteBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2206             MOVS     R2,#+6
   \   0000000A   0x216B             MOVS     R1,#+107
   \   0000000C   0x20D0             MOVS     R0,#+208
   \   0000000E   0x.... 0x....      BL       IICwriteBit
    128          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    129          
    130          /**************************实现函数********************************************
    131          *函数原型:		uint8_t MPU6050_getDeviceID(void)
    132          *功　　能:	    读取  MPU6050 WHO_AM_I 标识	 将返回 0x68
    133          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    134          uint8_t MPU6050_getDeviceID(void) {
   \                     MPU6050_getDeviceID: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    135          
    136              IICreadBytes(devAddr, MPU6050_RA_WHO_AM_I, 1, buffer);
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable5_1
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x2175             MOVS     R1,#+117
   \   0000000A   0x20D0             MOVS     R0,#+208
   \   0000000C   0x.... 0x....      BL       IICreadBytes
    137              return buffer[0];
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    138          }
    139          
    140          /**************************实现函数********************************************
    141          *函数原型:		uint8_t MPU6050_testConnection(void)
    142          *功　　能:	    检测MPU6050 是否已经连接
    143          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          uint8_t MPU6050_testConnection(void) {
   \                     MPU6050_testConnection: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    145             if(MPU6050_getDeviceID() == 0x68)  //0b01101000;
   \   00000002   0x.... 0x....      BL       MPU6050_getDeviceID
   \   00000006   0x2868             CMP      R0,#+104
   \   00000008   0xD101             BNE.N    ??MPU6050_testConnection_0
    146             return 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??MPU6050_testConnection_1
    147             	else return 0;
   \                     ??MPU6050_testConnection_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_testConnection_1: (+1)
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    148          }
    149          
    150          /**************************实现函数*******************************************
    151          *函数原型:  设置低通滤波器配置
    152          *功      能:
    153          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    154          void MPU6050_setDLPFMode(uint8_t mode){
   \                     MPU6050_setDLPFMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    155              IICwriteBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x2303             MOVS     R3,#+3
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0x211A             MOVS     R1,#+26
   \   00000012   0x20D0             MOVS     R0,#+208
   \   00000014   0x.... 0x....      BL       IICwriteBits
    156          }
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    157          
    158          /**************************实现函数*******************************************
    159          * 开启加速度器X轴的安全自测功能。
    160          * @安全自测启用参数
    161          * @请参见MPU6050_RA_ACCEL_CONFIG字段
    162          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    163          void MPU6050_setAccelXSelfTest(uint8_t enabled) {
   \                     MPU6050_setAccelXSelfTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    164              IICwriteBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_XA_ST_BIT, enabled);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2207             MOVS     R2,#+7
   \   0000000A   0x211C             MOVS     R1,#+28
   \   0000000C   0x20D0             MOVS     R0,#+208
   \   0000000E   0x.... 0x....      BL       IICwriteBit
    165          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    166          
    167          /**************************实现函数*******************************************
    168          * 开启加速度器Y轴的安全自测功能。
    169          * @安全自测启用参数
    170          * @请参见MPU6050_RA_ACCEL_CONFIG字段
    171          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    172          void MPU6050_setAccelYSelfTest(uint8_t enabled) {
   \                     MPU6050_setAccelYSelfTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    173              IICwriteBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_YA_ST_BIT, enabled);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2206             MOVS     R2,#+6
   \   0000000A   0x211C             MOVS     R1,#+28
   \   0000000C   0x20D0             MOVS     R0,#+208
   \   0000000E   0x.... 0x....      BL       IICwriteBit
    174          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    175          
    176          
    177          
    178          /**************************实现函数*******************************************
    179          * 开启加速度器Z轴的安全自测功能。
    180          * @安全自测启用参数
    181          * @请参见MPU6050_RA_ACCEL_CONFIG字段
    182          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    183          void MPU6050_setAccelZSelfTest(uint8_t enabled) {
   \                     MPU6050_setAccelZSelfTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    184              IICwriteBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ZA_ST_BIT, enabled);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2205             MOVS     R2,#+5
   \   0000000A   0x211C             MOVS     R1,#+28
   \   0000000C   0x20D0             MOVS     R0,#+208
   \   0000000E   0x.... 0x....      BL       IICwriteBit
    185          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    186          
    187          
    188          
    189          /**************************实现函数********************************************
    190          *函数原型:		void MPU6050_setI2CMasterModeEnabled(uint8_t enabled)
    191          *功　　能:	    设置 MPU6050 是否为AUX I2C线的主机
    192          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    193          void MPU6050_setI2CMasterModeEnabled(uint8_t enabled) {
   \                     MPU6050_setI2CMasterModeEnabled: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    194              IICwriteBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2205             MOVS     R2,#+5
   \   0000000A   0x216A             MOVS     R1,#+106
   \   0000000C   0x20D0             MOVS     R0,#+208
   \   0000000E   0x.... 0x....      BL       IICwriteBit
    195          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    196          
    197          /**************************实现函数********************************************
    198          *函数原型:		void MPU6050_setI2CBypassEnabled(uint8_t enabled)
    199          *功　　能:	    设置 MPU6050 是否为AUX I2C线的主机
    200          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    201          void MPU6050_setI2CBypassEnabled(uint8_t enabled) {
   \                     MPU6050_setI2CBypassEnabled: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    202              IICwriteBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, enabled);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x2137             MOVS     R1,#+55
   \   0000000C   0x20D0             MOVS     R0,#+208
   \   0000000E   0x.... 0x....      BL       IICwriteBit
    203          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    204          
    205          /**************************实现函数********************************************
    206          *函数原型:		void MPU6050_initialize(void)
    207          *功　　能:	    初始化 	MPU6050 以进入可用状态。
    208          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          void MPU6050_initialize(void) 
    210          {
   \                     MPU6050_initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    211              int16_t temp[6];
    212              unsigned char i;
    213          
    214              MPU6050_setClockSource(MPU6050_CLOCK_PLL_XGYRO);    //设置时钟
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       MPU6050_setClockSource
    215              MPU6050_setFullScaleGyroRange(MPU6050_GYRO_FS_1000);//陀螺仪最大量程 +-1000度每秒
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x.... 0x....      BL       MPU6050_setFullScaleGyroRange
    216              MPU6050_setFullScaleAccelRange(MPU6050_ACCEL_FS_2);	//加速度度最大量程 +-2G
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       MPU6050_setFullScaleAccelRange
    217              MPU6050_setDLPFMode(MPU6050_DLPF_BW_98);            //设置低通滤波器，98Hz
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       MPU6050_setDLPFMode
    218              MPU6050_setSleepEnabled(0);                         //进入工作状态
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       MPU6050_setSleepEnabled
    219              MPU6050_setI2CMasterModeEnabled(0);	                //不让MPU6050 控制AUXI2C
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       MPU6050_setI2CMasterModeEnabled
    220              MPU6050_setI2CBypassEnabled(1);	                //主控制器的I2C与MPU6050的AUXI2C直通。控制器可以直接访问HMC5883L
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       MPU6050_setI2CBypassEnabled
    221          	
    222          
    223          	//配置MPU6050 的中断模式 和中断电平模式
    224          	IICwriteBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, 0);
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x2207             MOVS     R2,#+7
   \   00000032   0x2137             MOVS     R1,#+55
   \   00000034   0x20D0             MOVS     R0,#+208
   \   00000036   0x.... 0x....      BL       IICwriteBit
    225          	IICwriteBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, 0);
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0x2206             MOVS     R2,#+6
   \   0000003E   0x2137             MOVS     R1,#+55
   \   00000040   0x20D0             MOVS     R0,#+208
   \   00000042   0x.... 0x....      BL       IICwriteBit
    226          	IICwriteBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, 1);
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x2205             MOVS     R2,#+5
   \   0000004A   0x2137             MOVS     R1,#+55
   \   0000004C   0x20D0             MOVS     R0,#+208
   \   0000004E   0x.... 0x....      BL       IICwriteBit
    227          	IICwriteBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_RD_CLEAR_BIT, 1);
   \   00000052   0x2301             MOVS     R3,#+1
   \   00000054   0x2204             MOVS     R2,#+4
   \   00000056   0x2137             MOVS     R1,#+55
   \   00000058   0x20D0             MOVS     R0,#+208
   \   0000005A   0x.... 0x....      BL       IICwriteBit
    228          	//开数据转换完成中断
    229                  IICwriteBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, 1);
   \   0000005E   0x2301             MOVS     R3,#+1
   \   00000060   0x2200             MOVS     R2,#+0
   \   00000062   0x2138             MOVS     R1,#+56
   \   00000064   0x20D0             MOVS     R0,#+208
   \   00000066   0x.... 0x....      BL       IICwriteBit
    230          
    231              for(i=0;i<10;i++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x0004             MOVS     R4,R0
   \                     ??MPU6050_initialize_0: (+1)
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0x2C0A             CMP      R4,#+10
   \   00000072   0xDA18             BGE.N    ??MPU6050_initialize_1
    232              {//更新FIFO数组
    233          	DELAY_US(50);
   \   00000074   0x....             LDR.N    R0,??DataTable5_2
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x2132             MOVS     R1,#+50
   \   0000007A   0x4348             MULS     R0,R1,R0
   \   0000007C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000080   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000084   0x.... 0x....      BL       systick_delay
    234          	MPU6050_getMotion6(&temp[0],&temp[1],&temp[2],&temp[3],&temp[4],&temp[5]);
   \   00000088   0xF10D 0x0012      ADD      R0,SP,#+18
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   \   0000008E   0xA804             ADD      R0,SP,#+16
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0xF10D 0x030E      ADD      R3,SP,#+14
   \   00000096   0xAA03             ADD      R2,SP,#+12
   \   00000098   0xF10D 0x010A      ADD      R1,SP,#+10
   \   0000009C   0xA802             ADD      R0,SP,#+8
   \   0000009E   0x.... 0x....      BL       MPU6050_getMotion6
    235              }
   \   000000A2   0x1C64             ADDS     R4,R4,#+1
   \   000000A4   0xE7E3             B.N      ??MPU6050_initialize_0
    236          	Gx_offset = Config.dGx_offset;
   \                     ??MPU6050_initialize_1: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable5_3
   \   000000A8   0x8840             LDRH     R0,[R0, #+2]
   \   000000AA   0x....             LDR.N    R1,??DataTable5_4
   \   000000AC   0x8008             STRH     R0,[R1, #+0]
    237          	Gy_offset = Config.dGy_offset;
   \   000000AE   0x....             LDR.N    R0,??DataTable5_3
   \   000000B0   0x8880             LDRH     R0,[R0, #+4]
   \   000000B2   0x....             LDR.N    R1,??DataTable5_5
   \   000000B4   0x8008             STRH     R0,[R1, #+0]
    238          	Gz_offset = Config.dGz_offset;																		 
   \   000000B6   0x....             LDR.N    R0,??DataTable5_3
   \   000000B8   0x88C0             LDRH     R0,[R0, #+6]
   \   000000BA   0x....             LDR.N    R1,??DataTable5_6
   \   000000BC   0x8008             STRH     R0,[R1, #+0]
    239          }
   \   000000BE   0xB006             ADD      SP,SP,#+24
   \   000000C0   0xBD10             POP      {R4,PC}          ;; return
    240          
    241          /**************************实现函数********************************************
    242          *函数原型:		unsigned char MPU6050_is_DRY(void)
    243          *功　　能:	    检查 MPU6050的中断引脚，测试是否完成转换
    244          返回 1  转换完成
    245          0 数据寄存器还没有更新
    246          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    247          unsigned char MPU6050_is_DRY(void)
    248          {
   \                     MPU6050_is_DRY: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    249              if(gpio_get(PTC18)){
   \   00000002   0x2052             MOVS     R0,#+82
   \   00000004   0x.... 0x....      BL       gpio_get
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??MPU6050_is_DRY_0
    250          	  return 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??MPU6050_is_DRY_1
    251          	 }
    252          	 else return 0;
   \                     ??MPU6050_is_DRY_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??MPU6050_is_DRY_1: (+1)
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    253          }
    254          

   \                                 In section .bss, align 2
    255          int16_t MPU6050_Lastax,MPU6050_Lastay,MPU6050_Lastaz
   \                     MPU6050_Lastax:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     MPU6050_Lastay:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     MPU6050_Lastaz:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    256          				,MPU6050_Lastgx,MPU6050_Lastgy,MPU6050_Lastgz;
   \                     MPU6050_Lastgx:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     MPU6050_Lastgy:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     MPU6050_Lastgz:
   \   00000000                      DS8 2
    257          /**************************实现函数********************************************
    258          *函数原型:		void MPU6050_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    259          *功　　能:	    读取 MPU6050的当前测量值 获得姿态
    260          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void MPU6050_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
   \                     MPU6050_getMotion6: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000012   0xF8DD 0x902C      LDR      R9,[SP, #+44]
    262            
    263          	if(MPU6050_is_DRY())            //检查MPU6050的中断引脚，测试是否完成转换
   \   00000016   0x.... 0x....      BL       MPU6050_is_DRY
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD06D             BEQ.N    ??MPU6050_getMotion6_0
    264                  {                                   
    265                    IICreadBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 14, buffer);//读取指定设备 指定寄存器的 length个值
   \   0000001E   0x....             LDR.N    R3,??DataTable5_1
   \   00000020   0x220E             MOVS     R2,#+14
   \   00000022   0x213B             MOVS     R1,#+59
   \   00000024   0x20D0             MOVS     R0,#+208
   \   00000026   0x.... 0x....      BL       IICreadBytes
    266              
    267                    MPU6050_Lastax=(((int16_t)buffer[0])  << 8) | buffer[1] ;
   \   0000002A   0x....             LDR.N    R0,??DataTable5_1
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable5_1
   \   00000030   0x7849             LDRB     R1,[R1, #+1]
   \   00000032   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000036   0x....             LDR.N    R1,??DataTable5_7
   \   00000038   0x8008             STRH     R0,[R1, #+0]
    268                    MPU6050_Lastay=(((int16_t)buffer[2])  << 8) | buffer[3] ;
   \   0000003A   0x....             LDR.N    R0,??DataTable5_1
   \   0000003C   0x7880             LDRB     R0,[R0, #+2]
   \   0000003E   0x....             LDR.N    R1,??DataTable5_1
   \   00000040   0x78C9             LDRB     R1,[R1, #+3]
   \   00000042   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000046   0x....             LDR.N    R1,??DataTable5_8
   \   00000048   0x8008             STRH     R0,[R1, #+0]
    269                    MPU6050_Lastaz=(((int16_t)buffer[4])  << 8) | buffer[5] ;
   \   0000004A   0x....             LDR.N    R0,??DataTable5_1
   \   0000004C   0x7900             LDRB     R0,[R0, #+4]
   \   0000004E   0x....             LDR.N    R1,??DataTable5_1
   \   00000050   0x7949             LDRB     R1,[R1, #+5]
   \   00000052   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000056   0x....             LDR.N    R1,??DataTable5_9
   \   00000058   0x8008             STRH     R0,[R1, #+0]
    270                    //跳过温度ADC
    271                    MPU6050_Lastgx=(((int16_t)buffer[8])  << 8) | buffer[9] ;
   \   0000005A   0x....             LDR.N    R0,??DataTable5_1
   \   0000005C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000005E   0x....             LDR.N    R1,??DataTable5_1
   \   00000060   0x7A49             LDRB     R1,[R1, #+9]
   \   00000062   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000066   0x....             LDR.N    R1,??DataTable5_10
   \   00000068   0x8008             STRH     R0,[R1, #+0]
    272                    MPU6050_Lastgy=(((int16_t)buffer[10]) << 8) | buffer[11];
   \   0000006A   0x....             LDR.N    R0,??DataTable5_1
   \   0000006C   0x7A80             LDRB     R0,[R0, #+10]
   \   0000006E   0x....             LDR.N    R1,??DataTable5_1
   \   00000070   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000072   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000076   0x....             LDR.N    R1,??DataTable5_11
   \   00000078   0x8008             STRH     R0,[R1, #+0]
    273                    MPU6050_Lastgz=(((int16_t)buffer[12]) << 8) | buffer[13];
   \   0000007A   0x....             LDR.N    R0,??DataTable5_1
   \   0000007C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000007E   0x....             LDR.N    R1,??DataTable5_1
   \   00000080   0x7B49             LDRB     R1,[R1, #+13]
   \   00000082   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000086   0x....             LDR.N    R1,??DataTable5_12
   \   00000088   0x8008             STRH     R0,[R1, #+0]
    274                    MPU6050_newValues(MPU6050_Lastax,MPU6050_Lastay,MPU6050_Lastaz
    275          		,MPU6050_Lastgx,MPU6050_Lastgy,MPU6050_Lastgz);
   \   0000008A   0x....             LDR.N    R0,??DataTable5_12
   \   0000008C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000090   0x9001             STR      R0,[SP, #+4]
   \   00000092   0x....             LDR.N    R0,??DataTable5_11
   \   00000094   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000098   0x9000             STR      R0,[SP, #+0]
   \   0000009A   0x....             LDR.N    R0,??DataTable5_10
   \   0000009C   0xF9B0 0x3000      LDRSH    R3,[R0, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable5_9
   \   000000A2   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   000000A6   0x....             LDR.N    R0,??DataTable5_8
   \   000000A8   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000000AC   0x....             LDR.N    R0,??DataTable5_7
   \   000000AE   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000B2   0x.... 0x....      BL       MPU6050_newValues
    276                    *ax  =MPU6050_FIFO[0][10];
   \   000000B6   0x....             LDR.N    R0,??DataTable5
   \   000000B8   0x8A80             LDRH     R0,[R0, #+20]
   \   000000BA   0x8020             STRH     R0,[R4, #+0]
    277                    *ay  =MPU6050_FIFO[1][10];
   \   000000BC   0x....             LDR.N    R0,??DataTable5
   \   000000BE   0x8D40             LDRH     R0,[R0, #+42]
   \   000000C0   0x8028             STRH     R0,[R5, #+0]
    278                    *az = MPU6050_FIFO[2][10];
   \   000000C2   0x....             LDR.N    R0,??DataTable5
   \   000000C4   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   000000C8   0x8030             STRH     R0,[R6, #+0]
    279                    *gx  =MPU6050_FIFO[3][10]-Gx_offset;
   \   000000CA   0x....             LDR.N    R0,??DataTable5
   \   000000CC   0xF8B0 0x0056      LDRH     R0,[R0, #+86]
   \   000000D0   0x....             LDR.N    R1,??DataTable5_4
   \   000000D2   0x8809             LDRH     R1,[R1, #+0]
   \   000000D4   0x1A40             SUBS     R0,R0,R1
   \   000000D6   0x8038             STRH     R0,[R7, #+0]
    280                    *gy = MPU6050_FIFO[4][10]-Gy_offset;
   \   000000D8   0x....             LDR.N    R0,??DataTable5
   \   000000DA   0xF8B0 0x006C      LDRH     R0,[R0, #+108]
   \   000000DE   0x....             LDR.N    R1,??DataTable5_5
   \   000000E0   0x8809             LDRH     R1,[R1, #+0]
   \   000000E2   0x1A40             SUBS     R0,R0,R1
   \   000000E4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    281                    *gz = MPU6050_FIFO[5][10]-Gz_offset;
   \   000000E8   0x....             LDR.N    R0,??DataTable5
   \   000000EA   0xF8B0 0x0082      LDRH     R0,[R0, #+130]
   \   000000EE   0x....             LDR.N    R1,??DataTable5_6
   \   000000F0   0x8809             LDRH     R1,[R1, #+0]
   \   000000F2   0x1A40             SUBS     R0,R0,R1
   \   000000F4   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   000000F8   0xE020             B.N      ??MPU6050_getMotion6_1
    282                    } 
    283                    else 
    284                    {
    285                    *ax = MPU6050_FIFO[0][10];//=MPU6050_FIFO[0][10];
   \                     ??MPU6050_getMotion6_0: (+1)
   \   000000FA   0x....             LDR.N    R0,??DataTable5
   \   000000FC   0x8A80             LDRH     R0,[R0, #+20]
   \   000000FE   0x8020             STRH     R0,[R4, #+0]
    286                    *ay = MPU6050_FIFO[1][10];//=MPU6050_FIFO[1][10];
   \   00000100   0x....             LDR.N    R0,??DataTable5
   \   00000102   0x8D40             LDRH     R0,[R0, #+42]
   \   00000104   0x8028             STRH     R0,[R5, #+0]
    287                    *az = MPU6050_FIFO[2][10];//=MPU6050_FIFO[2][10];
   \   00000106   0x....             LDR.N    R0,??DataTable5
   \   00000108   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   0000010C   0x8030             STRH     R0,[R6, #+0]
    288                    *gx = MPU6050_FIFO[3][10]-Gx_offset;//=MPU6050_FIFO[3][10];
   \   0000010E   0x....             LDR.N    R0,??DataTable5
   \   00000110   0xF8B0 0x0056      LDRH     R0,[R0, #+86]
   \   00000114   0x....             LDR.N    R1,??DataTable5_4
   \   00000116   0x8809             LDRH     R1,[R1, #+0]
   \   00000118   0x1A40             SUBS     R0,R0,R1
   \   0000011A   0x8038             STRH     R0,[R7, #+0]
    289                    *gy = MPU6050_FIFO[4][10]-Gy_offset;//=MPU6050_FIFO[4][10];
   \   0000011C   0x....             LDR.N    R0,??DataTable5
   \   0000011E   0xF8B0 0x006C      LDRH     R0,[R0, #+108]
   \   00000122   0x....             LDR.N    R1,??DataTable5_5
   \   00000124   0x8809             LDRH     R1,[R1, #+0]
   \   00000126   0x1A40             SUBS     R0,R0,R1
   \   00000128   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    290                    *gz = MPU6050_FIFO[5][10]-Gz_offset;//=MPU6050_FIFO[5][10];
   \   0000012C   0x....             LDR.N    R0,??DataTable5
   \   0000012E   0xF8B0 0x0082      LDRH     R0,[R0, #+130]
   \   00000132   0x....             LDR.N    R1,??DataTable5_6
   \   00000134   0x8809             LDRH     R1,[R1, #+0]
   \   00000136   0x1A40             SUBS     R0,R0,R1
   \   00000138   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    291                    }
    292          }
   \                     ??MPU6050_getMotion6_1: (+1)
   \   0000013C   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    293          

   \                                 In section .text, align 2, keep-with-next
    294          void MPU6050_getlastMotion6(int16_t* ax, int16_t* ay, 
    295          		int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz)
    296          {
   \                     MPU6050_getlastMotion6: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
   \   00000004   0x9D05             LDR      R5,[SP, #+20]
    297          	*ax  =MPU6050_FIFO[0][10];
   \   00000006   0x....             LDR.N    R6,??DataTable5
   \   00000008   0x8AB6             LDRH     R6,[R6, #+20]
   \   0000000A   0x8006             STRH     R6,[R0, #+0]
    298          	*ay  =MPU6050_FIFO[1][10];
   \   0000000C   0x....             LDR.N    R6,??DataTable5
   \   0000000E   0x8D76             LDRH     R6,[R6, #+42]
   \   00000010   0x800E             STRH     R6,[R1, #+0]
    299          	*az = MPU6050_FIFO[2][10];
   \   00000012   0x....             LDR.N    R6,??DataTable5
   \   00000014   0xF8B6 0x6040      LDRH     R6,[R6, #+64]
   \   00000018   0x8016             STRH     R6,[R2, #+0]
    300          	*gx  =MPU6050_FIFO[3][10]-Gx_offset;
   \   0000001A   0x....             LDR.N    R6,??DataTable5
   \   0000001C   0xF8B6 0x6056      LDRH     R6,[R6, #+86]
   \   00000020   0x....             LDR.N    R7,??DataTable5_4
   \   00000022   0x883F             LDRH     R7,[R7, #+0]
   \   00000024   0x1BF6             SUBS     R6,R6,R7
   \   00000026   0x801E             STRH     R6,[R3, #+0]
    301          	*gy = MPU6050_FIFO[4][10]-Gy_offset;
   \   00000028   0x....             LDR.N    R6,??DataTable5
   \   0000002A   0xF8B6 0x606C      LDRH     R6,[R6, #+108]
   \   0000002E   0x....             LDR.N    R7,??DataTable5_5
   \   00000030   0x883F             LDRH     R7,[R7, #+0]
   \   00000032   0x1BF6             SUBS     R6,R6,R7
   \   00000034   0x8026             STRH     R6,[R4, #+0]
    302          	*gz = MPU6050_FIFO[5][10]-Gz_offset;
   \   00000036   0x....             LDR.N    R6,??DataTable5
   \   00000038   0xF8B6 0x6082      LDRH     R6,[R6, #+130]
   \   0000003C   0x....             LDR.N    R7,??DataTable5_6
   \   0000003E   0x883F             LDRH     R7,[R7, #+0]
   \   00000040   0x1BF6             SUBS     R6,R6,R7
   \   00000042   0x802E             STRH     R6,[R5, #+0]
    303          }
   \   00000044   0xBCF0             POP      {R4-R7}
   \   00000046   0x4770             BX       LR               ;; return
    304          
    305          /**************************实现函数********************************************
    306          *函数原型:		void MPU6050_InitGyro_Offset(void)
    307          *功　　能:	    读取 MPU6050的陀螺仪偏置
    308          此时模块应该被静止放置。以测试静止时的陀螺仪输出
    309          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    310          void MPU6050_InitGyro_Offset(void)
    311          {
   \                     MPU6050_InitGyro_Offset: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
    312          	unsigned char i;
    313          	int16_t temp[6];
    314          	int32_t	tempgx=0,tempgy=0,tempgz=0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
    315          	int32_t	tempax=0,tempay=0,tempaz=0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
    316          	Gx_offset=0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable5_4
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
    317          	Gy_offset=0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable5_5
   \   00000022   0x8008             STRH     R0,[R1, #+0]
    318          	Gz_offset=0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x....             LDR.N    R1,??DataTable5_6
   \   00000028   0x8008             STRH     R0,[R1, #+0]
    319          	for(i=0;i<50;i++)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0004             MOVS     R4,R0
   \                     ??MPU6050_InitGyro_Offset_0: (+1)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C32             CMP      R4,#+50
   \   00000032   0xDA18             BGE.N    ??MPU6050_InitGyro_Offset_1
    320                  {
    321            		DELAY_US(100);
   \   00000034   0x....             LDR.N    R0,??DataTable5_2
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x2164             MOVS     R1,#+100
   \   0000003A   0x4348             MULS     R0,R1,R0
   \   0000003C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000040   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000044   0x.... 0x....      BL       systick_delay
    322            		MPU6050_getMotion6(&temp[0],&temp[1],&temp[2],&temp[3],&temp[4],&temp[5]);
   \   00000048   0xF10D 0x0012      ADD      R0,SP,#+18
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0xA804             ADD      R0,SP,#+16
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0xF10D 0x030E      ADD      R3,SP,#+14
   \   00000056   0xAA03             ADD      R2,SP,#+12
   \   00000058   0xF10D 0x010A      ADD      R1,SP,#+10
   \   0000005C   0xA802             ADD      R0,SP,#+8
   \   0000005E   0x.... 0x....      BL       MPU6050_getMotion6
    323            		//LED_Change();
    324          	}
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0xE7E3             B.N      ??MPU6050_InitGyro_Offset_0
    325           	for(i=0;i<100;i++)
   \                     ??MPU6050_InitGyro_Offset_1: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x0004             MOVS     R4,R0
   \                     ??MPU6050_InitGyro_Offset_2: (+1)
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x2C64             CMP      R4,#+100
   \   0000006E   0xDA30             BGE.N    ??MPU6050_InitGyro_Offset_3
    326                  {
    327          		DELAY_US(200);
   \   00000070   0x....             LDR.N    R0,??DataTable5_2
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x21C8             MOVS     R1,#+200
   \   00000076   0x4348             MULS     R0,R1,R0
   \   00000078   0xF44F 0x717A      MOV      R1,#+1000
   \   0000007C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000080   0x.... 0x....      BL       systick_delay
    328          		MPU6050_getMotion6(&temp[0],&temp[1],&temp[2],&temp[3],&temp[4],&temp[5]);
   \   00000084   0xF10D 0x0012      ADD      R0,SP,#+18
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0xA804             ADD      R0,SP,#+16
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0xF10D 0x030E      ADD      R3,SP,#+14
   \   00000092   0xAA03             ADD      R2,SP,#+12
   \   00000094   0xF10D 0x010A      ADD      R1,SP,#+10
   \   00000098   0xA802             ADD      R0,SP,#+8
   \   0000009A   0x.... 0x....      BL       MPU6050_getMotion6
    329          		tempax+= temp[0];
   \   0000009E   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000000A2   0xFA08 0xF880      SXTAH    R8,R8,R0
    330          		tempay+= temp[1];
   \   000000A6   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   000000AA   0xFA09 0xF980      SXTAH    R9,R9,R0
    331          		tempaz+= temp[2];
   \   000000AE   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   000000B2   0xFA0A 0xFA80      SXTAH    R10,R10,R0
    332          		tempgx+= temp[3];
   \   000000B6   0xF9BD 0x000E      LDRSH    R0,[SP, #+14]
   \   000000BA   0xFA05 0xF580      SXTAH    R5,R5,R0
    333          		tempgy+= temp[4];
   \   000000BE   0xF9BD 0x0010      LDRSH    R0,[SP, #+16]
   \   000000C2   0xFA06 0xF680      SXTAH    R6,R6,R0
    334          		tempgz+= temp[5];
   \   000000C6   0xF9BD 0x0012      LDRSH    R0,[SP, #+18]
   \   000000CA   0xFA07 0xF780      SXTAH    R7,R7,R0
    335          		//LED_Change();
    336          	}
   \   000000CE   0x1C64             ADDS     R4,R4,#+1
   \   000000D0   0xE7CB             B.N      ??MPU6050_InitGyro_Offset_2
    337          
    338          	Config.dGx_offset = Gx_offset = tempgx/100;//MPU6050_FIFO[3][10];
   \                     ??MPU6050_InitGyro_Offset_3: (+1)
   \   000000D2   0x2064             MOVS     R0,#+100
   \   000000D4   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   000000D8   0x....             LDR.N    R1,??DataTable5_4
   \   000000DA   0x8008             STRH     R0,[R1, #+0]
   \   000000DC   0x....             LDR.N    R0,??DataTable5_4
   \   000000DE   0x8800             LDRH     R0,[R0, #+0]
   \   000000E0   0x....             LDR.N    R1,??DataTable5_3
   \   000000E2   0x8048             STRH     R0,[R1, #+2]
    339          	Config.dGy_offset = Gy_offset = tempgy/100;//MPU6050_FIFO[4][10];
   \   000000E4   0x2064             MOVS     R0,#+100
   \   000000E6   0xFB96 0xF0F0      SDIV     R0,R6,R0
   \   000000EA   0x....             LDR.N    R1,??DataTable5_5
   \   000000EC   0x8008             STRH     R0,[R1, #+0]
   \   000000EE   0x....             LDR.N    R0,??DataTable5_5
   \   000000F0   0x8800             LDRH     R0,[R0, #+0]
   \   000000F2   0x....             LDR.N    R1,??DataTable5_3
   \   000000F4   0x8088             STRH     R0,[R1, #+4]
    340          	Config.dGz_offset = Gz_offset = tempgz/100;//MPU6050_FIFO[5][10];
   \   000000F6   0x2064             MOVS     R0,#+100
   \   000000F8   0xFB97 0xF0F0      SDIV     R0,R7,R0
   \   000000FC   0x....             LDR.N    R1,??DataTable5_6
   \   000000FE   0x8008             STRH     R0,[R1, #+0]
   \   00000100   0x....             LDR.N    R0,??DataTable5_6
   \   00000102   0x8800             LDRH     R0,[R0, #+0]
   \   00000104   0x....             LDR.N    R1,??DataTable5_3
   \   00000106   0x80C8             STRH     R0,[R1, #+6]
    341          	Write_config();
   \   00000108   0x.... 0x....      BL       Write_config
    342          	tempax/=100;
   \   0000010C   0x2064             MOVS     R0,#+100
   \   0000010E   0xFB98 0xF8F0      SDIV     R8,R8,R0
    343          	tempay/=100;
   \   00000112   0x2064             MOVS     R0,#+100
   \   00000114   0xFB99 0xF9F0      SDIV     R9,R9,R0
    344          	tempaz/=100;
   \   00000118   0x2064             MOVS     R0,#+100
   \   0000011A   0xFB9A 0xFAF0      SDIV     R10,R10,R0
    345          }
   \   0000011E   0xB006             ADD      SP,SP,#+24
   \   00000120   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     MPU6050_FIFO

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     Config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     Gx_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     Gy_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     Gz_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     MPU6050_Lastax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     MPU6050_Lastay

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     MPU6050_Lastaz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     MPU6050_Lastgx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     MPU6050_Lastgy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     MPU6050_Lastgz
    346          
    347          //------------------End of File----------------------------

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   MPU6050_InitGyro_Offset
        56   -> MPU6050_getMotion6
        56   -> Write_config
        56   -> systick_delay
       8   MPU6050_getDeviceID
         8   -> IICreadBytes
      40   MPU6050_getMotion6
        40   -> IICreadBytes
        40   -> MPU6050_is_DRY
        40   -> MPU6050_newValues
      16   MPU6050_getlastMotion6
      32   MPU6050_initialize
        32   -> IICwriteBit
        32   -> MPU6050_getMotion6
        32   -> MPU6050_setClockSource
        32   -> MPU6050_setDLPFMode
        32   -> MPU6050_setFullScaleAccelRange
        32   -> MPU6050_setFullScaleGyroRange
        32   -> MPU6050_setI2CBypassEnabled
        32   -> MPU6050_setI2CMasterModeEnabled
        32   -> MPU6050_setSleepEnabled
        32   -> systick_delay
       8   MPU6050_is_DRY
         8   -> gpio_get
      20   MPU6050_newValues
       8   MPU6050_setAccelXSelfTest
         8   -> IICwriteBit
       8   MPU6050_setAccelYSelfTest
         8   -> IICwriteBit
       8   MPU6050_setAccelZSelfTest
         8   -> IICwriteBit
      16   MPU6050_setClockSource
        16   -> IICwriteBits
      16   MPU6050_setDLPFMode
        16   -> IICwriteBits
      16   MPU6050_setFullScaleAccelRange
        16   -> IICwriteBits
      16   MPU6050_setFullScaleGyroRange
        16   -> IICwriteBits
       8   MPU6050_setI2CBypassEnabled
         8   -> IICwriteBit
       8   MPU6050_setI2CMasterModeEnabled
         8   -> IICwriteBit
       8   MPU6050_setSleepEnabled
         8   -> IICwriteBit
       8   MPU6050_testConnection
         8   -> MPU6050_getDeviceID


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       2  Gx_offset
       2  Gy_offset
       2  Gz_offset
     132  MPU6050_FIFO
     292  MPU6050_InitGyro_Offset
       2  MPU6050_Lastax
       2  MPU6050_Lastay
       2  MPU6050_Lastaz
       2  MPU6050_Lastgx
       2  MPU6050_Lastgy
       2  MPU6050_Lastgz
      24  MPU6050_getDeviceID
     320  MPU6050_getMotion6
      72  MPU6050_getlastMotion6
     194  MPU6050_initialize
      20  MPU6050_is_DRY
     574  MPU6050_newValues
      20  MPU6050_setAccelXSelfTest
      20  MPU6050_setAccelYSelfTest
      20  MPU6050_setAccelZSelfTest
      26  MPU6050_setClockSource
      26  MPU6050_setDLPFMode
      26  MPU6050_setFullScaleAccelRange
      26  MPU6050_setFullScaleGyroRange
      20  MPU6050_setI2CBypassEnabled
      20  MPU6050_setI2CMasterModeEnabled
      20  MPU6050_setSleepEnabled
      18  MPU6050_testConnection
      16  buffer

 
   166 bytes in section .bss
 1 790 bytes in section .text
 
 1 790 bytes of CODE memory
   166 bytes of DATA memory

Errors: none
Warnings: none
