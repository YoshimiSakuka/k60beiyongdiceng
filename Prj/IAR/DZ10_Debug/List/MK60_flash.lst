###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  11:28:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_flash.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_flash.c -D
#        DEBUG -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\MK60_flash.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\MK60_flash.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_flash.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       MK60_flash.c
     11           * @brief      flash函数库
     12           * @author     山外科技
     13           * @version    v5.2
     14           * @date       2014-10-09
     15           */
     16          
     17          
     18          //包含头文件
     19          
     20          #include "MK60_flash.h"
     21          
     22          //宏定义 FCCOB Number
     23          #if defined(MK60DZ10)
     24          #define     FCMD        FTFL_FCCOB0         //FTFL 命令
     25          
     26          #define     FADDR2      FTFL_FCCOB1         //Flash address [23:16]
     27          #define     FADDR1      FTFL_FCCOB2         //Flash address [15:8]
     28          #define     FADDR0      FTFL_FCCOB3         //Flash address [7:0]
     29          
     30          #define     FDATA0      FTFL_FCCOB4         //Data Byte 0       //注意一点，4字节排序，FDATA3是最低位，FDATA0是最高位
     31          #define     FDATA1      FTFL_FCCOB5         //Data Byte 1
     32          #define     FDATA2      FTFL_FCCOB6         //Data Byte 2
     33          #define     FDATA3      FTFL_FCCOB7         //Data Byte 3
     34          #define     FDATA4      FTFL_FCCOB8         //Data Byte 4
     35          #define     FDATA5      FTFL_FCCOB9         //Data Byte 5
     36          #define     FDATA6      FTFL_FCCOBA         //Data Byte 6
     37          #define     FDATA7      FTFL_FCCOBB         //Data Byte 7
     38          
     39          //FCMD 命令
     40          #define     RD1BLK    0x00   // 读整块Flash
     41          #define     RD1SEC    0x01   // 读整个扇区
     42          #define     PGMCHK    0x02   // 写入检查
     43          #define     RDRSRC    0x03   // 读目标数据(4字节)
     44          #define     PGM4      0x06   // 写入长字(4字节)
     45          #define     ERSBLK    0x08   // 擦除整块Flash
     46          #define     ERSSCR    0x09   // 擦除Flash扇区
     47          #define     PGMSEC    0x0B   // 写入扇区
     48          #define     RD1ALL    0x40   // 读所有的块
     49          #define     RDONCE    0x41   // 只读一次
     50          #define     PGMONCE   0x43   // 只写一次
     51          #define     ERSALL    0x44   // 擦除所有块
     52          #define     VFYKEY    0x45   // 验证后门访问钥匙
     53          #define     PGMPART   0x80   // 写入分区
     54          #define     SETRAM    0x81   // 设定FlexRAM功能
     55          
     56          #elif defined(MK60F15)
     57          #define     FCMD        FTFE_FCCOB0         //FTFL 命令
     58          
     59          #define     FADDR2      FTFE_FCCOB1         //Flash address [23:16]
     60          #define     FADDR1      FTFE_FCCOB2         //Flash address [15:8]
     61          #define     FADDR0      FTFE_FCCOB3         //Flash address [7:0]
     62          //Must be 64-bit aligned (Flash address [2:0] = 000)  8字节对齐
     63          
     64          #define     FDATA0      FTFE_FCCOB4         //Data Byte 0       //注意一点，4字节排序，FDATA3是最低位，FDATA0是最高位
     65          #define     FDATA1      FTFE_FCCOB5         //Data Byte 1
     66          #define     FDATA2      FTFE_FCCOB6         //Data Byte 2
     67          #define     FDATA3      FTFE_FCCOB7         //Data Byte 3
     68          #define     FDATA4      FTFE_FCCOB8         //Data Byte 4
     69          #define     FDATA5      FTFE_FCCOB9         //Data Byte 5
     70          #define     FDATA6      FTFE_FCCOBA         //Data Byte 6
     71          #define     FDATA7      FTFE_FCCOBB         //Data Byte 7
     72          
     73          //FCMD 命令
     74          #define     RD1BLK    0x00   // 读整块Flash
     75          #define     RD1SEC    0x01   // 读整个扇区
     76          #define     PGMCHK    0x02   // 写入检查
     77          #define     RDRSRC    0x03   // 读目标数据(8字节)
     78          #define     PGM8      0x07   // 写入长字(8字节)
     79          #define     ERSBLK    0x08   // 擦除整块Flash
     80          #define     ERSSCR    0x09   // 擦除Flash扇区
     81          #define     PGMSEC    0x0B   // 写入扇区
     82          #define     RD1ALL    0x40   // 读所有的块
     83          #define     RDONCE    0x41   // 只读一次
     84          #define     PGMONCE   0x43   // 只写一次
     85          #define     ERSALL    0x44   // 擦除所有块
     86          #define     VFYKEY    0x45   // 验证后门访问钥匙
     87          #define     PGMPART   0x80   // 写入分区
     88          #define     SETRAM    0x81   // 设定FlexRAM功能
     89          
     90          #endif
     91          
     92          
     93          
     94          /*!
     95           *  @brief      Flash命令
     96           *  @return     命令执行结果(1成功，0失败)
     97           *  @since      v5.0
     98           */

   \                                 In section .textrw, align 2, keep-with-next
     99          __RAMFUNC uint8 flash_cmd()
    100          {
    101              //写 FTFL_FSTAT 启动 Flash命令
    102          #if defined(MK60DZ10)
    103              FTFL_FSTAT =    (0
    104                               |  FTFL_FSTAT_CCIF_MASK        // 指令完成标志(写1清0)
    105                               |  FTFL_FSTAT_RDCOLERR_MASK    // 读冲突错误标志(写1清0)
    106                               |  FTFL_FSTAT_ACCERR_MASK      // 访问错误标志位(写1清0)
    107                               |  FTFL_FSTAT_FPVIOL_MASK      // 非法访问保护标志位(写1清0)
    108                              );
   \                     flash_cmd: (+1)
   \   00000000   0x20F0             MOVS     R0,#+240
   \   00000002   0x....             LDR.N    R1,??DataTable4  ;; 0x40020000
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    109          
    110              while(!(FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK));    // 等待命令完成
   \                     ??flash_cmd_0: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable4  ;; 0x40020000
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x0600             LSLS     R0,R0,#+24
   \   0000000C   0xD5FB             BPL.N    ??flash_cmd_0
    111          
    112              // 检查错误标志
    113              if( FTFL_FSTAT & (FTFL_FSTAT_ACCERR_MASK | FTFL_FSTAT_RDCOLERR_MASK | FTFL_FSTAT_FPVIOL_MASK | FTFL_FSTAT_MGSTAT0_MASK))
   \   0000000E   0x....             LDR.N    R0,??DataTable4  ;; 0x40020000
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2171             MOVS     R1,#+113
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD001             BEQ.N    ??flash_cmd_1
    114              {
    115                  return 0 ;                                  //执行命令出错
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE000             B.N      ??flash_cmd_2
    116              }
    117              else
    118              {
    119                  return 1;                                   //执行命令成功
   \                     ??flash_cmd_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??flash_cmd_2: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    120              }
    121          
    122          #elif defined(MK60F15)
    123              FTFE_FSTAT =    (0
    124                               |  FTFE_FSTAT_CCIF_MASK        // 指令完成标志(写1清0)
    125                               |  FTFE_FSTAT_RDCOLERR_MASK    // 读冲突错误标志(写1清0)
    126                               |  FTFE_FSTAT_ACCERR_MASK      // 访问错误标志位(写1清0)
    127                               |  FTFE_FSTAT_FPVIOL_MASK      // 非法访问保护标志位(写1清0)
    128                              );
    129          
    130              while(!(FTFE_FSTAT & FTFE_FSTAT_CCIF_MASK));    // 等待命令完成
    131          
    132              // 检查错误标志
    133              if( FTFE_FSTAT & (FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_RDCOLERR_MASK | FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_MGSTAT0_MASK))
    134              {
    135                  return 0 ;                                  //执行命令出错
    136              }
    137              else
    138              {
    139                  return 1;                                   //执行命令成功
    140              }
    141          
    142          #endif
    143          }
    144          
    145          
    146          /*!
    147           *  @brief      初始化flash
    148           *  @since      v5.0
    149           */

   \                                 In section .textrw, align 2, keep-with-next
    150          __RAMFUNC void flash_init(void)
    151          {
   \                     flash_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    152          #if defined( MK60DZ10)
    153              // 清除Flash预读取缓冲区
    154              FMC_PFB0CR |= FMC_PFB0CR_S_B_INV_MASK;      //
   \   00000002   0x....             LDR.N    R0,??DataTable4_1  ;; 0x4001f004
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   0000000A   0x....             LDR.N    R1,??DataTable4_1  ;; 0x4001f004
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    155              FMC_PFB1CR |= FMC_PFB0CR_S_B_INV_MASK;
   \   0000000E   0x....             LDR.N    R0,??DataTable4_2  ;; 0x4001f008
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000016   0x....             LDR.N    R1,??DataTable4_2  ;; 0x4001f008
   \   00000018   0x6008             STR      R0,[R1, #+0]
    156          
    157              while(!(FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK));    // 等待命令完成
   \                     ??flash_init_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable4  ;; 0x40020000
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x0600             LSLS     R0,R0,#+24
   \   00000020   0xD5FB             BPL.N    ??flash_init_0
    158          
    159              FTFL_FSTAT =    (0
    160                               |  FTFL_FSTAT_CCIF_MASK        // 指令完成标志(写1清0)
    161                               |  FTFL_FSTAT_RDCOLERR_MASK    // 读冲突错误标志(写1清0)
    162                               |  FTFL_FSTAT_ACCERR_MASK      // 访问错误标志位(写1清0)
    163                               |  FTFL_FSTAT_FPVIOL_MASK      // 非法访问保护标志位(写1清0)
    164                              );
   \   00000022   0x20F0             MOVS     R0,#+240
   \   00000024   0x....             LDR.N    R1,??DataTable4  ;; 0x40020000
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    165          
    166          #elif defined(MK60F15)
    167              // 清除Flash预读取缓冲区
    168              FMC_PFB01CR |= FMC_PFB01CR_S_B_INV_MASK;      //
    169              //FMC_PFB23CR |= FMC_PFB23CR_S_B_INV_MASK;
    170          
    171              while(!(FTFE_FSTAT & FTFE_FSTAT_CCIF_MASK));    // 等待命令完成
    172          
    173              FTFE_FSTAT =    (0
    174                               |  FTFE_FSTAT_CCIF_MASK        // 指令完成标志(写1清0)
    175                               |  FTFE_FSTAT_RDCOLERR_MASK    // 读冲突错误标志(写1清0)
    176                               |  FTFE_FSTAT_ACCERR_MASK      // 访问错误标志位(写1清0)
    177                               |  FTFE_FSTAT_FPVIOL_MASK      // 非法访问保护标志位(写1清0)
    178                              );
    179          #endif
    180              DELAY_MS(10);
   \   00000028   0x200A             MOVS     R0,#+10
   \   0000002A   0x.... 0x....      BL       systick_delay_ms
    181          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    182          
    183          /*!
    184           *  @brief      擦除指定flash扇区
    185           *  @param      sector_num    扇区号（K60N512实际使用0~255）
    186           *  @return     执行结果(1成功，0失败)
    187           *  @since      v5.0
    188           *  Sample usage:       flash_erase_sector(127);        //擦除扇区127
    189           */

   \                                 In section .textrw, align 2, keep-with-next
    190          __RAMFUNC uint8 flash_erase_sector(uint16 sector_num)
    191          {
   \                     flash_erase_sector: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    192              uint32 addr = sector_num * FLASH_SECTOR_SIZE;
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0xF44F 0x6000      MOV      R0,#+2048
   \   0000000C   0xFB00 0xF004      MUL      R0,R0,R4
   \   00000010   0x9000             STR      R0,[SP, #+0]
    193          
    194              // 设置擦除命令
    195              FCMD = ERSSCR;
   \   00000012   0x2009             MOVS     R0,#+9
   \   00000014   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40020007
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    196          
    197              // 设置目标地址
    198              FADDR2 = ((Dtype *)&addr)->B[2];
   \   00000018   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000001C   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40020006
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    199              FADDR1 = ((Dtype *)&addr)->B[1];
   \   00000020   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000024   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40020005
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    200              FADDR0 = ((Dtype *)&addr)->B[0];
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40020004
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    201          
    202              if(flash_cmd() == 0)
   \   00000030   0x.... 0x....      BL       flash_cmd
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??flash_erase_sector_0
    203              {
    204                  return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE00C             B.N      ??flash_erase_sector_1
    205              }
    206          
    207              if(sector_num == 0)
   \                     ??flash_erase_sector_0: (+1)
   \   0000003C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD108             BNE.N    ??flash_erase_sector_2
    208              {
    209          #if defined(MK60DZ10)
    210                  return flash_write(sector_num,0x00040C,0xFFFFFFFE);
   \   00000042   0xF07F 0x0201      MVNS     R2,#+1
   \   00000046   0xF240 0x410C      MOVW     R1,#+1036
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   0x.... 0x....      BL       flash_write
   \   00000052   0xE000             B.N      ??flash_erase_sector_1
    211          #elif defined(MK60F15)
    212                  return flash_write(sector_num,0x000408,0xFFFFFFFEFFFFFFFF );
    213          #endif
    214              }
    215          
    216              return 1;
   \                     ??flash_erase_sector_2: (+1)
   \   00000054   0x2001             MOVS     R0,#+1
   \                     ??flash_erase_sector_1: (+1)
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    217          }
    218          
    219          
    220          /*!
    221           *  @brief      写入长字节数据到 flash指定地址
    222           *  @param      sector_num      扇区号（0 ~ FLASH_SECTOR_NUM）
    223           *  @param      offset          写入扇区内部偏移地址（0~2043 中 4的倍数）
    224           *  @param      data            需要写入的数据
    225           *  @return     执行结果(1成功，0失败)
    226           *  @since      v5.0
    227           *  Sample usage:       flash_write(127,0,0xFFFFFFFE);        //扇区127,偏移地址为0,写入数据:0xFFFFFFFE
    228           */

   \                                 In section .textrw, align 2, keep-with-next
    229          __RAMFUNC uint8 flash_write(uint16 sector_num, uint16 offset, FLASH_WRITE_TYPE data)
    230          {
   \                     flash_write: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    231              uint32 addr = sector_num * FLASH_SECTOR_SIZE  + offset ;
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0xF44F 0x6000      MOV      R0,#+2048
   \   0000000E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000010   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000014   0x9001             STR      R0,[SP, #+4]
    232              uint32 tmpdata;
    233          
    234              //ASSERT(offset % FLASH_ALIGN_ADDR == 0);             //偏移量必须为4的倍数
    235              //此处提示警告，但是安全的……
    236              //ASSERT(offset <= FLASH_SECTOR_SIZE);                //扇区大小为2K，即偏移量必须不大于 0x800
    237              //此处提示警告，但是安全的……
    238          
    239              // 设置目标地址
    240              FADDR2 = ((Dtype *)&addr)->B[2];
   \   00000016   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000001A   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40020006
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    241              FADDR1 = ((Dtype *)&addr)->B[1];
   \   0000001E   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000022   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40020005
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    242              FADDR0 = ((Dtype *)&addr)->B[0];
   \   00000026   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002A   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40020004
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    243          
    244              // 设置 低32位数据
    245              tmpdata = (uint32)data;
   \   0000002E   0x9600             STR      R6,[SP, #+0]
    246          
    247              FDATA0 = ((Dtype *)&tmpdata)->B[3];                    // 设置写入数据
   \   00000030   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000034   0x....             LDR.N    R1,??DataTable4_7  ;; 0x4002000b
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    248              FDATA1 = ((Dtype *)&tmpdata)->B[2];
   \   00000038   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000003C   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4002000a
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    249              FDATA2 = ((Dtype *)&tmpdata)->B[1];
   \   00000040   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000044   0x....             LDR.N    R1,??DataTable4_9  ;; 0x40020009
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    250              FDATA3 = ((Dtype *)&tmpdata)->B[0];
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0x....             LDR.N    R1,??DataTable4_10  ;; 0x40020008
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    251          
    252          #if defined(MK60DZ10)
    253          
    254              // 设置擦除命令
    255              FCMD = PGM4;
   \   00000050   0x2006             MOVS     R0,#+6
   \   00000052   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40020007
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    256          
    257          #elif defined(MK60F15)
    258          
    259              // 设置擦除命令
    260              FCMD = PGM8;
    261          
    262              // 设置 高32位数据
    263              tmpdata = (uint32)(data>>32);
    264          
    265              FDATA4 = ((Dtype *)&tmpdata)->B[3];                 // 设置写入数据
    266              FDATA5 = ((Dtype *)&tmpdata)->B[2];
    267              FDATA6 = ((Dtype *)&tmpdata)->B[1];
    268              FDATA7 = ((Dtype *)&tmpdata)->B[0];
    269          #endif
    270          
    271              if(flash_cmd() == 0)
   \   00000056   0x.... 0x....      BL       flash_cmd
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD101             BNE.N    ??flash_write_0
    272              {
    273                  return 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE000             B.N      ??flash_write_1
    274              }
    275          
    276              return 1;  //成功执行
   \                     ??flash_write_0: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \                     ??flash_write_1: (+1)
   \   00000064   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    277          
    278          }
    279          
    280          
    281          /*!
    282           *  @brief      写入数据缓冲区到 flash指定地址
    283           *  @param      sector_num      扇区号（K60N512实际使用0~255）
    284           *  @param      offset          写入扇区内部偏移地址（0~2043 中 4的倍数）
    285           *  @param      buf             需要写入的数据缓冲区首地址
    286           *  @return     执行结果(1成功，0失败)
    287           *  @since      v5.0
    288           *  Sample usage:           uint32 buff[10];
    289                                      flash_write_buf(127,0,sizeof(buff),buff);        //扇区127,偏移地址为0,写入数据源地址:buff,数目sizeof(buff)
    290           */
    291          

   \                                 In section .textrw, align 2, keep-with-next
    292          __RAMFUNC uint8 flash_write_buf(uint16 sector_num, uint16 offset, uint16 cnt, uint8 *buf)
    293          {
   \                     flash_write_buf: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    294              uint32  size;
    295          
    296              uint32  addr;
    297              uint32  data;
    298          
    299              //ASSERT(offset % FLASH_ALIGN_ADDR == 0);                    //偏移量必须为4的倍数
    300              //此处提示警告，但是安全的(ram函数调用rom函数引起警告)
    301              //ASSERT(offset <= FLASH_SECTOR_SIZE );                    //扇区大小为2K，即偏移量必须不大于 0x800
    302              //此处提示警告，但是安全的(ram函数调用rom函数引起警告)
    303          
    304              addr = sector_num * FLASH_SECTOR_SIZE  + offset;      //计算地址
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000012   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000014   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000018   0x9000             STR      R0,[SP, #+0]
    305          
    306              // 设置写入命令
    307          #if defined(MK60DZ10)
    308              FCMD = PGM4;
   \   0000001A   0x2006             MOVS     R0,#+6
   \   0000001C   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40020007
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    309          #elif defined(MK60F15)
    310              FCMD = PGM8;
    311          #endif
    312          
    313              for(size = 0; size < cnt; size += FLASH_ALIGN_ADDR )
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4680             MOV      R8,R0
   \                     ??flash_write_buf_0: (+1)
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x45B0             CMP      R8,R6
   \   00000028   0xD22A             BCS.N    ??flash_write_buf_1
    314              {
    315          
    316                  // 设置目标地址
    317                  FADDR2 = ((Dtype *)&addr)->B[2];
   \   0000002A   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000002E   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40020006
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    318                  FADDR1 = ((Dtype *)&addr)->B[1];
   \   00000032   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000036   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40020005
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    319                  FADDR0 = ((Dtype *)&addr)->B[0];
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40020004
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    320          
    321                  // 设置 低32位数据
    322                  data =  *(uint32 *)buf;
   \   00000042   0x6838             LDR      R0,[R7, #+0]
   \   00000044   0x9001             STR      R0,[SP, #+4]
    323          
    324                  FDATA0 = ((Dtype *)&data)->B[3];                    // 设置写入数据
   \   00000046   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   0000004A   0x....             LDR.N    R1,??DataTable4_7  ;; 0x4002000b
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
    325                  FDATA1 = ((Dtype *)&data)->B[2];
   \   0000004E   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000052   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4002000a
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    326                  FDATA2 = ((Dtype *)&data)->B[1];
   \   00000056   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000005A   0x....             LDR.N    R1,??DataTable4_9  ;; 0x40020009
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
    327                  FDATA3 = ((Dtype *)&data)->B[0];
   \   0000005E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000062   0x....             LDR.N    R1,??DataTable4_10  ;; 0x40020008
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    328          
    329          #if defined(MK60F15)
    330                  // 设置 高32位数据
    331                  data = *(uint32 *)(buf+4);
    332          
    333                  FDATA4 = ((Dtype *)&data)->B[3];                    // 设置写入数据
    334                  FDATA5 = ((Dtype *)&data)->B[2];
    335                  FDATA6 = ((Dtype *)&data)->B[1];
    336                  FDATA7 = ((Dtype *)&data)->B[0];
    337          #endif
    338          
    339                  if(flash_cmd() == 0)
   \   00000066   0x.... 0x....      BL       flash_cmd
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD101             BNE.N    ??flash_write_buf_2
    340                  {
    341                      return 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE007             B.N      ??flash_write_buf_3
    342                  }
    343          
    344                  addr += FLASH_ALIGN_ADDR;
   \                     ??flash_write_buf_2: (+1)
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x1D00             ADDS     R0,R0,#+4
   \   00000076   0x9000             STR      R0,[SP, #+0]
    345                  buf += FLASH_ALIGN_ADDR;
   \   00000078   0x1D3F             ADDS     R7,R7,#+4
    346              }
   \   0000007A   0xF118 0x0804      ADDS     R8,R8,#+4
   \   0000007E   0xE7D1             B.N      ??flash_write_buf_0
    347              return 1;  //成功执行
   \                     ??flash_write_buf_1: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??flash_write_buf_3: (+1)
   \   00000082   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    348          }

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x4001F004         DC32     0x4001f004

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x4001F008         DC32     0x4001f008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40020007         DC32     0x40020007

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40020006         DC32     0x40020006

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40020005         DC32     0x40020005

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x4002000B         DC32     0x4002000b

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x4002000A         DC32     0x4002000a

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40020009         DC32     0x40020009

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x40020008         DC32     0x40020008
    349          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   flash_cmd
      16   flash_erase_sector
        16   -> flash_cmd
        16   -> flash_write
       8   flash_init
         8   -> systick_delay_ms
      24   flash_write
        24   -> flash_cmd
      32   flash_write_buf
        32   -> flash_cmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      32  flash_cmd
      88  flash_erase_sector
      48  flash_init
     102  flash_write
     134  flash_write_buf

 
 448 bytes in section .textrw
 
 448 bytes of CODE memory

Errors: none
Warnings: 1
