###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Jul/2016  12:04:21
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_ftm.c
#    Command line =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_ftm.c -D DEBUG
#        -D ARM_MATH_CM4 -D MK60DZ10 -lCN
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -lB
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\ -o
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "E:\IAR for
#        ARM\arm\INC\c\DLib_Config_Full.h" -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\App\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\IAR\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Chip\inc\kinetis\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\CMSIS\Inc\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\FatFs\
#        -I D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Lib\USB\ -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\MPU6050\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\IMU\
#        -I
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\..\..\Board\Accessories\Driver\
#        -On
#    List file    =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\List\MK60_ftm.lst
#    Object file  =  
#        D:\Study\2016电子设计大赛\Ti\电赛备用底层\Prj\IAR\DZ10_Debug\Obj\MK60_ftm.o
#
###############################################################################

D:\Study\2016电子设计大赛\Ti\电赛备用底层\Chip\src\MK60_ftm.c
      1          /*!
      2           *     COPYRIGHT NOTICE
      3           *     Copyright (c) 2013,山外科技
      4           *     All rights reserved.
      5           *     技术讨论：山外论坛 http://www.vcan123.com
      6           *
      7           *     除注明出处外，以下所有内容版权均属山外科技所有，未经允许，不得用于商业用途，
      8           *     修改内容时必须保留山外科技的版权声明。
      9           *
     10           * @file       MK60_ftm.c
     11           * @brief      FTM定时器函数库
     12           * @author     山外科技
     13           * @version    v5.2
     14           * @date       2014-10-31
     15           */
     16          
     17          
     18          /*
     19           * 包含头文件
     20           */
     21          #include "common.h"
     22          #include  "MK60_FTM.h"
     23          
     24          /*
     25           * 定义数组
     26           */

   \                                 In section .data, align 4
     27          FTM_MemMapPtr FTMN[FTM_MAX] = {FTM0_BASE_PTR, FTM1_BASE_PTR, FTM2_BASE_PTR
   \                     FTMN:
   \   00000000   0x40038000         DC32 40038000H, 40039000H, 400B8000H
   \              0x40039000   
   \              0x400B8000   
     28          #ifdef MK60F15
     29          , FTM3_BASE_PTR         //FX 才有FTM3
     30          #endif
     31          }; //定义三个指针数组保存 FTMn_e 的地址
     32          

   \                                 In section .bss, align 4
     33          static uint32 ftm_mod[FTM_MAX];
   \                     ftm_mod:
   \   00000000                      DS8 12
     34          
     35          /*!
     36           *  @brief      初始化FTM 的端口
     37           *  @param      FTMn_e    模块号（FTM0、  FTM1、  FTM2）
     38           *  @param      FTM_CHn_e     通道号（CH0~CH7）
     39           *  @since      v5.0
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          static void FTM_port_mux(FTMn_e ftmn, FTM_CHn_e ch)
     42          {
   \                     FTM_port_mux: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     43              /******************* 开启时钟 和 复用IO口*******************/
     44              switch(ftmn)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD003             BEQ.N    ??FTM_port_mux_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD066             BEQ.N    ??FTM_port_mux_1
   \   00000010   0xD349             BCC.N    ??FTM_port_mux_2
   \   00000012   0xE080             B.N      ??FTM_port_mux_3
     45              {
     46              case FTM0:
     47                  SIM_SCGC6 |= SIM_SCGC6_FTM0_MASK;       //使能FTM0时钟
   \                     ??FTM_port_mux_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x4004803c
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x4004803c
   \   00000022   0x6008             STR      R0,[R1, #+0]
     48                  switch(ch)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD00B             BEQ.N    ??FTM_port_mux_4
   \   0000002A   0x2D02             CMP      R5,#+2
   \   0000002C   0xD015             BEQ.N    ??FTM_port_mux_5
   \   0000002E   0xD30E             BCC.N    ??FTM_port_mux_6
   \   00000030   0x2D04             CMP      R5,#+4
   \   00000032   0xD01E             BEQ.N    ??FTM_port_mux_7
   \   00000034   0xD317             BCC.N    ??FTM_port_mux_8
   \   00000036   0x2D06             CMP      R5,#+6
   \   00000038   0xD027             BEQ.N    ??FTM_port_mux_9
   \   0000003A   0xD320             BCC.N    ??FTM_port_mux_10
   \   0000003C   0x2D07             CMP      R5,#+7
   \   0000003E   0xD02A             BEQ.N    ??FTM_port_mux_11
   \   00000040   0xE02F             B.N      ??FTM_port_mux_12
     49                  {
     50                  case FTM_CH0:
     51                      if(FTM0_CH0_PIN == PTC1)
     52                      {
     53                          port_init(FTM0_CH0_PIN, ALT4);
   \                     ??FTM_port_mux_4: (+1)
   \   00000042   0xF44F 0x6180      MOV      R1,#+1024
   \   00000046   0x2041             MOVS     R0,#+65
   \   00000048   0x.... 0x....      BL       port_init
     54                      }
     55                      else if(FTM0_CH0_PIN == PTA3)
     56                      {
     57                          port_init(FTM0_CH0_PIN, ALT3);
     58                      }
     59                      else
     60                      {
     61                          ASSERT(0);                      //设置管脚有误？
     62                      }
     63                      break;
   \   0000004C   0xE02A             B.N      ??FTM_port_mux_13
     64          
     65                  case FTM_CH1:
     66                      if(FTM0_CH1_PIN == PTC2)
     67                      {
     68                          port_init(FTM0_CH1_PIN, ALT4);
     69                      }
     70                      else if(FTM0_CH1_PIN == PTA4)
     71                      {
     72                          port_init(FTM0_CH1_PIN, ALT3);
   \                     ??FTM_port_mux_6: (+1)
   \   0000004E   0xF44F 0x7140      MOV      R1,#+768
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0x.... 0x....      BL       port_init
     73                      }
     74                      else
     75                      {
     76                          ASSERT(0);                      //设置管脚有误？
     77                      }
     78                      break;
   \   00000058   0xE024             B.N      ??FTM_port_mux_13
     79          
     80                  case FTM_CH2:
     81                      if(FTM0_CH2_PIN == PTC3)
     82                      {
     83                          port_init(FTM0_CH2_PIN, ALT4);
     84                      }
     85                      else if(FTM0_CH2_PIN == PTA5)
     86                      {
     87                          port_init(FTM0_CH2_PIN, ALT3);
   \                     ??FTM_port_mux_5: (+1)
   \   0000005A   0xF44F 0x7140      MOV      R1,#+768
   \   0000005E   0x2005             MOVS     R0,#+5
   \   00000060   0x.... 0x....      BL       port_init
     88                      }
     89                      else
     90                      {
     91                          ASSERT(0);                      //设置管脚有误？
     92                      }
     93                      break;
   \   00000064   0xE01E             B.N      ??FTM_port_mux_13
     94          
     95                  case FTM_CH3:
     96                      if(FTM0_CH3_PIN == PTC4)
     97                      {
     98                          port_init(FTM0_CH3_PIN, ALT4);
     99                      }
    100                      else if(FTM0_CH3_PIN == PTA6)
    101                      {
    102                          port_init(FTM0_CH3_PIN, ALT3);
   \                     ??FTM_port_mux_8: (+1)
   \   00000066   0xF44F 0x7140      MOV      R1,#+768
   \   0000006A   0x2006             MOVS     R0,#+6
   \   0000006C   0x.... 0x....      BL       port_init
    103                      }
    104                      else
    105                      {
    106                          ASSERT(0);                      //设置管脚有误？
    107                      }
    108                      break;
   \   00000070   0xE018             B.N      ??FTM_port_mux_13
    109          
    110                  case FTM_CH4:
    111                      if(FTM0_CH4_PIN == PTD4)
    112                      {
    113                          port_init(FTM0_CH4_PIN, ALT4);
   \                     ??FTM_port_mux_7: (+1)
   \   00000072   0xF44F 0x6180      MOV      R1,#+1024
   \   00000076   0x2064             MOVS     R0,#+100
   \   00000078   0x.... 0x....      BL       port_init
    114                      }
    115                      else if(FTM0_CH4_PIN == PTA7)
    116                      {
    117                          port_init(FTM0_CH4_PIN, ALT3);
    118                      }
    119                      else
    120                      {
    121                          ASSERT(0);                      //设置管脚有误？
    122                      }
    123                      break;
   \   0000007C   0xE012             B.N      ??FTM_port_mux_13
    124          
    125                  case FTM_CH5:
    126                      if(FTM0_CH5_PIN == PTD5)
    127                      {
    128                          port_init(FTM0_CH5_PIN, ALT4);
   \                     ??FTM_port_mux_10: (+1)
   \   0000007E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000082   0x2065             MOVS     R0,#+101
   \   00000084   0x.... 0x....      BL       port_init
    129                      }
    130                      else if(FTM0_CH5_PIN == PTA0)
    131                      {
    132                          port_init(FTM0_CH5_PIN, ALT3);
    133                      }
    134                      else
    135                      {
    136                          ASSERT(0);                      //设置管脚有误？
    137                      }
    138                      break;
   \   00000088   0xE00C             B.N      ??FTM_port_mux_13
    139          
    140                  case FTM_CH6:
    141                      if(FTM0_CH6_PIN == PTD6)
    142                      {
    143                          port_init(FTM0_CH6_PIN, ALT4);
   \                     ??FTM_port_mux_9: (+1)
   \   0000008A   0xF44F 0x6180      MOV      R1,#+1024
   \   0000008E   0x2066             MOVS     R0,#+102
   \   00000090   0x.... 0x....      BL       port_init
    144                      }
    145                      else if(FTM0_CH6_PIN == PTA1)
    146                      {
    147                          port_init(FTM0_CH6_PIN, ALT3);
    148                      }
    149                      else
    150                      {
    151                          ASSERT(0);                      //设置管脚有误？
    152                      }
    153                      break;
   \   00000094   0xE006             B.N      ??FTM_port_mux_13
    154          
    155                  case FTM_CH7:
    156                      if(FTM0_CH7_PIN == PTD7)
    157                      {
    158                          port_init(FTM0_CH7_PIN, ALT4);
   \                     ??FTM_port_mux_11: (+1)
   \   00000096   0xF44F 0x6180      MOV      R1,#+1024
   \   0000009A   0x2067             MOVS     R0,#+103
   \   0000009C   0x.... 0x....      BL       port_init
    159                      }
    160                      else if(FTM0_CH7_PIN == PTA2)
    161                      {
    162                          port_init(FTM0_CH7_PIN, ALT3);
    163                      }
    164                      else
    165                      {
    166                          ASSERT(0);                      //设置管脚有误？
    167                      }
    168                      break;
   \   000000A0   0xE000             B.N      ??FTM_port_mux_13
    169                  default:
    170                      return;
   \                     ??FTM_port_mux_12: (+1)
   \   000000A2   0xE038             B.N      ??FTM_port_mux_14
    171                  }
    172                  break;
   \                     ??FTM_port_mux_13: (+1)
   \   000000A4   0xE037             B.N      ??FTM_port_mux_15
    173          
    174              case FTM1:
    175                  SIM_SCGC6 |= SIM_SCGC6_FTM1_MASK;       //使能FTM1时钟
   \                     ??FTM_port_mux_2: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x4004803c
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x4004803c
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    176                  switch(ch)
   \   000000B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B8   0x2D00             CMP      R5,#+0
   \   000000BA   0xD002             BEQ.N    ??FTM_port_mux_16
   \   000000BC   0x2D01             CMP      R5,#+1
   \   000000BE   0xD006             BEQ.N    ??FTM_port_mux_17
   \   000000C0   0xE00B             B.N      ??FTM_port_mux_18
    177                  {
    178                  case FTM_CH0:
    179                      if((FTM1_CH0_PIN == PTA8) || (FTM1_CH0_PIN == PTA12) || (FTM1_CH0_PIN == PTB0) )
    180                      {
    181                          port_init(FTM1_CH0_PIN, ALT3);
   \                     ??FTM_port_mux_16: (+1)
   \   000000C2   0xF44F 0x7140      MOV      R1,#+768
   \   000000C6   0x2020             MOVS     R0,#+32
   \   000000C8   0x.... 0x....      BL       port_init
    182                      }
    183                      else
    184                      {
    185                          ASSERT(0);                      //设置管脚有误？
    186                      }
    187                      break;
   \   000000CC   0xE006             B.N      ??FTM_port_mux_19
    188          
    189          
    190                  case FTM_CH1:
    191                      if((FTM1_CH1_PIN == PTA9) || (FTM1_CH1_PIN == PTA13) || (FTM1_CH1_PIN == PTB1) )
    192                      {
    193                          port_init(FTM1_CH1_PIN, ALT3);
   \                     ??FTM_port_mux_17: (+1)
   \   000000CE   0xF44F 0x7140      MOV      R1,#+768
   \   000000D2   0x200D             MOVS     R0,#+13
   \   000000D4   0x.... 0x....      BL       port_init
    194                      }
    195                      else
    196                      {
    197                          ASSERT(0);                      //设置管脚有误？
    198                      }
    199                      break;
   \   000000D8   0xE000             B.N      ??FTM_port_mux_19
    200          
    201                  default:
    202                      return;
   \                     ??FTM_port_mux_18: (+1)
   \   000000DA   0xE01C             B.N      ??FTM_port_mux_14
    203                  }
    204                  break;
   \                     ??FTM_port_mux_19: (+1)
   \   000000DC   0xE01B             B.N      ??FTM_port_mux_15
    205          
    206              case FTM2:
    207                  SIM_SCGC3 |= SIM_SCGC3_FTM2_MASK;                           //使能FTM2时钟
   \                     ??FTM_port_mux_1: (+1)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable10_1  ;; 0x40048030
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x40048030
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    208                  switch(ch)
   \   000000EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F0   0x2D00             CMP      R5,#+0
   \   000000F2   0xD002             BEQ.N    ??FTM_port_mux_20
   \   000000F4   0x2D01             CMP      R5,#+1
   \   000000F6   0xD006             BEQ.N    ??FTM_port_mux_21
   \   000000F8   0xE00B             B.N      ??FTM_port_mux_22
    209                  {
    210                  case FTM_CH0:
    211                      if((FTM2_CH0_PIN == PTA10) || (FTM2_CH0_PIN == PTB18) )
    212                      {
    213                          port_init(FTM2_CH0_PIN, ALT3);
   \                     ??FTM_port_mux_20: (+1)
   \   000000FA   0xF44F 0x7140      MOV      R1,#+768
   \   000000FE   0x200A             MOVS     R0,#+10
   \   00000100   0x.... 0x....      BL       port_init
    214                      }
    215                      else
    216                      {
    217                          ASSERT(0);                      //设置管脚有误？
    218                      }
    219                      break;
   \   00000104   0xE006             B.N      ??FTM_port_mux_23
    220          
    221                  case FTM_CH1:
    222                      if((FTM2_CH1_PIN == PTA11) || (FTM2_CH1_PIN == PTB19))
    223                      {
    224                          port_init(FTM2_CH1_PIN, ALT3);
   \                     ??FTM_port_mux_21: (+1)
   \   00000106   0xF44F 0x7140      MOV      R1,#+768
   \   0000010A   0x200B             MOVS     R0,#+11
   \   0000010C   0x.... 0x....      BL       port_init
    225                      }
    226                      else
    227                      {
    228                          ASSERT(0);                      //设置管脚有误？
    229                      }
    230                      break;
   \   00000110   0xE000             B.N      ??FTM_port_mux_23
    231          
    232                  default:
    233                      return;
   \                     ??FTM_port_mux_22: (+1)
   \   00000112   0xE000             B.N      ??FTM_port_mux_14
    234                  }
    235                  break;
   \                     ??FTM_port_mux_23: (+1)
   \   00000114   0xE7FF             B.N      ??FTM_port_mux_15
    236          #ifdef MK60F15
    237              case FTM3:
    238                  SIM_SCGC3 |= SIM_SCGC3_FTM3_MASK;       //使能FTM3时钟
    239                  switch(ch)
    240                  {
    241                  case FTM_CH0:
    242                      if(FTM3_CH0_PIN == PTD0)
    243                      {
    244                          port_init(FTM3_CH0_PIN, ALT4);
    245                      }
    246                      else if(FTM3_CH0_PIN == PTE5)
    247                      {
    248                          port_init(FTM3_CH0_PIN, ALT6);
    249                      }
    250                      else
    251                      {
    252                          ASSERT(0);                      //设置管脚有误？
    253                      }
    254                      break;
    255          
    256                  case FTM_CH1:
    257                      if(FTM3_CH1_PIN == PTD1)
    258                      {
    259                          port_init(FTM3_CH1_PIN, ALT4);
    260                      }
    261                      else if(FTM3_CH1_PIN == PTE6)
    262                      {
    263                          port_init(FTM3_CH1_PIN, ALT6);
    264                      }
    265                      else
    266                      {
    267                          ASSERT(0);                      //设置管脚有误？
    268                      }
    269                      break;
    270          
    271                  case FTM_CH2:
    272                      if(FTM3_CH2_PIN == PTD2)
    273                      {
    274                          port_init(FTM3_CH2_PIN, ALT4);
    275                      }
    276                      else if(FTM3_CH2_PIN == PTE7)
    277                      {
    278                          port_init(FTM3_CH2_PIN, ALT6);
    279                      }
    280                      else
    281                      {
    282                          ASSERT(0);                      //设置管脚有误？
    283                      }
    284                      break;
    285          
    286                  case FTM_CH3:
    287                      if(FTM3_CH3_PIN == PTD3)
    288                      {
    289                          port_init(FTM3_CH3_PIN, ALT4);
    290                      }
    291                      else if(FTM3_CH3_PIN == PTE8)
    292                      {
    293                          port_init(FTM3_CH3_PIN, ALT6);
    294                      }
    295                      else
    296                      {
    297                          ASSERT(0);                      //设置管脚有误？
    298                      }
    299                      break;
    300          
    301                  case FTM_CH4:
    302                      if(FTM3_CH4_PIN == PTC8)
    303                      {
    304                          port_init(FTM3_CH4_PIN, ALT3);
    305                      }
    306                      else if(FTM3_CH4_PIN == PTE9)
    307                      {
    308                          port_init(FTM3_CH4_PIN, ALT6);
    309                      }
    310                      else
    311                      {
    312                          ASSERT(0);                      //设置管脚有误？
    313                      }
    314                      break;
    315          
    316                  case FTM_CH5:
    317                      if(FTM3_CH5_PIN == PTC9)
    318                      {
    319                          port_init(FTM3_CH5_PIN, ALT3);
    320                      }
    321                      else if(FTM3_CH5_PIN == PTE10)
    322                      {
    323                          port_init(FTM3_CH5_PIN, ALT6);
    324                      }
    325                      else
    326                      {
    327                          ASSERT(0);                      //设置管脚有误？
    328                      }
    329                      break;
    330          
    331                  case FTM_CH6:
    332                      if(FTM3_CH6_PIN == PTC10)
    333                      {
    334                          port_init(FTM3_CH6_PIN, ALT3);
    335                      }
    336                      else if(FTM3_CH6_PIN == PTE11)
    337                      {
    338                          port_init(FTM3_CH6_PIN, ALT6);
    339                      }
    340                      else
    341                      {
    342                          ASSERT(0);                      //设置管脚有误？
    343                      }
    344                      break;
    345          
    346                  case FTM_CH7:
    347                      if(FTM3_CH7_PIN == PTC11)
    348                      {
    349                          port_init(FTM3_CH7_PIN, ALT3);
    350                      }
    351                      else if(FTM3_CH7_PIN == PTE12)
    352                      {
    353                          port_init(FTM3_CH7_PIN, ALT6);
    354                      }
    355                      else
    356                      {
    357                          ASSERT(0);                      //设置管脚有误？
    358                      }
    359                  }
    360                  break;
    361          
    362          #endif
    363              default:
    364                  break;
    365              }
    366          }
   \                     ??FTM_port_mux_3: (+1)
   \                     ??FTM_port_mux_15: (+1)
   \                     ??FTM_port_mux_14: (+1)
   \   00000116   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    367          
    368          /*!
    369           *  @brief      初始化FTM 的PWM 功能
    370           *  @param      FTMn_e    模块号（FTM0、  FTM1、  FTM2）
    371           *  @param      FTM_CHn_e     通道号（CH0~CH7）
    372           *  @param      freq    频率（单位为Hz）
    373           *  @param      duty    占空比分子，占空比 = duty / FTMn_PRECISON
    374           *  @since      v5.0
    375           *  @note       同一个FTM，PWM频率是必须一样的，但占空比可不一样。共3个FTM，即可以输出3个不同频率PWM
    376           *  Sample usage:       ftm_pwm_init(FTM0, FTM_CH6,200, 10);    //初始化 FTM0_CH6 为 频率 200Hz 的PWM，占空比为 10/FTM0_PRECISON
    377           */

   \                                 In section .bss, align 4
    378          int mod1;
   \                     mod1:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    379          void ftm_pwm_init(FTMn_e ftmn, FTM_CHn_e ch, uint32 freq, uint32 duty)
    380          {
   \                     ftm_pwm_init: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    381              uint32 clk_hz ;
    382              uint16 mod;
    383              uint8  ps;
    384              uint16 cv;
    385          
    386              ASSERT( (ftmn == FTM0) || ( (ftmn == FTM1 || ftmn == FTM2 ) && (ch <= FTM_CH1))
    387          #ifdef MK60F15
    388                      || (ftmn == FTM3)       //FX  有FTM3
    389          #endif
    390                     );  //检查传递进来的通道是否正确
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD00E             BEQ.N    ??ftm_pwm_init_0
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD002             BEQ.N    ??ftm_pwm_init_1
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C02             CMP      R4,#+2
   \   0000001C   0xD102             BNE.N    ??ftm_pwm_init_2
   \                     ??ftm_pwm_init_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xDB05             BLT.N    ??ftm_pwm_init_0
   \                     ??ftm_pwm_init_2: (+1)
   \   00000024   0xF44F 0x71C3      MOV      R1,#+390
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000002C   0x.... 0x....      BL       assert_failed
    391          
    392              /******************* 开启时钟 和 复用IO口*******************/
    393              FTM_port_mux(ftmn,ch);
   \                     ??ftm_pwm_init_0: (+1)
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       FTM_port_mux
    394          
    395              /*       计算频率设置        */
    396              //  若 CPWMS = 1 ，即双边捕捉脉冲，则 PMW频率 =  bus频率 /2 /(2^预分频因子)/模数
    397              //  若 CPWMS = 0 ，即单边捕捉脉冲，则 PMW频率 =  bus频率    /(2^预分频因子)/模数
    398              //  EPWM的周期 ：MOD - CNTIN + 0x0001   (CNTIN 设为0)
    399              //  脉冲宽度：CnV - CNTIN
    400          
    401              //  模数 MOD < 0x10000
    402              //  预分频因子 PS  < 0x07
    403              //  预分频因子 PS 越小时，模数 mod 就越大，计数就越精准，PWM输出更为准确
    404              //  MOD  = clk_hz/(freq*(1 << PS)) < 0x10000  ==>  clk_hz/(freq*0x10000) < (1<< PS)  ==>  (clk_hz/(freq*0x10000) >> PS) < 1
    405              //  即 (((clk_hz/0x10000 )/ freq ) >> PS ) < 1
    406          
    407              // 以 CPWMS = 0 ，即单边捕捉脉冲为例
    408              clk_hz = (bus_clk_khz * 1000) ;     // bus频率
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF44F 0x717A      MOV      R1,#+1000
   \   00000046   0x4348             MULS     R0,R1,R0
   \   00000048   0x4680             MOV      R8,R0
    409          
    410              mod = (clk_hz >> 16 ) / freq ;      // 临时用 mod 缓存一下
   \   0000004A   0xEA5F 0x4018      LSRS     R0,R8,#+16
   \   0000004E   0xFBB0 0xF0F6      UDIV     R0,R0,R6
   \   00000052   0x4681             MOV      R9,R0
    411              ps = 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x4682             MOV      R10,R0
    412              while((mod >> ps) >= 1)             // 等 (mod >> ps) < 1 才退出 while 循环 ，即求 PS 的最小值
   \                     ??ftm_pwm_init_3: (+1)
   \   00000058   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000005C   0x4648             MOV      R0,R9
   \   0000005E   0xFA50 0xF00A      ASRS     R0,R0,R10
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xDB02             BLT.N    ??ftm_pwm_init_4
    413              {
    414                  ps++;
   \   00000066   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   0000006A   0xE7F5             B.N      ??ftm_pwm_init_3
    415              }
    416          
    417              ASSERT(ps <= 0x07);                 // 断言， PS 最大为 0x07 ，超过此值，则 PWM频率设置过低，或 Bus 频率过高
   \                     ??ftm_pwm_init_4: (+1)
   \   0000006C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000070   0xF1BA 0x0F08      CMP      R10,#+8
   \   00000074   0xDB05             BLT.N    ??ftm_pwm_init_5
   \   00000076   0xF240 0x11A1      MOVW     R1,#+417
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000007E   0x.... 0x....      BL       assert_failed
    418          
    419              mod = (clk_hz >> ps) / freq;        // 求 MOD 的值
   \                     ??ftm_pwm_init_5: (+1)
   \   00000082   0x4640             MOV      R0,R8
   \   00000084   0xFA30 0xF00A      LSRS     R0,R0,R10
   \   00000088   0xFBB0 0xF0F6      UDIV     R0,R0,R6
   \   0000008C   0x4681             MOV      R9,R0
    420          
    421              ftm_mod[ftmn]=mod;
   \   0000008E   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0xF840 0x9024      STR      R9,[R0, R4, LSL #+2]
    422          
    423              switch(ftmn)                        // 初值 CNTIN 设为0 ，脉冲宽度：CnV - CNTIN ，即 CnV 就是 脉冲宽度了。
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x2C00             CMP      R4,#+0
   \   000000A0   0xD003             BEQ.N    ??ftm_pwm_init_6
   \   000000A2   0x2C02             CMP      R4,#+2
   \   000000A4   0xD019             BEQ.N    ??ftm_pwm_init_7
   \   000000A6   0xD30C             BCC.N    ??ftm_pwm_init_8
   \   000000A8   0xE023             B.N      ??ftm_pwm_init_9
    424              {
    425                  // EPWM的周期 ： MOD - CNTIN + 0x0001 == MOD - 0 + 1
    426                  // 则 CnV = (MOD - 0 + 1) * 占空比 = (MOD - 0 + 1) * duty/ FTM_PRECISON
    427              case FTM0:
    428                  cv = (duty * (mod - 0 + 1)) / FTM0_PRECISON;
   \                     ??ftm_pwm_init_6: (+1)
   \   000000AA   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000AE   0xF119 0x0001      ADDS     R0,R9,#+1
   \   000000B2   0xFB00 0xF007      MUL      R0,R0,R7
   \   000000B6   0xF242 0x7110      MOVW     R1,#+10000
   \   000000BA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000BE   0x4683             MOV      R11,R0
    429                  break;
   \   000000C0   0xE017             B.N      ??ftm_pwm_init_10
    430          
    431              case FTM1:
    432                  cv = (duty * (mod - 0 + 1)) / FTM1_PRECISON;
   \                     ??ftm_pwm_init_8: (+1)
   \   000000C2   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000C6   0xF119 0x0001      ADDS     R0,R9,#+1
   \   000000CA   0xFB00 0xF007      MUL      R0,R0,R7
   \   000000CE   0xF242 0x7110      MOVW     R1,#+10000
   \   000000D2   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000D6   0x4683             MOV      R11,R0
    433                  break;
   \   000000D8   0xE00B             B.N      ??ftm_pwm_init_10
    434          
    435              case FTM2:
    436                  cv = (duty * (mod - 0 + 1)) / FTM2_PRECISON;
   \                     ??ftm_pwm_init_7: (+1)
   \   000000DA   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000DE   0xF119 0x0001      ADDS     R0,R9,#+1
   \   000000E2   0xFB00 0xF007      MUL      R0,R0,R7
   \   000000E6   0xF242 0x7110      MOVW     R1,#+10000
   \   000000EA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000EE   0x4683             MOV      R11,R0
    437                  break;
   \   000000F0   0xE7FF             B.N      ??ftm_pwm_init_10
    438          #ifdef MK60F15
    439              case FTM3:
    440                  cv = (duty * (mod - 0 + 1)) / FTM3_PRECISON;
    441                  break;
    442          #endif
    443          
    444              default:
    445                  break;
    446              }
    447          
    448              /******************** 选择输出模式为 边沿对齐PWM *******************/
    449              //通道状态控制，根据模式来选择 边沿或电平
    450              FTM_CnSC_REG(FTMN[ftmn], ch) &= ~FTM_CnSC_ELSA_MASK;
   \                     ??ftm_pwm_init_9: (+1)
   \                     ??ftm_pwm_init_10: (+1)
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000106   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000108   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000010C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010E   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000112   0x68C9             LDR      R1,[R1, #+12]
   \   00000114   0xF031 0x0104      BICS     R1,R1,#0x4
   \   00000118   0x60C1             STR      R1,[R0, #+12]
    451              FTM_CnSC_REG(FTMN[ftmn], ch)  = FTM_CnSC_MSB_MASK | FTM_CnSC_ELSB_MASK;
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000011E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000120   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000124   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000126   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   0000012A   0x2128             MOVS     R1,#+40
   \   0000012C   0x60C1             STR      R1,[R0, #+12]
    452              // MSnB:MSnA = 1x       边沿对齐PWM
    453              // ELSnB:ELSnA = 10     先高后低
    454              // ELSnB:ELSnA = 11     先低后高
    455          
    456              /******************** 配置时钟和分频 ********************/
    457              FTM_SC_REG(FTMN[ftmn])    = ( 0
    458                                            //| FTM_SC_CPWMS_MASK         //0：上升沿计数模式 ，1： 跳变沿计数模式选择 （注释了表示 0）
    459                                            | FTM_SC_PS(ps)             //分频因子，分频系数 = 2^PS
    460                                            | FTM_SC_CLKS(1)            //时钟选择， 0：没选择时钟，禁用； 1：bus 时钟； 2：MCGFFCLK； 3：EXTCLK（ 由SIM_SOPT4 选择输入管脚 FTM_CLKINx）
    461                                            //| FTM_SC_TOIE_MASK        //溢出中断使能（注释了表示 禁止溢出中断）
    462                                          );
   \   0000012E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000132   0xF01A 0x0007      ANDS     R0,R10,#0x7
   \   00000136   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   0000013E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000140   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000144   0x6008             STR      R0,[R1, #+0]
    463              FTM_MOD_REG(FTMN[ftmn])   = mod;                        //模数, EPWM的周期为 ：MOD - CNTIN + 0x0001
   \   00000146   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000014E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000150   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000154   0xF8C0 0x9008      STR      R9,[R0, #+8]
    464              mod1 = mod;
   \   00000158   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   00000160   0xF8C0 0x9000      STR      R9,[R0, #+0]
    465              FTM_CNTIN_REG(FTMN[ftmn]) = 0;                          //计数器初始化值。设置脉冲宽度：(CnV - CNTIN).
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   0000016A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016C   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000170   0x64C8             STR      R0,[R1, #+76]
    466              FTM_CnV_REG(FTMN[ftmn], ch) = cv;
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000176   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000178   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000017C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000017E   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000182   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   00000186   0xF8C0 0xB010      STR      R11,[R0, #+16]
    467              FTM_CNT_REG(FTMN[ftmn])   = 0;                          //计数器。只有低16位可用（写任何值到此寄存器，都会加载 CNTIN 的值）
   \   0000018A   0x2000             MOVS     R0,#+0
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000190   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000192   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000196   0x6048             STR      R0,[R1, #+4]
    468          }
   \   00000198   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    469          
    470          /*!
    471           *  @brief      设置FTM 的PWM 通道占空比
    472           *  @param      FTMn_e    模块号（FTM0、  FTM1、  FTM2）
    473           *  @param      FTM_CHn_e     通道号（CH0~CH7）
    474           *  @param      duty    占空比分子，占空比 = duty / FTMn_PRECISON
    475           *  @since      v5.0
    476           *  @note       同一个FTM，PWM频率是必须一样的，但占空比可不一样。共3个FTM，即可以输出3个不同频率PWM
    477           *  Sample usage:       ftm_pwm_duty(FTM0, FTM_CH6, 10);    //设置 FTM0_CH6占空比为 10/FTM0_PRECISON
    478           */

   \                                 In section .text, align 2, keep-with-next
    479          void ftm_pwm_duty(FTMn_e ftmn, FTM_CHn_e ch, uint32 duty)
    480          {
   \                     ftm_pwm_duty: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    481              uint32 cv;
    482              uint32 mod = 0;
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    483          
    484              ASSERT( (ftmn == FTM0) || ( (ftmn == FTM1 || ftmn == FTM2 ) && (ch <= FTM_CH1))
    485          #ifdef MK60F15
    486                      || (ftmn == FTM3)       //FX  有FTM3
    487          #endif
    488                     );  //检查传递进来的通道是否正确
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD00E             BEQ.N    ??ftm_pwm_duty_0
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xD002             BEQ.N    ??ftm_pwm_duty_1
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C02             CMP      R4,#+2
   \   0000001E   0xD102             BNE.N    ??ftm_pwm_duty_2
   \                     ??ftm_pwm_duty_1: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D02             CMP      R5,#+2
   \   00000024   0xDB05             BLT.N    ??ftm_pwm_duty_0
   \                     ??ftm_pwm_duty_2: (+1)
   \   00000026   0xF44F 0x71F4      MOV      R1,#+488
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000002E   0x.... 0x....      BL       assert_failed
    489          
    490              switch(ftmn)
   \                     ??ftm_pwm_duty_0: (+1)
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD003             BEQ.N    ??ftm_pwm_duty_3
   \   00000038   0x2C02             CMP      R4,#+2
   \   0000003A   0xD017             BEQ.N    ??ftm_pwm_duty_4
   \   0000003C   0xD30B             BCC.N    ??ftm_pwm_duty_5
   \   0000003E   0xE020             B.N      ??ftm_pwm_duty_6
    491              {
    492                  //如果此处断言失败，说明占空比超过 100% ，务必自行检查是否出现这情况。
    493              case FTM0:
    494                  ASSERT(duty <= FTM0_PRECISON);     //用断言检测 占空比是否合理
   \                     ??ftm_pwm_duty_3: (+1)
   \   00000040   0xF242 0x7011      MOVW     R0,#+10001
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xD305             BCC.N    ??ftm_pwm_duty_7
   \   00000048   0xF44F 0x71F7      MOV      R1,#+494
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000050   0x.... 0x....      BL       assert_failed
    495                  break;
   \                     ??ftm_pwm_duty_7: (+1)
   \   00000054   0xE015             B.N      ??ftm_pwm_duty_8
    496          
    497              case FTM1:
    498                  ASSERT(duty <= FTM1_PRECISON);     //用断言检测 占空比是否合理
   \                     ??ftm_pwm_duty_5: (+1)
   \   00000056   0xF242 0x7011      MOVW     R0,#+10001
   \   0000005A   0x4286             CMP      R6,R0
   \   0000005C   0xD305             BCC.N    ??ftm_pwm_duty_9
   \   0000005E   0xF44F 0x71F9      MOV      R1,#+498
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000066   0x.... 0x....      BL       assert_failed
    499                  break;
   \                     ??ftm_pwm_duty_9: (+1)
   \   0000006A   0xE00A             B.N      ??ftm_pwm_duty_8
    500          
    501              case FTM2:
    502                  ASSERT(duty <= FTM2_PRECISON);     //用断言检测 占空比是否合理
   \                     ??ftm_pwm_duty_4: (+1)
   \   0000006C   0xF242 0x7011      MOVW     R0,#+10001
   \   00000070   0x4286             CMP      R6,R0
   \   00000072   0xD305             BCC.N    ??ftm_pwm_duty_10
   \   00000074   0xF44F 0x71FB      MOV      R1,#+502
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000007C   0x.... 0x....      BL       assert_failed
    503                  break;
   \                     ??ftm_pwm_duty_10: (+1)
   \   00000080   0xE7FF             B.N      ??ftm_pwm_duty_8
    504          
    505          #ifdef MK60F15
    506              case FTM3:
    507                  ASSERT(duty <= FTM3_PRECISON);     //用断言检测 占空比是否合理
    508                  break;
    509          #endif
    510          
    511              default:
    512                  break;
    513              }
    514          
    515          
    516              //占空比 = (CnV-CNTIN)/(MOD-CNTIN+1
    517              mod=ftm_mod[ftmn];
   \                     ??ftm_pwm_duty_6: (+1)
   \                     ??ftm_pwm_duty_8: (+1)
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000008C   0x4680             MOV      R8,R0
    518          
    519          
    520              switch(ftmn)
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD003             BEQ.N    ??ftm_pwm_duty_11
   \   00000094   0x2C02             CMP      R4,#+2
   \   00000096   0xD015             BEQ.N    ??ftm_pwm_duty_12
   \   00000098   0xD30A             BCC.N    ??ftm_pwm_duty_13
   \   0000009A   0xE01D             B.N      ??ftm_pwm_duty_14
    521              {
    522              case FTM0:
    523                  cv = (duty * (mod - 0 + 1)) / FTM0_PRECISON;
   \                     ??ftm_pwm_duty_11: (+1)
   \   0000009C   0xF118 0x0001      ADDS     R0,R8,#+1
   \   000000A0   0xFB00 0xF006      MUL      R0,R0,R6
   \   000000A4   0xF242 0x7110      MOVW     R1,#+10000
   \   000000A8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000AC   0x0007             MOVS     R7,R0
    524                  break;
   \   000000AE   0xE013             B.N      ??ftm_pwm_duty_15
    525          
    526              case FTM1:
    527                  cv = (duty * (mod - 0 + 1)) / FTM1_PRECISON;
   \                     ??ftm_pwm_duty_13: (+1)
   \   000000B0   0xF118 0x0001      ADDS     R0,R8,#+1
   \   000000B4   0xFB00 0xF006      MUL      R0,R0,R6
   \   000000B8   0xF242 0x7110      MOVW     R1,#+10000
   \   000000BC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000C0   0x0007             MOVS     R7,R0
    528                  break;
   \   000000C2   0xE009             B.N      ??ftm_pwm_duty_15
    529          
    530              case FTM2:
    531                  cv = (duty * (mod - 0 + 1)) / FTM2_PRECISON;
   \                     ??ftm_pwm_duty_12: (+1)
   \   000000C4   0xF118 0x0001      ADDS     R0,R8,#+1
   \   000000C8   0xFB00 0xF006      MUL      R0,R0,R6
   \   000000CC   0xF242 0x7110      MOVW     R1,#+10000
   \   000000D0   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000D4   0x0007             MOVS     R7,R0
    532                  break;
   \   000000D6   0xE7FF             B.N      ??ftm_pwm_duty_15
    533          
    534          #ifdef MK60F15
    535              case FTM3:
    536                  cv = (duty * (mod - 0 + 1)) / FTM3_PRECISON;
    537                  break;
    538          #endif
    539          
    540              default:
    541                  break;
    542              }
    543          
    544              // 配置FTM通道值
    545              FTM_CnV_REG(FTMN[ftmn], ch) = cv;
   \                     ??ftm_pwm_duty_14: (+1)
   \                     ??ftm_pwm_duty_15: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000E2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E4   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   000000E8   0x6107             STR      R7,[R0, #+16]
    546          
    547          }
   \   000000EA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    548          
    549          /*!
    550           *  @brief      设置FTM的频率
    551           *  @param      freq    频率（单位为Hz）
    552           *  @since      v5.0
    553           *  @note       修改PWM频率后，必须调用 ftm_pwm_duty 重新配置占空比。同一个模块，PWM频率必须相同。
    554           *  Sample usage:       ftm_pwm_freq(FTM0,200);    //设置 FTM0 的 频率 为 200Hz
    555           */

   \                                 In section .text, align 2, keep-with-next
    556          void ftm_pwm_freq(FTMn_e ftmn, uint32 freq)             //设置FTM的频率
    557          {
   \                     ftm_pwm_freq: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    558              uint32 clk_hz = (bus_clk_khz * 1000) >> 1;        //bus频率/2
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014   0x1046             ASRS     R6,R0,#+1
    559              uint32 mod;
    560              uint8 ps;
    561          
    562              /*       计算频率设置        */
    563              // 以 CPWMS = 0 ，即单边捕捉脉冲为例
    564              clk_hz = (bus_clk_khz * 1000) ;     // bus频率
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000020   0x4348             MULS     R0,R1,R0
   \   00000022   0x0006             MOVS     R6,R0
    565          
    566              mod = (clk_hz >> 16 ) / freq ;      // 临时用 mod 缓存一下
   \   00000024   0x0C30             LSRS     R0,R6,#+16
   \   00000026   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   0000002A   0x0007             MOVS     R7,R0
    567              ps = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4680             MOV      R8,R0
    568              while((mod >> ps) >= 1)             // 等 (mod >> ps) < 1 才退出 while 循环 ，即求 PS 的最小值
   \                     ??ftm_pwm_freq_0: (+1)
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0xFA30 0xF008      LSRS     R0,R0,R8
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??ftm_pwm_freq_1
    569              {
    570                  ps++;
   \   0000003A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000003E   0xE7F7             B.N      ??ftm_pwm_freq_0
    571              }
    572          
    573              ASSERT(ps <= 0x07);                 // 断言， PS 最大为 0x07 ，超过此值，则 PWM频率设置过低，或 Bus 频率过高
   \                     ??ftm_pwm_freq_1: (+1)
   \   00000040   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000044   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000048   0xDB05             BLT.N    ??ftm_pwm_freq_2
   \   0000004A   0xF240 0x213D      MOVW     R1,#+573
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000052   0x.... 0x....      BL       assert_failed
    574          
    575              mod = (clk_hz >> ps) / freq;        // 求 MOD 的值
   \                     ??ftm_pwm_freq_2: (+1)
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0xFA30 0xF008      LSRS     R0,R0,R8
   \   0000005C   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000060   0x0007             MOVS     R7,R0
    576          
    577              ftm_mod[ftmn]=mod;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0xF840 0x7024      STR      R7,[R0, R4, LSL #+2]
    578          
    579              /******************** 配置时钟和分频 ********************/
    580              FTM_SC_REG(FTMN[ftmn])    = ( 0
    581                                            //| FTM_SC_CPWMS_MASK         //0：上升沿计数模式 ，1： 跳变沿计数模式选择 （注释了表示 0）
    582                                            | FTM_SC_PS(ps)             //分频因子，分频系数 = 2^PS
    583                                            | FTM_SC_CLKS(1)            //时钟选择， 0：没选择时钟，禁用； 1：bus 时钟； 2：MCGFFCLK； 3：EXTCLK（ 由SIM_SOPT4 选择输入管脚 FTM_CLKINx）
    584                                            //| FTM_SC_TOIE_MASK        //溢出中断使能（注释了表示 禁止溢出中断）
    585                                          );
   \   0000006C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000070   0xF018 0x0007      ANDS     R0,R8,#0x7
   \   00000074   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000082   0x6008             STR      R0,[R1, #+0]
    586              FTM_CNTIN_REG(FTMN[ftmn]) = 0;      //计数器初始化值。设置脉冲宽度：(CnV - CNTIN).
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   0000008A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008C   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000090   0x64C8             STR      R0,[R1, #+76]
    587              FTM_MOD_REG(FTMN[ftmn])   = mod;    //模数, EPWM的周期为 ：MOD - CNTIN + 0x0001
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000009C   0x6087             STR      R7,[R0, #+8]
    588              FTM_CNT_REG(FTMN[ftmn])   = 0;      //计数器。只有低16位可用（写任何值到此寄存器，都会加载 CNTIN 的值）
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000AA   0x6048             STR      R0,[R1, #+4]
    589          }
   \   000000AC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    590          
    591          //////////////////////////////// 以上为输出PWM  //////////////////////////////////////////
    592          
    593          //////////////////////////////// 以下为输入捕捉 //////////////////////////////////////////
    594          
    595          /*!
    596           *  @brief      输入捕捉初始化函数
    597           *  @param      FTMn_e          模块号（FTM0、  FTM1、  FTM2）
    598           *  @param      FTM_CHn_e       通道号（CH0~CH7）
    599           *  @param      FTM_Input_cfg   输入捕捉触发条件配置
    600           *  @param      FTM_PS_e        分频因子
    601           *  @since      v5.0
    602           *  @note       同一个FTM，只能干一个活，用于输入捕捉后就不要再用于其他功能，例如PWM。
    603           *  Sample usage:       ftm_input_init(FTM0, FTM_CH0, FTM_Rising,FTM_PS_2);    //设置 FTM0_CH0上升沿触发输入捕捉，二分频
    604           */

   \                                 In section .text, align 2, keep-with-next
    605          void ftm_input_init(FTMn_e ftmn, FTM_CHn_e ch, FTM_Input_cfg cfg,FTM_PS_e ps)
    606          {
   \                     ftm_input_init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    607              ASSERT( (ftmn == FTM0) || ( (ftmn == FTM1 || ftmn == FTM2 ) && (ch <= FTM_CH1))
    608          #ifdef MK60F15
    609                      || (ftmn == FTM3)       //FX  有FTM3
    610          #endif
    611                     );  //检查传递进来的通道是否正确
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD00D             BEQ.N    ??ftm_input_init_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD002             BEQ.N    ??ftm_input_init_1
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C02             CMP      R4,#+2
   \   0000001A   0xD102             BNE.N    ??ftm_input_init_2
   \                     ??ftm_input_init_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D02             CMP      R5,#+2
   \   00000020   0xDB04             BLT.N    ??ftm_input_init_0
   \                     ??ftm_input_init_2: (+1)
   \   00000022   0xF240 0x2163      MOVW     R1,#+611
   \   00000026   0x....             LDR.N    R0,??DataTable10_2
   \   00000028   0x.... 0x....      BL       assert_failed
    612          
    613              /******************* 开启时钟 和 复用IO口*******************/
    614              FTM_port_mux(ftmn,ch);
   \                     ??ftm_input_init_0: (+1)
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       FTM_port_mux
    615          
    616              /******************* 设置为输入捕捉功能 *******************/
    617              switch(cfg)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD003             BEQ.N    ??ftm_input_init_3
   \   0000003E   0x2E02             CMP      R6,#+2
   \   00000040   0xD04B             BEQ.N    ??ftm_input_init_4
   \   00000042   0xD325             BCC.N    ??ftm_input_init_5
   \   00000044   0xE06D             B.N      ??ftm_input_init_6
    618              {
    619                  //输入捕捉模式下：DECAPEN = 0 ， DECAPEN = 0 ，CPWMS = 0， MSnB:MSnA = 0
    620          
    621                  // ELSnB:ELSnA         1          10          11
    622                  // 配置             上升沿      下降沿      跳变沿
    623          
    624              case FTM_Rising:    //上升沿触发
    625                  FTM_CnSC_REG(FTMN[ftmn], ch) |=  ( FTM_CnSC_ELSA_MASK  | FTM_CnSC_CHIE_MASK );                   //置1
   \                     ??ftm_input_init_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable10_5
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000054   0x....             LDR.N    R1,??DataTable10_5
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000062   0x68C9             LDR      R1,[R1, #+12]
   \   00000064   0xF051 0x0144      ORRS     R1,R1,#0x44
   \   00000068   0x60C1             STR      R1,[R0, #+12]
    626                  FTM_CnSC_REG(FTMN[ftmn], ch) &= ~( FTM_CnSC_ELSB_MASK  | FTM_CnSC_MSB_MASK | FTM_CnSC_MSA_MASK); //清0
   \   0000006A   0x....             LDR.N    R0,??DataTable10_5
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000078   0x....             LDR.N    R1,??DataTable10_5
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000086   0x68C9             LDR      R1,[R1, #+12]
   \   00000088   0xF031 0x0138      BICS     R1,R1,#0x38
   \   0000008C   0x60C1             STR      R1,[R0, #+12]
    627                  break;
   \   0000008E   0xE048             B.N      ??ftm_input_init_6
    628          
    629              case FTM_Falling:   //下降沿触发
    630                  FTM_CnSC_REG(FTMN[ftmn], ch) |= (FTM_CnSC_ELSB_MASK  | FTM_CnSC_CHIE_MASK );                    //置1
   \                     ??ftm_input_init_5: (+1)
   \   00000090   0x....             LDR.N    R0,??DataTable10_5
   \   00000092   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000094   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   0000009E   0x....             LDR.N    R1,??DataTable10_5
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   000000AC   0x68C9             LDR      R1,[R1, #+12]
   \   000000AE   0xF051 0x0148      ORRS     R1,R1,#0x48
   \   000000B2   0x60C1             STR      R1,[R0, #+12]
    631                  FTM_CnSC_REG(FTMN[ftmn], ch) &= ~( FTM_CnSC_ELSA_MASK | FTM_CnSC_MSB_MASK | FTM_CnSC_MSA_MASK); //清0
   \   000000B4   0x....             LDR.N    R0,??DataTable10_5
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BE   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   000000C2   0x....             LDR.N    R1,??DataTable10_5
   \   000000C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C6   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CC   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   000000D0   0x68C9             LDR      R1,[R1, #+12]
   \   000000D2   0xF031 0x0134      BICS     R1,R1,#0x34
   \   000000D6   0x60C1             STR      R1,[R0, #+12]
    632                  break;
   \   000000D8   0xE023             B.N      ??ftm_input_init_6
    633          
    634              case FTM_Rising_or_Falling: //上升沿、下降沿都触发
    635                  FTM_CnSC_REG(FTMN[ftmn], ch) |=  ( FTM_CnSC_ELSB_MASK | FTM_CnSC_ELSA_MASK  | FTM_CnSC_CHIE_MASK ); //置1
   \                     ??ftm_input_init_4: (+1)
   \   000000DA   0x....             LDR.N    R0,??DataTable10_5
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000E2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E4   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   000000E8   0x....             LDR.N    R1,??DataTable10_5
   \   000000EA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EC   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F2   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   000000F6   0x68C9             LDR      R1,[R1, #+12]
   \   000000F8   0xF051 0x014C      ORRS     R1,R1,#0x4C
   \   000000FC   0x60C1             STR      R1,[R0, #+12]
    636                  FTM_CnSC_REG(FTMN[ftmn], ch) &= ~( FTM_CnSC_MSB_MASK  | FTM_CnSC_MSA_MASK); //清0
   \   000000FE   0x....             LDR.N    R0,??DataTable10_5
   \   00000100   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000102   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   0000010C   0x....             LDR.N    R1,??DataTable10_5
   \   0000010E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000110   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000114   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000116   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   0000011A   0x68C9             LDR      R1,[R1, #+12]
   \   0000011C   0xF031 0x0130      BICS     R1,R1,#0x30
   \   00000120   0x60C1             STR      R1,[R0, #+12]
    637                  break;
    638              }
    639          
    640              FTM_SC_REG(FTMN[ftmn]) = ( 0
    641                                        | FTM_SC_CLKS(0x1)       //选择 bus 时钟
    642                                        | FTM_SC_PS(ps)          //选择 分频系数
    643                                       );
   \                     ??ftm_input_init_6: (+1)
   \   00000122   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000124   0xF017 0x0007      ANDS     R0,R7,#0x7
   \   00000128   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000012C   0x....             LDR.N    R1,??DataTable10_5
   \   0000012E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000130   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000134   0x6008             STR      R0,[R1, #+0]
    644              FTM_MODE_REG(FTMN[ftmn])    |= FTM_MODE_WPDIS_MASK; //禁止写保护
   \   00000136   0x....             LDR.N    R0,??DataTable10_5
   \   00000138   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000013E   0x6D40             LDR      R0,[R0, #+84]
   \   00000140   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000144   0x....             LDR.N    R1,??DataTable10_5
   \   00000146   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000148   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000014C   0x6548             STR      R0,[R1, #+84]
    645              FTM_COMBINE_REG(FTMN[ftmn]) = 0;
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x....             LDR.N    R1,??DataTable10_5
   \   00000152   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000154   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000158   0x6648             STR      R0,[R1, #+100]
    646              FTM_MODE_REG(FTMN[ftmn])    &= ~FTM_MODE_FTMEN_MASK;    //使能FTM
   \   0000015A   0x....             LDR.N    R0,??DataTable10_5
   \   0000015C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000162   0x6D40             LDR      R0,[R0, #+84]
   \   00000164   0x0840             LSRS     R0,R0,#+1
   \   00000166   0x0040             LSLS     R0,R0,#+1
   \   00000168   0x....             LDR.N    R1,??DataTable10_5
   \   0000016A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016C   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000170   0x6548             STR      R0,[R1, #+84]
    647              FTM_CNTIN_REG(FTMN[ftmn])   = 0;
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x....             LDR.N    R1,??DataTable10_5
   \   00000176   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000178   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000017C   0x64C8             STR      R0,[R1, #+76]
    648          
    649              FTM_STATUS_REG(FTMN[ftmn])  = 0x00;               //清中断标志位
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x....             LDR.N    R1,??DataTable10_5
   \   00000182   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000184   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000188   0x6508             STR      R0,[R1, #+80]
    650          
    651              //开启输入捕捉中断
    652              //enable_irq(FTM0_IRQn + ftmn);
    653          }
   \   0000018A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    654          
    655          /*!
    656           *  @brief      输入捕捉初始化函数
    657           *  @param      FTMn_e          模块号（FTM0、  FTM1、  FTM2）
    658           *  @param      FTM_CHn_e       通道号（CH0~CH7）
    659           *  @param      FTM_Input_cfg   输入捕捉触发条件配置
    660           *  @return     获取捕捉事件发生时的计数器值 (根据两次捕捉之间的差值可判断周期频率)
    661           *  @since      v5.0
    662           *  Sample usage:       uint16 data = ftm_input_get (FTM0, FTM_CH0) ;   // 获取FTM0_CH0输入捕捉事件触发时的计数值
    663           */

   \                                 In section .text, align 2, keep-with-next
    664          uint16   ftm_input_get (FTMn_e ftmn, FTM_CHn_e ch)
    665          {
   \                     ftm_input_get: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    666                  ASSERT( (ftmn == FTM0) || ( (ftmn == FTM1 || ftmn == FTM2 ) && (ch <= FTM_CH1))
    667          #ifdef MK60F15
    668                          || (ftmn == FTM3)       //FX  有FTM3
    669          #endif
    670                         );  //检查传递进来的通道是否正确
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00D             BEQ.N    ??ftm_input_get_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD002             BEQ.N    ??ftm_input_get_1
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xD102             BNE.N    ??ftm_input_get_2
   \                     ??ftm_input_get_1: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xDB04             BLT.N    ??ftm_input_get_0
   \                     ??ftm_input_get_2: (+1)
   \   0000001E   0xF240 0x219E      MOVW     R1,#+670
   \   00000022   0x....             LDR.N    R0,??DataTable10_2
   \   00000024   0x.... 0x....      BL       assert_failed
    671          
    672              return (uint16)FTM_CnV_REG(FTMN[ftmn],ch);    //保存
   \                     ??ftm_input_get_0: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10_5
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000036   0x6900             LDR      R0,[R0, #+16]
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    673          }
    674          

   \                                 In section .text, align 2, keep-with-next
    675          void     ftm_input_clean (FTMn_e ftmn)
    676          {
   \                     ftm_input_clean: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    677              ASSERT( ftmn < FTM_MAX);     //检查传递进来的通道是否正确
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C03             CMP      R4,#+3
   \   00000008   0xDB04             BLT.N    ??ftm_input_clean_0
   \   0000000A   0xF240 0x21A5      MOVW     R1,#+677
   \   0000000E   0x....             LDR.N    R0,??DataTable10_2
   \   00000010   0x.... 0x....      BL       assert_failed
    678          
    679              FTM_CNT_REG(FTMN[ftmn]) = 0;               //清 计数器计数值
   \                     ??ftm_input_clean_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable10_5
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000001E   0x6048             STR      R0,[R1, #+4]
    680          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    681          
    682          
    683          /*!
    684           *  @brief      FTM测试中断服务函数
    685           *  @since      v5.0
    686           *  @warning    此函数需要用户根据自己需求完成，这里仅仅是提供一个模版
    687           *  Sample usage:       set_vector_handler(FTM0_IRQn , FTM1_Input_test_handler);    //把 FTM1_Input_test_handler 函数添加到中断向量表，不需要我们手动调用
    688           */

   \                                 In section .text, align 2, keep-with-next
    689          void FTM1_Input_test_handler(void)
    690          {
    691              uint8 s = FTM1_STATUS;             //读取捕捉和比较状态  All CHnF bits can be checked using only one read of STATUS.
   \                     FTM1_Input_test_handler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40039050
   \   00000002   0x6800             LDR      R0,[R0, #+0]
    692              uint8 CHn;
    693          
    694              FTM1_STATUS = 0x00;             //清中断标志位
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             LDR.N    R3,??DataTable10_7  ;; 0x40039050
   \   00000008   0x601A             STR      R2,[R3, #+0]
    695          
    696              CHn = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0011             MOVS     R1,R2
    697              if( s & (1 << CHn) )
    698              {
    699                  //FTM_IRQ_DIS(FTM1, CHn);     //禁止输入捕捉中断
    700                  /*     用户任务       */
    701          
    702                  /*********************/
    703                  //FTM_IRQ_EN(FTM1, CHn); //开启输入捕捉中断
    704          
    705              }
    706          
    707              /* 这里添加 n=1 的模版，根据模版来添加 */
    708              CHn = 1;
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x0011             MOVS     R1,R2
    709              if( s & (1 << CHn) )
    710              {
    711                  //FTM_IRQ_EN(FTM1, CHn); //开启输入捕捉中断
    712                  /*     用户任务       */
    713          
    714          
    715                  /*********************/
    716                  //不建议在这里开启输入捕捉中断
    717                  //FTM_IRQ_EN(FTM1, CHn); //开启输入捕捉中断
    718              }
    719          }
   \   00000012   0x4770             BX       LR               ;; return
    720          
    721          //////////////////////////////// 以上为输入捕捉  //////////////////////////////////////////
    722          
    723          //////////////////////////////// 以下为正交解码 //////////////////////////////////////////
    724          
    725          /*!
    726           *  @brief      初始化FTM 的正交解码 功能
    727           *  @param      FTMn_e    模块号（ FTM1、  FTM2）
    728           *  @since      v5.0
    729           *  Sample usage:       ftm_quad_init(FTM1);    //初始化 FTM1 为正交解码模式
    730           */

   \                                 In section .text, align 2, keep-with-next
    731          void ftm_quad_init(FTMn_e ftmn)
    732          {
   \                     ftm_quad_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    733              ASSERT( (ftmn == FTM1) || (ftmn == FTM2 ) ); //检查传递进来的通道是否正确
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD007             BEQ.N    ??ftm_quad_init_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD004             BEQ.N    ??ftm_quad_init_0
   \   00000010   0xF240 0x21DD      MOVW     R1,#+733
   \   00000014   0x....             LDR.N    R0,??DataTable10_2
   \   00000016   0x.... 0x....      BL       assert_failed
    734          
    735              /******************* 开启时钟 和 复用IO口*******************/
    736              switch(ftmn)
   \                     ??ftm_quad_init_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD002             BEQ.N    ??ftm_quad_init_1
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD011             BEQ.N    ??ftm_quad_init_2
   \   00000026   0xE021             B.N      ??ftm_quad_init_3
    737              {
    738          
    739              case FTM1:
    740                  SIM_SCGC6 |= SIM_SCGC6_FTM1_MASK;       //使能FTM1时钟
   \                     ??ftm_quad_init_1: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10  ;; 0x4004803c
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   00000030   0x....             LDR.N    R1,??DataTable10  ;; 0x4004803c
   \   00000032   0x6008             STR      R0,[R1, #+0]
    741                  if((FTM1_QDPHA_PIN == PTA8) || (FTM1_QDPHA_PIN == PTB0) )                 //管脚复用
    742                  {
    743                      port_init(FTM1_QDPHA_PIN, ALT6);
    744                  }
    745                  else if(FTM1_QDPHA_PIN == PTA12)
    746                  {
    747                      port_init(FTM1_QDPHA_PIN, ALT7);
   \   00000034   0xF44F 0x61E0      MOV      R1,#+1792
   \   00000038   0x200C             MOVS     R0,#+12
   \   0000003A   0x.... 0x....      BL       port_init
    748                  }
    749                  else
    750                  {
    751                      ASSERT(0);                          //断言，配置的管脚不符合要求
    752                  }
    753          
    754                  if((FTM1_QDPHB_PIN == PTA9) ||(FTM1_QDPHB_PIN == PTB1))
    755                  {
    756                      port_init(FTM1_QDPHB_PIN, ALT6);
    757                  }
    758                  else if(FTM1_QDPHB_PIN == PTA13)
    759                  {
    760                      port_init(FTM1_QDPHB_PIN, ALT7);
   \   0000003E   0xF44F 0x61E0      MOV      R1,#+1792
   \   00000042   0x200D             MOVS     R0,#+13
   \   00000044   0x.... 0x....      BL       port_init
    761                  }
    762                  else
    763                  {
    764                      ASSERT(0);                          //断言，配置的管脚不符合要求
    765                  }
    766                  break;
   \   00000048   0xE015             B.N      ??ftm_quad_init_4
    767          
    768              case FTM2:
    769                  SIM_SCGC3 |= SIM_SCGC3_FTM2_MASK;                           //使能FTM2时钟
   \                     ??ftm_quad_init_2: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40048030
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000052   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40048030
   \   00000054   0x6008             STR      R0,[R1, #+0]
    770                  if((FTM2_QDPHA_PIN == PTA10) || (FTM2_QDPHA_PIN == PTB18))                  //管脚复用
    771                  {
    772                      port_init(FTM2_QDPHA_PIN, ALT6);
   \   00000056   0xF44F 0x61C0      MOV      R1,#+1536
   \   0000005A   0x2032             MOVS     R0,#+50
   \   0000005C   0x.... 0x....      BL       port_init
    773                  }
    774                  else
    775                  {
    776                      ASSERT(0);                          //断言，配置的管脚不符合要求
    777                  }
    778          
    779                  if((FTM2_QDPHB_PIN == PTA11) || (FTM2_QDPHB_PIN == PTB19) )                 //管脚复用
    780                  {
    781                      port_init(FTM2_QDPHB_PIN, ALT6);
   \   00000060   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000064   0x2033             MOVS     R0,#+51
   \   00000066   0x.... 0x....      BL       port_init
    782                  }
    783                  else
    784                  {
    785                      ASSERT(0);                          //断言，配置的管脚不符合要求
    786                  }
    787                  break;
   \   0000006A   0xE004             B.N      ??ftm_quad_init_4
    788              default:
    789                  ASSERT(0);                              //断言，配置的模块有误
   \                     ??ftm_quad_init_3: (+1)
   \   0000006C   0xF240 0x3115      MOVW     R1,#+789
   \   00000070   0x....             LDR.N    R0,??DataTable10_2
   \   00000072   0x.... 0x....      BL       assert_failed
    790                  break;
    791              }
    792          
    793              FTM_MODE_REG(FTMN[ftmn])  |=    (0
    794                                               | FTM_MODE_WPDIS_MASK  //写保护禁止
    795                                               | FTM_MODE_FTMEN_MASK   //使能 FTM
    796                                              );
   \                     ??ftm_quad_init_4: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable10_5
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000007E   0x6D40             LDR      R0,[R0, #+84]
   \   00000080   0xF050 0x0005      ORRS     R0,R0,#0x5
   \   00000084   0x....             LDR.N    R1,??DataTable10_5
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000008C   0x6548             STR      R0,[R1, #+84]
    797          //    FTM_QDCTRL_REG(FTMN[ftmn]) |=   (0
    798          //                                    | FTM_QDCTRL_QUADMODE_MASK
    799          //                                     );
    800              FTM_QDCTRL_REG(FTMN[ftmn]) &= ~FTM_QDCTRL_QUADMODE_MASK; //选定编码模式为A相与B相编码模式
   \   0000008E   0x....             LDR.N    R0,??DataTable10_5
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000096   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000009A   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000009E   0x....             LDR.N    R1,??DataTable10_5
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000A6   0xF8C1 0x0080      STR      R0,[R1, #+128]
    801              FTM_CNTIN_REG(FTMN[ftmn])   = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x....             LDR.N    R1,??DataTable10_5
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000B4   0x64C8             STR      R0,[R1, #+76]
    802              FTM_MOD_REG(FTMN[ftmn])     = 10000;//FTM_MOD_MOD_MASK;
   \   000000B6   0xF242 0x7010      MOVW     R0,#+10000
   \   000000BA   0x....             LDR.N    R1,??DataTable10_5
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000C2   0x6088             STR      R0,[R1, #+8]
    803              //FTM_SC_REG(FTMN[ftmn]) |= FTM_SC_CLKS(3);  //选择外部时钟
    804              FTM_QDCTRL_REG(FTMN[ftmn]) |=   (0
    805                                              | FTM_QDCTRL_QUADEN_MASK
    806                                               );
   \   000000C4   0x....             LDR.N    R0,??DataTable10_5
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000CC   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   000000D0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000D4   0x....             LDR.N    R1,??DataTable10_5
   \   000000D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D8   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000DC   0xF8C1 0x0080      STR      R0,[R1, #+128]
    807              FTM_MODE_REG(FTMN[ftmn])  |= FTM_QDCTRL_QUADEN_MASK;
   \   000000E0   0x....             LDR.N    R0,??DataTable10_5
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000E8   0x6D40             LDR      R0,[R0, #+84]
   \   000000EA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000EE   0x....             LDR.N    R1,??DataTable10_5
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   000000F6   0x6548             STR      R0,[R1, #+84]
    808              FTM_CNT_REG(FTMN[ftmn])     = 0;                    //计数器。只有低16位可用（写任何值到此寄存器，都会加载 CNTIN 的值）
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x....             LDR.N    R1,??DataTable10_5
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000102   0x6048             STR      R0,[R1, #+4]
    809              
    810          }
   \   00000104   0xBD10             POP      {R4,PC}          ;; return
    811          
    812          /*!
    813           *  @brief      获取FTM 正交解码 的脉冲数
    814           *  @param      FTMn_e    模块号（ FTM1、  FTM2）
    815           *  @since      v5.0
    816           *  Sample usage:       int16 count = ftm_quad_get(FTM1);    //获取  FTM1 交解码 的脉冲数
    817           */

   \                                 In section .text, align 2, keep-with-next
    818          int16 ftm_quad_get(FTMn_e ftmn)
    819          {
   \                     ftm_quad_get: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    820              int16 val;
    821              ASSERT( (ftmn == FTM1) || (ftmn == FTM2 ) );        //检查传递进来的通道是否正确
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD007             BEQ.N    ??ftm_quad_get_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD004             BEQ.N    ??ftm_quad_get_0
   \   00000010   0xF240 0x3135      MOVW     R1,#+821
   \   00000014   0x....             LDR.N    R0,??DataTable10_2
   \   00000016   0x.... 0x....      BL       assert_failed
    822              val = FTM_CNT_REG(FTMN[ftmn]);
   \                     ??ftm_quad_get_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable10_5
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0x0005             MOVS     R5,R0
    823          
    824              return val;
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    825          }
    826          
    827          /*!
    828           *  @brief      清 FTM 正交解码 的脉冲数
    829           *  @param      FTMn_e    模块号（ FTM1、  FTM2）
    830           *  @since      v5.0
    831           *  Sample usage:       ftm_quad_clean(FTM1);    //复位 FTM1 正交解码 的脉冲数
    832           */

   \                                 In section .text, align 2, keep-with-next
    833          void ftm_quad_clean(FTMn_e ftmn)
    834          {
   \                     ftm_quad_clean: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    835              ASSERT( (ftmn == FTM1) || (ftmn == FTM2 ) ); //检查传递进来的通道是否正确
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD007             BEQ.N    ??ftm_quad_clean_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD004             BEQ.N    ??ftm_quad_clean_0
   \   00000010   0xF240 0x3143      MOVW     R1,#+835
   \   00000014   0x....             LDR.N    R0,??DataTable10_2
   \   00000016   0x.... 0x....      BL       assert_failed
    836          
    837              FTM_CNT_REG(FTMN[ftmn])     = 0;             //计数器。只有低16位可用（写任何值到此寄存器，都会加载 CNTIN 的值）
   \                     ??ftm_quad_clean_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable10_5
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000024   0x6048             STR      R0,[R1, #+4]
    838          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ftm_mod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     FTMN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     mod1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40039050         DC32     0x40039050

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 53H, 74H, 75H, 64H, 79H
   \              0x5C 0x53    
   \              0x74 0x75    
   \              0x64 0x79    
   \   00000008   0x5C 0x32          DC8 5CH, 32H, 30H, 31H, 36H, 0B5H, 0E7H, 0D7H
   \              0x30 0x31    
   \              0x36 0xB5    
   \              0xE7 0xD7    
   \   00000010   0xD3 0xC9          DC8 0D3H, 0C9H, 0E8H, 0BCH, 0C6H, 0B4H, 0F3H, 0C8H
   \              0xE8 0xBC    
   \              0xC6 0xB4    
   \              0xF3 0xC8    
   \   00000018   0xFC 0x5C          DC8 0FCH, 5CH, 54H, 69H, 5CH, 0B5H, 0E7H, 0C8H
   \              0x54 0x69    
   \              0x5C 0xB5    
   \              0xE7 0xC8    
   \   00000020   0xFC 0xB1          DC8 0FCH, 0B1H, 0B8H, 0D3H, 0C3H, 0B5H, 0D7H, 0B2H
   \              0xB8 0xD3    
   \              0xC3 0xB5    
   \              0xD7 0xB2    
   \   00000028   0xE3 0x5C          DC8 0E3H, 5CH, 43H, 68H, 69H, 70H, 5CH, 73H
   \              0x43 0x68    
   \              0x69 0x70    
   \              0x5C 0x73    
   \   00000030   0x72 0x63          DC8 72H, 63H, 5CH, 4DH, 4BH, 36H, 30H, 5FH
   \              0x5C 0x4D    
   \              0x4B 0x36    
   \              0x30 0x5F    
   \   00000038   0x66 0x74          DC8 66H, 74H, 6DH, 2EH, 63H, 0
   \              0x6D 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0
    839          
    840          
    841          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FTM1_Input_test_handler
      16   FTM_port_mux
        16   -> port_init
       8   ftm_input_clean
         8   -> assert_failed
      16   ftm_input_get
        16   -> assert_failed
      24   ftm_input_init
        24   -> FTM_port_mux
        24   -> assert_failed
      24   ftm_pwm_duty
        24   -> assert_failed
      24   ftm_pwm_freq
        24   -> assert_failed
      40   ftm_pwm_init
        40   -> FTM_port_mux
        40   -> assert_failed
       8   ftm_quad_clean
         8   -> assert_failed
      16   ftm_quad_get
        16   -> assert_failed
       8   ftm_quad_init
         8   -> assert_failed
         8   -> port_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
      64  ?_0
      20  FTM1_Input_test_handler
      12  FTMN
     280  FTM_port_mux
      34  ftm_input_clean
      60  ftm_input_get
     396  ftm_input_init
      12  ftm_mod
     238  ftm_pwm_duty
     176  ftm_pwm_freq
     412  ftm_pwm_init
      40  ftm_quad_clean
      44  ftm_quad_get
     262  ftm_quad_init
       4  mod1

 
    16 bytes in section .bss
    12 bytes in section .data
    64 bytes in section .rodata
 1 994 bytes in section .text
 
 1 994 bytes of CODE  memory
    64 bytes of CONST memory
    28 bytes of DATA  memory

Errors: none
Warnings: none
